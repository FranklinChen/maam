\documentclass[10pt,letter,english]{article}

\usepackage{amsmath}
\usepackage{amscd}
\usepackage{amssymb}

\usepackage{tikz}
\usetikzlibrary{arrows}

\usepackage[sc,osf]{mathpazo}
\linespread{1.05}         % Palatino needs more leading (space between lines)
\usepackage[T1]{fontenc}
\fontencoding{T1}
\fontfamily{ppl}
\fontseries{m}
\fontshape{n}
\fontsize{10}{13}
\selectfont

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Set Theory Concepts

\newcommand{\buildset}[2]{\{ #1 \;|\; #2 \}}
\newcommand{\compose}[0]{\circ}

\newcommand{\partto}{\rightharpoonup}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Textual Macros

\newcommand{\aam}[0]{\textsc{aam}}
\newcommand{\maam}[0]{\textsc{maam}}
\newcommand{\js}[0]{JavaScript}
\newcommand{\lambdajs}[0]{$\lambda_{JS}$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Machine Configurations

\newcommand{\cek}[3]{\langle #1, #2, #3 \rangle}
\newcommand{\cesk}[4]{\langle #1, #2, #3, #4 \rangle}
\newcommand{\cessk}[5]{\langle #1, #2, #3, #4, #5 \rangle}
\newcommand{\cesskc}[6]{\langle #1, #2, #3, #4, #5, #6 \rangle}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\title{MJSAI: Designing a Sound, Configurable, Efficient, and Pushdown %
              Monadic Static~Analyzer for JavaScript}
\author{{David Darais and Daniel King}\\
        School of Engineering and Applied Sciences\\
        Harvard University}

\maketitle

\section*{Abstract}

We present the design and implementation of a static analyzer for \js{}. We
leverage the Monadic Abstracting Abstract Machines (\maam{}) technique to
create an analysis which is both configurable and correct by construction. We
also recast pushdown static analysis in terms of \aam{}. This recasting permits
us to also easily create a pushdown \maam{} analysis for \js{}.

\section{Introduction}

This work had three goals:

\begin{itemize}
\item Design a configurable static analysis for javascript using the
  Monadic Abstracting Abstract Machines (\maam{}, \cite{maam}) design process.
\item Implement the analysis using the \maam{} framework as implemented in Haskell.
\item Analyze the performance of many different analysis techniques, including
  pushdown analysis, against the JSAI \cite{jsai} benchmark suite.
\end{itemize}

We completed the first goal, part of the second, and none of the third.
%
We underestimated the time necessary to implement the semantics of \js{} in the
\maam{} Haskell framework.
%
We were unable to complete a full implementation of the \js{} spec and
therefore unable to run our interpreter on the full JSAI~\cite{jsai} benchmark
suite.
%
However, we were successful in running our analysis on programs which reside in
the subset of \js{} that we were able to implement.
%
We also spent a significant amoutn of time understanding pushdown analysis and
recasting it in the \aam{} and \maam frameworks.

The remainder of the paper presents the design and implementation of the
analysis, including subsections on our understanding of pushdown analysis.

\section{Design}
\subsection{Pushdown Analysis in MAAM}

Pushdown analysis means different things to different people. There is a
significant amount of work on first-order pushdown semantics, but we focus on
understanding the higher-order setting. There are primarily two papers which
describe a pushdown analysis for a higher-order setting: Vardoulakis and
Shivers' \emph{CFA2} \cite{cfa2} and Earl, Might, and Van Horn's \emph{PDCFA}
\cite{pdcfa}. Both papers share the idea of \emph{precise call-return matching}
and some form of \emph{memoization}. The former improves the precision and the
latter improves the time-efficiency of the analysis. The \emph{CFA2} analysis
also precisely tracks so-called \emph{stack} variables. We will not describe
this technique in detail other than to say that it involves identifying
variables which can safely live on the call stack and tracking their values
exactly. Unfortunately, even if one ignores the special \emph{stack} variables,
it is not obvious that the two techniques describe the same style of
analysis. The presentations styles differ dramatically: \emph{CFA2} describes a
Cousot \& Cousot style Abstract Interpretation whereas \emph{PDCFA} describes
the conversion of an abstract machine into a Dyck state graph.

We propose a unification of these two approaches using the \aam{} technique of
Might and Van Horn \cite{aam}. There are two simple ideas that lead to a
pushdown style analysis: a separate, path-sensitive store for continuations and
a memo table for caching analysis results. We claim, without proof, that the
path-sensitive continuation-store provides \emph{precise call-return matching}.

We now describe an AAM-style approach to pushdown static analysis for a standard CEK machine.
%
Recall that a CEK machine is a state machine with three components:
%
\begin{enumerate}
\item The control expression $(c : Exp)$
\item The execution environment $(\rho : Var \rightarrow Val)$
\item The continuation $(k : List Frame)$
\end{enumerate}
%
In AAM-style, we first design an instrument concrete semantics.
%
This instrumented concrete semantics will yield a semantically equivalent
concrete interpreter, but with implementation choices which, after abstraction,
will yield an analysis with different properties.
%
To instrument the semantics for a pushdown analysis we:
\begin{enumerate}
\item Break the recursion between environments and values a. la. AAM \cite{aam}
\item Break the recursion between cons-cells in the list type for continuations.
%
This step is also in the discipline of AAM \cite{aam}, although this particular
choice is not made in their original paper.
%
\item Add a memo-table which caches the results of the analysis.
%
This memo-table caches results \emph{invariant to the continuation present during evaluation}.
\end{enumerate}

From steps 1. and 2. we end up with a C-E-S-KS-K* machine with the following components:
\begin{enumerate}
\item The control expression $(c : Exp)$ as before
\item The environment $(\rho : Var \rightarrow Addr)$
\item The store $(\sigma : Addr \rightarrow Val)$
\item The continuation store $(\kappa\sigma : KAddr \rightarrow \mathcal{P}(Frame + \{Null\}))$
\item The continuation pointer $(\kappa-ptr : KAddr)$
\end{enumerate}

\begin{proposition}
A step relation
\begin{equation*}
\mapsto^{PD} \in CESKSK* \times CESKSK* 
\end{equation*}
is definable which agrees with the standard semantics
\begin{equation*}
\mapsto \in CEK \times CEK 
\end{equation*}
\end{proposition}

Step 3. yields a larger machine, C-E-S-KS-K*-\$ machine, which adds a new component:
\begin{equation*}
\$ : C \times E \times S \rightarrow Val + \{SEEN\} + \{UNSEEN\}
\end{equation*}
%
The fact that the cache can memoize invariant to the continuation is
traditionally understoon in the pushdown literature as by-product of viewing
the semantics a pushdown automata.
%
We propose another intuition: the CEK machine comes from a \emph{reduction}
semantics--a setting where reduction is defined invariant to context to begin
with.

\begin{figure}
\centering

\begin{equation*}
\begin{array}{c c l c l}
  c            &:& Exp        && \\
  \rho         &:& Env        &=& Var   \partto Addr \\
  \sigma       &:& Store      &=& Addr  \partto Value \\
  \kappa\sigma &:& KStore     &=& KAddr \partto Frame \times KAddr \\
  \kappa       &:& KAddr      && \\
  \$         &:& Cache      &=& Exp \times Store \times Env \partto Value
\end{array}
\end{equation*}


\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.5cm,
  thick,main node/.style={font=\sffamily\bfseries}]

  \node[main node] (101) at (0, 1)
    {$\cek{c}{\rho}{\kappa}$};
  \node[main node] (102) [right of = 101]
    {$\cesk{c}{\rho}{\sigma}{\kappa}$};
  \node[main node] (103) [right of = 102]
    {$\cessk{c}{\rho}{\sigma}{\kappa\sigma}{\kappa}$};
  \node[main node] (104) [right of = 103]
    {$\cesskc{c}{\rho}{\sigma}{\kappa\sigma}{\kappa}{\$}$};

  \path[->]
    (101) edge node {Step 1} (102)
    (102) edge node {Step 2} (103)
    (103) edge node {Step 3} (104);

\end{tikzpicture}
\caption{An AAM-style approach for producing a pushdown abstract machine} \label{fig:M1}
\end{figure}

\subsection{A JavaScript Analysis in MAAM}

\js{} has a large, complex specification and many implementations which
practically define the expected semantics of \js{}. Rather than describe and
implement our own semantics, we implement the \lambdajs{} semantics as described
in \cite{lambdajs}. Additionally, we reused their desugaring program.

We reformulated the \lambdajs{} semantics into a reduction machine
semantics. The \lambdajs{} evaluation contexts became our \emph{Frame} data
type. Additionally, we do not divide the evaluation contexts into two sets and
use syntactic stepping rules to implement exceptional control flow. We choose to
implement exceptional control flow with meta functions that crawl the stack
looking for appropriate return points.

\section{Implementation}

\begin{figure}
\centering

\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=5cm,
  thick,main node/.style={font=\sffamily\bfseries}]

  \node[main node] (101) at (0, 1)
    {JS Code};
  \node[main node] (102) [right of = 101]
    {\lambdajs{} Code};
  \node[main node] (103) [right of = 102]
    {Analysis Results};

  \path[->]
    (101) edge node {Parse \& Desugar} (102)
    (102) edge node {\maam{} Analyzer} (103);

\end{tikzpicture}
\caption{The Architecture of Our Analysis System. The second arrow is original work.}
\end{figure}



\section{Related Work}
\subsection{The Essence of JavaScript: \lambdajs{}}

The \lambdajs{} work provides a complete, practical foundation to perform
research on real-world JavaScript programs. The \lambdajs{} work identifies a
simplified language that captures the essential features of \js{}. The
\lambdajs{} language is the composition of four distinct semantics: function and
object semantics, mutable references, prototypal inheritance, and control
operators. In the authors' experience, implementing this semantics is time
consuming, but mindless. The complexity of \js{} is not apparent in the
\lambdajs{} model.

The complexity of \js{} is fully captured by a desugaring phase which replaces
certain forms, such as \texttt{with}, with simpler \js{} code. Additionally, the
\lambdajs{} team has an implementation of the \js{} standard library which
abstracts away the details of string and number coercions. These coercions are
specified by many pages of non-trivial pseudo-code in the ECMAScript 3rd Edition
standard.

\section{Conclusion}



\bibliography{paper}{}
\bibliographystyle{acm}

\end{document}
