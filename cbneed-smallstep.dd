# Overview

This is a small-step semantics for a call-by-need CPS language with lambdas and
datatypes.

I claim this is what you would get if you took the standard AAM Krivine machine
[AAM 2010] and applied a CPS discipline. The CPS transformation is used as a
purely syntactic discipline to:

1. Eliminate administrative, stack-manipulating semantic transitions.
2. Ensure that the only expressions treated lazily are function applications
   and recursive variable references.

# Direct Style Syntax

The source syntax looks like this:

    l   ∈ Lit
    con ∈ Symbol
    x   ∈ Var
    e   ∈ Exp ::=
      l
      x
      DATA(con,e₁,...,eₙ)
      λ(x) → e
      LET x := e₁ IN e₂
      LETREC { x₁ := e₁ ; ... ; xₙ := eₙ } IN e
      CASE e OF { (con₁,e₁₁,...,e₁ₙ) → e₁ ; ... ; (conₘ,eₘ₁,...,eₘₙ) → eₘ }
      @F(e₁,e₂)

# CPS Syntax

For the CPS syntax we distinguish source variables |Var|, continuation
variables |KVar| and reference variables |RVar|. Although continuation
variables give names to continuation values, continuations are still second
class values and cannot flow to source variable binders. Reference variables
only exist as unique names for reference allocation sites in the abstract
semantics.

    l     ∈ Lit
    con   ∈ Symbol
    x     ∈ Var
    k     ∈ KVar
    r     ∈ RVar

The CPS syntax is stratified into |Pico|, |Atom| and |Call| expressions.
|Pico| expressions are a variable or literal; |Atom| expressions are those
which can be computed immediately: lambdas and thunked function application;
and |Call| expressions are those which require arbitrary amounts of computation
to evaluate. |Call| expressions contain nested |Atom| expressions in let
bindings and nested |Pico| expressions in function applications and case
branching (other than the tail |Call| in let and case expressions).

    p ∈ Pico ::= x | l
    a ∈ Atom ::= 
      p
      λ(x,k) → c 
      THUNK[r,xᵣ,k](p₁,p₂)
    ka ∈ KAtom ::=
      k
      λ(x) → c 
    c ∈ Call ::= 
      LET x := a IN c
      LET k := ka IN c
      REC [r₁,xᵣ₁,x₁] ... [rₙ,xᵣₙ,xₙ] IN c
      LETREC { x₁ := a₁ ; ... ; xₙ := aₙ } IN c
      @K(k,p)
      @F(p₁,p₂,k)
      CASE(p) OF { (con₁,x₁₁,...,x₁ₙ) → c₁ ; ... ; (conₘ,xₘ₁,...,xₘₙ) → cₘ }
      HALT(p)

The |THUNK[r,xᵣ,k](p,p)| syntax holds binders:

- |r|: The unique name for allocating the reference cell.
- |xᵣ|: The name for allocating values that are returned from evaluating the
  reference cell.
- |k|: The name for allocating the continuation that pushes this thunk's
  evaluation on the stack.

The |REC[r,xᵣ,x]| syntax holds binders:

- |r|: The unique name for allocating the reference cell.
- |xᵣ|: The name for allocating values taht are returned from evaluating the
  reference cell.
- |x|: The source-level binder name.

# CPS Conversion

The CPS conversion demonstrates how source |LETREC| forms desugar into CPS
|REC| and |LETREC| forms. This CPS conversion take a meta-continuations as an
argument and reifies the meta-continuation when necessary. In the
implementation we do even better, keeping a continuation either meta-level or
object-level and only reifying or reflecting it if necessary.

    CPS : Exp × (Pico → Call) → Call
    CPS(l,k) := k(l)
    CPS(x,k) := k(x)
    CPS(DATA(con,e₁,...,eₙ),k) :=
      CPS(e₁,λ(p₁) → ... (CPS(eₙ,λ(pₙ) →
      LET x₁ := p₁ IN
      ...
      LET xₙ := pₙ IN
      LET x  := DATA(con,p₁,...,pₙ) IN
      k(x)
        where x fresh
    CPS(λ(x) → e,k) := 
      LET x := λ(x,k') → CPS(e,λ(p) → @K(k',p)) IN
      k(x)
        where x,k' fresh
    CPS(LET x := e₁ IN e₂,k) :=
      CPS(e₁,λ(p) → 
      LET x := p IN 
      CPS(e₂,k))
    CPS(LETREC { x₁ := e₁ ; ... ; xₙ := eₙ } IN e,k) :=
      REC [r₁,xᵣ₁,x₁] ... [rₙ,xᵣₙ,xₙ] IN
      CPS(e₁,λ(p₁) → ... (CPS(eₙ,λ(pₙ) → 
      LETREC { x₁ := p₁ ; ... ; xₙ := pₙ } IN
      CPS(e,k))) ... )
        where r₁,xᵣ₁,...,rₙ,xᵣₙ fresh
    CPS(CASE(e) OF { (con₁,x₁₁,...,x₁ₙ) → e₁ ; (conₘ,xₘ₁,...,xₘₙ) → eₘ },k) :=
      CPS(e,λ(p) →
      CASE p OF { (con₁,x₁₁,...,x₁ₙ) → CPS(e₁,k) ; (con,xₘ₁,...,xₘₙ) → CPS(eₘ,k) })
    CPS(@F(e₁,e₂),k) :=
      CPS(e₁,λ(p₁) →
      CPS(e₂,λ(p₂) →
      LET x := THUNK[r,xᵣ,k](p₁,p₂) IN
      k(x)))
        where r,xᵣ,k fresh

Notice that the CPS translation does not create any |@F| expressions. This is
because |@F| is treated as a forcing function call, none of which are present
in the source. Forcing function calls |@F| arise as the result of entering a
thunk, and entering a thunk arises from case expressions or another forcing
function call.

# Concrete Dynamic Semantics

    τ     ∈ Time
    tick  ∈ Call × Time → Time
    𝓁     ∈ Addr
    alloc ∈ AnyVar × Time → Addr

    v ∈ Val ::= 
      l 
      DATA(con,𝓁₁,...,𝓁ₙ)
      ⟨λ(x,k) → c,ρ⟩ 
      REF[x](r)
    kv ∈ KVal ::=
      ⟨λ(x) → c,ρ⟩ 
      ⟨λ![𝓁,v](x) → c,ρ⟩
    rv ∈ RVal ::=
      FORCED(v)
      ⟨THUNK[k](p₁,p₂),ρ⟩ 

|REF| values contain a reference location (allocated by |r|) which points to
either a forced or thunked value. The second continuation form |⟨λ![𝓁,v](x) →
c,ρ⟩| is just like a standard continuation but with added behavior: before
continuing to its body |c| it looks up the location |𝓁| and replaces any
occurences of |v| with the bound argument.

    x,k,r ∈ AnyVar  := Var  ∪ KVar ∪ RVar
    p,k,r ∈ AnyPico := Pico ∪ KVar ∪ RVar
    a,k,r ∈ AnyAtom := Atom ∪ KVar ∪ RVar
    v,kv  ∈ AnyVal  := Val  ∪ KVal

    ρ     ∈ Env     := AnyVar ⇀ Addr
    σ     ∈ Store   := Addr ⇀ AnyVal


The concrete semantics are given through denotation functions |𝒜ᶜ| and |𝒫ᶜ|,
and a small-step transition relation |_~~>ᶜ_|.

    𝒫ᶜ ∈ AnyPico → Env × Store → AnyVal
    𝒫ᶜ⟦x⟧(ρ,σ) = σ(ρ(x))
    𝒫ᶜ⟦l⟧(ρ,σ) = l

    𝒜ᶜ    ∈ AnyAtom → Env × Store × Time → AnyVal × Store
    𝒜ᶜ⟦p⟧(ρ,σ,τ) = (𝒫ᶜ⟦p⟧(ρ,σ),σ)
    𝒜ᶜ⟦λ(x,k) → c⟧(ρ,σ,τ) = (⟨λ(x,k) → c,ρ⟩,σ)
    𝒜ᶜ⟦THUNK[r,xᵣ,k](p₁,p₂)⟧(ρ,σ,τ) = (REF[xᵣ](𝓁ᵣ),σ[𝓁ᵣ ↦ ⟨THUNK[k](p₁,p₂),ρ⟩])
      where 𝓁ᵣ := alloc(r,τ)

The denotation for |THUNK| atmoic expressions evaluates to a new reference cell
with its value bound to a thunk closure.

    ς     ∈ Σ := Call × Env × Store × Time
    _~~>ᶜ_ ∈ Σ × Σ

The let-style commands are simple; they update the environment and store with
new values and proceed to the nested call. |REC-C| creates reference cells for
recursive bindings and |LETREC-C| fills them in.

    [LET-C]
    ⟨LET x := a IN c,ρ,σ,τ⟩ ~~>ᶜ ⟨c,ρ',σ'',tick(τ)⟩
      where 
        (v,σ') := 𝒜ᶜ⟦a⟧(ρ,σ,τ) 
        𝓁ₓ     := alloc(x,τ)
        ρ'     := ρ[x ↦ 𝓁ₓ]
        σ''    := σ'[𝓁ₓ ↦ v]

    [REC-C]
    ⟨REC [r₁,xᵣ₁,x₁] ... [rₙ,xᵣₙ,xₙ] IN c,ρ,σ,τ⟩ ~~>ᶜ ⟨c,ρ',σ',tick(τ)⟩
      where 
        𝓁ᵣ₁ := alloc(r₁,τ) , ... , 𝓁ᵣₙ := alloc(rₙ,τ)
        𝓁ₓ₁ := alloc(x₁,τ) , ... , 𝓁ₓₙ := alloc(xₙ,τ)
        ρ'  := ρ[x₁ ↦ 𝓁ₓ₁,...,xₙ ↦ 𝓁ₓₙ]
        σ'  := σ[𝓁ₓ₁ ↦ REF[xᵣ₁](𝓁ᵣ₁),...,𝓁ₓₙ ↦ REF[xᵣₙ](𝓁ᵣₙ)]

    [LETREC-C]
    ⟨LETREC { x₁ := a₁ ; ... ; xₙ := aₙ } IN c,ρ,σ,τ⟩ ~~>ᶜ ⟨c,ρ,σ',tick(τ)⟩
      where 
        REF[xᵣ₁](𝓁₁) := σ(ρ(x₁)) , ... , REF[xᵣₙ](𝓁ₙ) := σ(ρ(xₙ))
        (v₁,σ₁)      := 𝒜ᶜ⟦a₁⟧(ρ,σ,τ) , ... , (vₙ,σₙ) := 𝒜ᶜ⟦aₙ⟧(ρ,σₙ₋₁,τ) 
        σ'           := σₙ[𝓁₁ ↦ v₁,...,𝓁ₙ ↦ vₙ]

Continuation applications continue with the continuation body and environment.
The |KON-MEMO-C| rule implements the semantics of memoization. The set
difference with |[𝓁' ↦ v]| in [KON-MEMO-C] is redundant because the new value
will overwrite the old one, but its abstraction will become meaningful and
important in the abstract semantics.

    [KON-C]
    ⟨@K(p₁,p₂),ρ,σ,τ⟩ ~~>ᶜ ⟨c,ρ'',σ',σ)],tick(τ)⟩
      where 
        ⟨λ(x) → c,ρ'⟩ := 𝒫ᶜ⟦p₁⟧(ρ,σ)
        𝓁ₓ            := alloc(x,τ)
        ρ''           := ρ'[x ↦ 𝓁ₓ]
        σ'            := σ[𝓁ₓ ↦ 𝒫ᶜ⟦p₂⟧(ρ,σ)]

    [KON-MEMO-C]
    ⟨@K(p₁,p₂),ρ,σ,τ⟩ ~~>ᶜ ⟨c,ρ'',σ',tick(τ)⟩
      where 
        ⟨λ![𝓁,v](x) → c,ρ'⟩ := 𝒫ᶜ⟦p₁⟧(ρ,σ)
        𝓁ₓ                  := alloc(x,τ)
        ρ''                 := ρ'[x ↦ 𝓁ₓ]
        σ'                  := (σ ∩ ¬[𝓁' ↦ v])[𝓁ₓ ↦ 𝒫ᶜ⟦p₂⟧(ρ,σ),𝓁 ↦ 𝒫ᶜ⟦p⟧(ρ,σ)]

Function application has three cases:

1. The first atom is a function, in which case the function is applied.
2. The first atom is a forced value, in which case the value is retrieved and
   the application is attempted again.
2. The first atom is a thunk, in which case the thunk is jumped to and the
   current application context is pushed on the stack.

    [FUN-VAL-C]
    ⟨@F(p₁,p₂,p₃),ρ,σ,τ⟩ ~~>ᶜ ⟨c,ρ'',σ',tick(τ)⟩
      where 
        ⟨λ(x,k) → c,ρ'⟩ := 𝒫ᶜ⟦p₁⟧(ρ,σ)
        𝓁ₓ              := alloc(x,τ) 
        𝓁ₖ              := alloc(k,τ)
        ρ''             := ρ'[x ↦ 𝓁ₓ,k ↦ 𝓁ₖ]
        σ'              := σ[𝓁ₓ ↦ 𝒫ᶜ⟦p₂⟧(ρ,σ),𝓁ₖ ↦ 𝒫ᶜ⟦p₃⟧(ρ,σ)]

    [FUN-FORCED-C]
    ⟨@F(p₁,p₂,p₃),ρ,σ,τ⟩ ~~>ᶜ ⟨@F(x,p₂,p₃),ρ',σ',tick(τ)⟩
      where 
        REF[x](𝓁) := 𝒫ᶜ⟦p₁⟧(ρ,σ)
        FORCED(v) := σ(𝓁) 
        𝓁ₓ        := alloc(x,τ)
        ρ'        := ρ[x ↦ 𝓁ₓ]
        σ'        := σ[𝓁ₓ ↦ v]

    [FUN-THUNK-C]
    ⟨@F(p₁,p₂,p₃),ρ,σ,τ⟩ ~~>ᶜ ⟨@F(p₁',p₂',k),ρ'[k ↦ 𝓁ₖ],σ',tick(τ)⟩
      where 
        REF[x](𝓁)              := 𝒫ᶜ⟦p₁⟧(ρ,σ)
        ⟨THUNK[k](p₁',p₂'),ρ'⟩ := σ(𝓁) 
        𝓁ₖ                     := alloc(k,τ)
        ρ''                    := ρ'[k ↦ 𝓁ₖ]
        σ'                     := σ[𝓁ₖ ↦ ⟨λ![𝓁,σ(𝓁)](x) → @F(x,p₂,p₃),ρ⟩]

Case expressions similarly have three cases:

1. The atom is a data construction, in which case the case branch is executed.
2. The atom is a forced value, in which case the value is retrieved and the
   case is attempted again.
2. The atom is a thunk, in which case the thunk is jumped to and the
   current case context is pushed on the stack.

    [CASE-VAL-C]
    ⟨CASE(p) OF { con₁(x₁₁,...,x₁ₙ) → c₁ ; ... ; conᵢ(xᵢ₁,...,xᵢₙ) → cᵢ ; ... ; conₘ(xₘ₁,...,xₘₙ) → cₘ},ρ,σ,τ⟩ ~~>ᶜ ⟨cᵢ,ρ',σ',tick(τ)⟩
      where 
        DATA(conᵢ,𝓁₁,...,𝓁ₙ) := 𝒫ᶜ⟦p⟧(ρ,σ)
        𝓁ₓ₁                  := alloc(xᵢ₁,τ) , ... , 𝓁ₓₙ := alloc(xᵢₙ,τ)
        ρ'                   := ρ[xᵢ₁ ↦ 𝓁ₓ₁,...,xᵢₙ ↦ 𝓁ₓₙ]
        σ'                   := σ[𝓁ₓ₁ ↦ σ(𝓁₁),...,𝓁ₓₙ ↦ σ(𝓁ₙ)]

    [CASE-FORCED-C]
    ⟨CASE(p) OF { alts },ρ,σ,τ⟩ ~~>ᶜ ⟨CASE(x) OF { alts },ρ',σ',tick(τ)⟩
      where 
        REF[x](𝓁) := 𝒫ᶜ⟦p⟧(ρ,σ)
        FORCED(v) := σ(𝓁) 
        𝓁ₓ        := alloc(x,τ)
        ρ'        := ρ[x ↦ 𝓁ₓ]
        σ'        := σ[𝓁ₓ ↦ v]

    [CASE-THUNK-C]
    ⟨CASE(p) OF { alts },ρ,σ,τ⟩ ~~>ᶜ ⟨@F(p₁',p₂',k),ρ'',σ',tick(τ)⟩
      where 
        REF[x](𝓁)              := 𝒫ᶜ⟦p⟧(ρ,σ)
        ⟨THUNK[k](p₁',p₂'),ρ'⟩ := σ(𝓁) 
        𝓁ₖ                     := alloc(k,τ)
        ρ''                    := ρ'[k ↦ 𝓁ₖ]
        σ'                     := σ[𝓁ₖ ↦ ⟨λ![𝓁,σ(𝓁)](x) → CASE(x) OF { alts },ρ⟩]

The notation in |CASE-VAL-C| is a little strange. |conᵢ| matches with the i'th
constructor in the sequence of |Alt| expressions and |xᵢ₁,...,xᵢₙ| is the
sequence of binders attached to that branch.

# Abstract Dynamic Semantics

The abstract semantics are just like the concrete semantics except:

1. It is non-deterministic.
2. It is approximating--values are merged into the store rather than updated.

These two characteristics allow for (or arise from) making the state space
finite, which is essential for a computable analysis.

For simplicity, it is assumed that the value space is abstracted as a powerset
of concrete values. This does not yet yield a finite state space, but going
from powerset to something finite with a lattice structure is a simple matter
of replace union and intersection (|∪| and |∩|) with join and meet (|⊔| and
|⊓|). We still write join (|⊔|) when merging two stores, which will perform a
union (|∪|) on value sets in the codomain. Notationally we write |v| to range
over values and capitalized as |V| to range over powersets of values.

The only difference between the abstract semantics are a replacement of |:=|
with |∈| when evaluating pico expressions with |𝒫|, and updating the store
monotonically with join (|⊔|) rather than with replacement.

    σ ∈ Store := Addr → ℙ(AnyVal)

    𝒫ᵃ : Pico → (Env × Store) → ℙ(AnyVal)
    𝒫ᵃ⟦x⟧(ρ,σ) = σ(ρ(x))
    𝒫ᵃ⟦l⟧(ρ,σ) = {l}

    𝒜ᵃ : Atom → Env × Store × Time → ℙ(AnyVal) × Store
    𝒜ᵃ⟦p⟧(ρ,σ,τ) = (𝒫ᵃ⟦p⟧(ρ,σ),σ)
    𝒜ᵃ⟦λ(x,k) → c⟧(ρ,σ,τ) = ({⟨λ(x,k) → c,ρ⟩},σ)
    𝒜ᵃ⟦THUNK[r,xᵣ,k](p₁,p₂)⟧(ρ,σ,τ) = ({REF[xᵣ](𝓁ᵣ)},σ ⊔ [𝓁ᵣ ↦ ⟨THUNK[k](p₁,p₂),ρ⟩])
      where 𝓁ᵣ := alloc(r,τ)

    [LET-A]
    ⟨LET x := a IN c,ρ,σ,τ⟩ ~~>ᵃ ⟨c,ρ',σ'',tick(τ)⟩
      where 
        (V,σ') := 𝒜ᵃ⟦a⟧(ρ,σ,τ) 
        𝓁ₓ     := alloc(x,τ)
        ρ'     := ρ[x ↦ 𝓁ₓ]
        σ''    := σ' ⊔ [𝓁ₓ ↦ v]

    [REC-A]
    ⟨REC [r₁,xᵣ₁,x₁] ... [rₙ,xᵣₙ,xₙ] IN c,ρ,σ,τ⟩ ~~>ᵃ ⟨c,ρ',σ',tick(τ)⟩
      where 
        𝓁ᵣ₁ := alloc(r₁,τ) , ... , 𝓁ᵣₙ := alloc(rₙ,τ)
        𝓁ₓ₁ := alloc(x₁,τ) , ... , 𝓁ₓₙ := alloc(xₙ,τ)
        ρ'  := ρ[x₁ ↦ 𝓁ₓ₁,...,xₙ ↦ 𝓁ₓₙ]
        σ'  := σ ⊔ [𝓁ₓ₁ ↦ REF[xᵣ₁](𝓁ᵣ₁),...,𝓁ₓₙ ↦ REF[xᵣₙ](𝓁ᵣₙ)]

    [LETREC-A]
    ⟨LETREC { x₁ := a₁ ; ... ; xₙ := aₙ } IN c,ρ,σ,τ⟩ ~~>ᵃ ⟨c,ρ,σ',tick(τ)⟩
      where 
        REF[xᵣ₁](𝓁₁)  ∈ σ(ρ(x₁)) , ... , REF[xᵣₙ](𝓁ₙ)  ∈ σ(ρ(xₙ))
        (V₁,σ₁)      := 𝒜ᵃ⟦a₁⟧(ρ,σ,τ) , ... , (vₙ,σₙ) := 𝒜ᵃ⟦aₙ⟧(ρ,σₙ₋₁,τ) 
        σ'           := σₙ ⊔ [𝓁₁ ↦ v₁,...,𝓁ₙ ↦ vₙ]

    [KON-A]
    ⟨@K(p₁,p₂),ρ,σ,τ⟩ ~~>ᵃ ⟨c,ρ'',σ',σ)],tick(τ)⟩
      where 
        ⟨λ(x) → c,ρ'⟩  ∈ 𝒫ᵃ⟦p₁⟧(ρ,σ)
        𝓁ₓ            := alloc(x,τ)
        ρ''           := ρ'[x ↦ 𝓁ₓ]
        σ'            := σ ⊔ [𝓁ₓ ↦ 𝒫ᵃ⟦p₂⟧(ρ,σ)]

    [KON-MEMO-A]
    ⟨@K(p₁,p₂),ρ,σ,τ⟩ ~~>ᵃ ⟨c,ρ'',σ',tick(τ)⟩
      where 
        ⟨λ![𝓁,v](x) → c,ρ'⟩  ∈ 𝒫ᵃ⟦p₁⟧(ρ,σ)
        𝓁ₓ                  := alloc(x,τ)
        ρ''                 := ρ'[x ↦ 𝓁ₓ]
        σ'                  := (σ ⊓ ¬[𝓁' ↦ v]) ⊔ [𝓁ₓ ↦ 𝒫ᵃ⟦p₂⟧(ρ,σ),𝓁 ↦ 𝒫ᵃ⟦p⟧(ρ,σ)]

    [FUN-VAL-A]
    ⟨@F(p₁,p₂,p₃),ρ,σ,τ⟩ ~~>ᵃ ⟨c,ρ'',σ',tick(τ)⟩
      where 
        ⟨λ(x,k) → c,ρ'⟩  ∈ 𝒫ᵃ⟦p₁⟧(ρ,σ)
        𝓁ₓ              := alloc(x,τ) 
        𝓁ₖ              := alloc(k,τ)
        ρ''             := ρ'[x ↦ 𝓁ₓ,k ↦ 𝓁ₖ]
        σ'              := σ ⊔ [𝓁ₓ ↦ 𝒫ᵃ⟦p₂⟧(ρ,σ),𝓁ₖ ↦ 𝒫ᵃ⟦p₃⟧(ρ,σ)]

    [FUN-FORCED-A]
    ⟨@F(p₁,p₂,p₃),ρ,σ,τ⟩ ~~>ᵃ ⟨@F(x,p₂,p₃),ρ',σ',tick(τ)⟩
      where 
        REF[x](𝓁)  ∈ 𝒫ᵃ⟦p₁⟧(ρ,σ)
        FORCED(v)  ∈ σ(𝓁) 
        𝓁ₓ        := alloc(x,τ)
        ρ'        := ρ[x ↦ 𝓁ₓ]
        σ'        := σ ⊔ [𝓁ₓ ↦ v]

    [FUN-THUNK-A]
    ⟨@F(p₁,p₂,p₃),ρ,σ,τ⟩ ~~>ᵃ ⟨@F(p₁',p₂',k),ρ'[k ↦ 𝓁ₖ],σ',tick(τ)⟩
      where 
        REF[x](𝓁)               ∈ 𝒫ᵃ⟦p₁⟧(ρ,σ)
        ⟨THUNK[k](p₁',p₂'),ρ'⟩  ∈ σ(𝓁) 
        𝓁ₖ                     := alloc(k,τ)
        ρ''                    := ρ'[k ↦ 𝓁ₖ]
        σ'                     := σ ⊔ [𝓁ₖ ↦ ⟨λ![𝓁,σ(𝓁)](x) → @F(x,p₂,p₃),ρ⟩]

    [CASE-VAL-A]
    ⟨CASE(p) OF { con₁(x₁₁,...,x₁ₙ) → c₁ ; ... ; conᵢ(xᵢ₁,...,xᵢₙ) → cᵢ ; ... ; conₘ(xₘ₁,...,xₘₙ) → cₘ},ρ,σ,τ⟩ ~~>ᵃ ⟨cᵢ,ρ',σ',tick(τ)⟩
      where 
        DATA(conᵢ,𝓁₁,...,𝓁ₙ)  ∈ 𝒫ᵃ⟦p⟧(ρ,σ)
        𝓁ₓ₁                  := alloc(xᵢ₁,τ) , ... , 𝓁ₓₙ := alloc(xᵢₙ,τ)
        ρ'                   := ρ[xᵢ₁ ↦ 𝓁ₓ₁,...,xᵢₙ ↦ 𝓁ₓₙ]
        σ'                   := σ ⊔ [𝓁ₓ₁ ↦ σ(𝓁₁),...,𝓁ₓₙ ↦ σ(𝓁ₙ)]

    [CASE-FORCED-A]
    ⟨CASE(p) OF { alts },ρ,σ,τ⟩ ~~>ᵃ ⟨CASE(x) OF { alts },ρ',σ',tick(τ)⟩
      where 
        REF[x](𝓁)  ∈ 𝒫ᵃ⟦p⟧(ρ,σ)
        FORCED(v)  ∈ σ(𝓁) 
        𝓁ₓ        := alloc(x,τ)
        ρ'        := ρ[x ↦ 𝓁ₓ]
        σ'        := σ ⊔ [𝓁ₓ ↦ v]

    [CASE-THUNK-A]
    ⟨CASE(p) OF { alts },ρ,σ,τ⟩ ~~>ᵃ ⟨@F(p₁',p₂',k),ρ'',σ',tick(τ)⟩
      where 
        REF[x](𝓁)               ∈ 𝒫ᵃ⟦p⟧(ρ,σ)
        ⟨THUNK[k](p₁',p₂'),ρ'⟩  ∈ σ(𝓁) 
        𝓁ₖ                     := alloc(k,τ)
        ρ''                    := ρ'[k ↦ 𝓁ₖ]
        σ'                     := σ ⊔ [𝓁ₖ ↦ ⟨λ![𝓁,σ(𝓁)](x) → CASE(x) OF { alts },ρ⟩]
