% any author declaration will be ignored  when using 'plid' option (for double blind review)
\documentclass[pldi]{sigplanconf}

% From PLDI Template {-{

% \usepackage{SIunits}            % typset units correctly
\usepackage{courier}            % standard fixed width font
\usepackage[scaled]{helvet} % see www.ctan.org/get/macros/latex/required/psnfss/psnfss2e.pdf
\usepackage{url}                  % format URLs
\usepackage{listings}          % format code
\usepackage{enumitem}      % adjust spacing in enums
\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   % hyperlinks, including DOIs and URLs in bibliography
% known bug: http://tex.stackexchange.com/questions/1522/pdfendlink-ended-up-in-different-nesting-level-than-pdfstartlink
\newcommand{\doi}[1]{doi:~\href{http://dx.doi.org/#1}{\Hurl{#1}}}   % print a hyperlinked DOI

% }-}

% Setup {-{

\usepackage{fontspec}
\setmainfont{CMU Serif}   % unicode variant of CM

\usepackage{amsmath}      % \begin{align*}
\usepackage{amssymb}      % \leadsto
\usepackage{bm}           % bold maths
\usepackage{unicode-math} % unicode maths
\usepackage{galois}       % \galois

\usepackage{float}        % \begin{figure}
\floatstyle{boxed}
\restylefloat{figure}

% }-}

% Macros {-{

\newcommand{\lamif}{\textbf{Œª-IF}\@}

\newcommand{\ifz}[3]{\pmb{\operatorname{if0}} (#1)\{#2\}\{#3\}}
\newcommand{\lam}{\pmb{Œª}}
\newcommand{\indor}{\;|\;}
\newcommand{\plus}{\pmb{+}}
\newcommand{\minus}{\pmb{-}}
\newcommand{\op}{\mathbin{op}}
\newcommand{\ap}{\;\;}
\newcommand{\steps}{\leadsto}
\newcommand{\ddo}{\underline{\operatorname{do}}}
\newcommand{\case}[1]{\text{\underline{case} $#1$ \underline{of}}}
\newcommand{\getkon}{\operatorname{get-Kon}}
\newcommand{\putkon}{\operatorname{put-Kon}}
\newcommand{\pushkon}{\operatorname{push-Kon}}
\newcommand{\popkon}{\operatorname{pop-Kon}}
\newcommand{\getenv}{\operatorname{get-Env}}
\newcommand{\putenv}{\operatorname{put-Env}}
\newcommand{\ret}{\operatorname{return}}
\newcommand{\toclo}{\operatorname{to-clo}}
\newcommand{\mif}[3]{\text{\underline{if} $#1$ \underline{then} $#2$ \underline{else} $#3$}}
\newcommand{\stepf}{\operatorname{step}}
\newcommand{\atomf}{\operatorname{atom}}
\newcommand{\branchOnSet}{\operatorname{branch-on-set}}
\newcommand{\intI}{\operatorname{int-I}}
\newcommand{\ifzE}{\operatorname{if0-E}}
\newcommand{\cloI}{\operatorname{clo-I}}
\newcommand{\cloE}{\operatorname{clo-E}}
\newcommand{\aintI}{\widehat{\operatorname{int-I}}}
\newcommand{\aifzE}{\widehat{\operatorname{if0-E}}}
\newcommand{\acloI}{\widehat{\operatorname{clo-I}}}
\newcommand{\acloE}{\widehat{\operatorname{clo-E}}}
\newcommand{\adelta}{\widehat{\delta}}
\newcommand{\st}{\;|\;}
\newcommand{\coerce}[1]{\operatorname{‚Üì_{#1}}}
\newcommand{\failonbot}{\operatorname{‚Üë_‚ä•}}
\newcommand{\liftnondet}{\operatorname{‚Üë_ùí´ }}
\newcommand{\AVal}{\widehat{Val}}
\newcommand{\AEnv}{\widehat{Env}}
\newcommand{\mplus}{\mathbin{‚ü®+‚ü©}}
\newcommand{\AAddr}{\widehat{Addr}}
\newcommand{\ATime}{\widehat{Time}}
\newcommand{\AStore}{\widehat{Store}}
\newcommand{\aalloc}{\widehat{alloc}}
\newcommand{\atick}{\widehat{tick}}

% }-}

\begin{document}

\title{Modular Static Analysis: Orthogonal Design, Correct by Construction}
\maketitle

% Abstract {-{
% \begin{abstract}
% \end{abstract}
% }-}

% Introduction {-{
% \section{Introduction}

% }-}

% Modular Analysis by Example {-{
\section{Modular Analysis by Example}

To demonstrate our framework we will grow a concrete semantics into an executable analysis in small steps.
% Should I resist the pun? :P -DD
Each step will expose some property of the analysis to be tuned independent of other properties.
We use an applied lambda calculus as an example language to demonstrate our approach.

% Concrete Semantics {-{
\subsection{Concrete Semantics}

Our example language is \lamif, an applied lambda caluclus with integers and conditional statements.
The syntax for \lamif\ is given in figure~\ref{lamif:syntax}.

\begin{figure}[t]
\caption{\lamif\ syntax.}
\label{lamif:syntax}
\input{snips/00_Semantics/00_Syntax.tex}
\end{figure}

We will use a standard small-step semantics for \lamif, which is shown in figure~\ref{lamif:semantics}.

\begin{figure}[t]
\caption{\lamif\ semantics.}
\label{lamif:semantics}
\input{snips/00_Semantics/01_Semantics.tex}
\end{figure}

Analyses in our framework are least fixed point computations over a collecting semantics.
A collecting semantics for \lamif\ is defined as:
\begin{equation*}
  Œº(œÇ). œÇ‚ÇÄ ‚äî œÇ ‚äî \{ œÇ' \st œÇ \steps œÇ' \}
\end{equation*}
where $œÇ‚ÇÄ := ‚ü® e‚ÇÄ , ‚ä• , ‚àô ‚ü©$ is the injection of the initial program $e‚ÇÄ$ into the state space $Œ£$.

% }-}

% From Semantics to Interpreter {-{
\subsection{From Semantics to Interpreter}
\label{interpreter}

On our way to an executable analysis for \lamif, we first evolve the small-step relation into an executable small-step interpreter.
We write this interpreter in monadic style for two reasons.
First, it is much easier to add new states and rules to a monadic interpreter.
Second, we will exploit the monadic abstraction to expose flow and path sensitivities in a later section.

The interpreter will use two types monadic effects: state and partiality.
The operations for state effects are get and put, and the operation for the partiality effect is $‚ä•$.
For reference: monadic, state and partiality operations have the following types:

\input{snips/01_Interpreter/00_MonadOps.tex}
%\input{snips/01_Interpreter/01_StateOps.tex}
%\input{snips/01_Interpreter/02_PartialityOps.tex}

We construct a monad $‚Ñ≥ $ for our interpreter which combines state effects for $Env$ and $Kon$ with a partiality effect.
The type $‚Ñ≥ $ is just a simple type:
\input{snips/01_Interpreter/03_MonadType.tex}

We factor the definition of the interpreter into two parts: one for atomic and one for compound expressions.
Atomic expressions return to the top frame of the stack:
\input{snips/01_Interpreter/04_Atomic.tex}

Our interpreter uses helper functions $ùíú ‚ü¶\_‚üß$, $\pushkon$, $\popkon$, $\delta$, $\coerce{Clo}$, and $\failonbot$.
The function $ùíú ‚ü¶\_‚üß$ is the denotation function which uses the monadic state effect for environments:
\input{snips/01_Interpreter/05_AtomDen.tex}

Functions $\pushkon$ and $\popkon$ interact with effects for both continuation state and partiality:
\input{snips/01_Interpreter/06_PushPopKon.tex}

The function $\delta$ gives the expected denotation to operators:
\input{snips/01_Interpreter/07_Delta.tex}

The function $\coerce{Clo}$ is a function from types which include closure values to partial closures.
\input{snips/01_Interpreter/08_CoerceClo.tex}

The function $\failonbot$ lifts partial values to monadic values, mapping $‚ä•$ to $‚ä•$.
\input{snips/01_Interpreter/09_FailOnBot.tex}

Our small-step interpreter is defined by dispatching to $\atomf$ or pushing continuation frames for compound expressions.
\input{snips/01_Interpreter/10_Exp.tex}

\paragraph{Correctness and Execution}

As before, we must construct a collecting semantics in order to define an executable analysis.
To do this, we must relate our small-step interpreter to a state machine transition function.
That is, we must relate our interpreter of type $Exp ‚Üí ‚Ñ≥ (Exp)$ to a state transition of type $Œ£ ‚Üí Œ£$ for \emph{some} $Œ£$.

For this interpreter the state space $Œ£$ is defined $Œ£ := {(Exp √ó Env √ó Kon)}_‚ä•$.
To establish the correctness of $Œ£$ we construct an isomorphism between $Exp ‚Üí ‚Ñ≥ (Exp)$ and $Œ£ ‚Üí Œ£$.
We use the standard isomorphisim between Kleisli morphisms $Œ± ‚Üí ‚Ñ≥ (Œ≤)$ and $‚Ñ≥ (Œ±) ‚Üí ‚Ñ≥ (Œ≤)$ where $‚Ñ≥ $ is the partiality monad ${(\_)}_‚ä•$.
To execute the analysis we transport the interpreter through the isomorphism and find the least fixed point of the collecting semantics.

% }-}

% Exposing the Abstract Domain {-{
\subsection{Exposing the Abstract Domain}

We will now expose the choice of abstract domain for the interpreter.
However, giving a finite abstract domain for integers alone will not yet give a computable analysis.
There will still be an infinite number of possible abstract state spaces due to the recursion between closures and environments.
We will address this issue in a future modification to the interpreter.

To expose the choice of abstract domain we introduce a type $\AVal$ behind an abstract interface:
\input{snips/02_AbstractDomain/00_AVal.tex}

This abstraction forces us to use an abstract environment, mapping variables to abstract values:
\input{snips/02_AbstractDomain/01_AEnv.tex}
and re-implement $ùíú ‚ü¶\_‚üß$:
\input{snips/02_AbstractDomain/02_AtomDen.tex}

Before implementing $\atomf$ we must reconsider our monadic effects.
Because we have abstracted values, our interpreter must consider \emph{sets} of possible states resulting from conditionals and function calls.
We introduce this nondeterminism as an effect in the monad, taking the place of partiality (which was just nondeterminism with zero or one branches).
Nondeterminism has two operators, $‚ä•$ as we've seen before, and $\mplus$ which branches to both left and right monadic computation.
The effects for our monadic type are now:
\input{snips/02_AbstractDomain/03_Effects.tex}
and to support these effects we redefine $‚Ñ≥ $ to be:
\input{snips/02_AbstractDomain/04_MonadType.tex}

Our definition for $\atomf$ now uses nondeterminism effects:
\input{snips/02_AbstractDomain/05_Atomic.tex}

Helper function $\liftnondet$ is the analog of $\failonbot$ for lifting sets into monads with nondeterminism:
\input{snips/02_AbstractDomain/06_LiftNonDet.tex}

\paragraph{Correctness and Execution}

To construct a collecting semantics we again construct an isomorphism between $Exp ‚Üí ‚Ñ≥ (Exp)$ and $Œ£$ where $Œ£ := ùí´ (Exp √ó \AEnv √ó Kon)$.
This isomorphism is again the standard one between Kleisli morphisms $Œ± ‚Üí ‚Ñ≥ (Œ≤)$ and $‚Ñ≥ (Œ±) ‚Üí ‚Ñ≥ (Œ≤)$ where $‚Ñ≥ $ is the powerset monad $ùí´ $.

Now that we have a parameter to the analysis, $\AVal$, we can discuss what an analysis is and what it means for it to be correct.
An analysis is some instantiation of $\AVal$ to $\AVal‚ÇÅ$ where $Val\galois{Œ±}{Œ≥}\AVal‚ÇÅ$.
Furthermore, each operation in the $\AVal$ interface must be an abstraction of concrete versions, namely $\intI ‚äë Œ≥ (\aintI‚ÇÅ)$, $\ifzE ‚äë Œ≥ (\aifzE‚ÇÅ)$, etc.
This local argument about $\AVal‚ÇÅ$, coupled with the monotonicity of $\stepf$ and the isomorphism between $Exp ‚Üí ‚Ñ≥ (Exp)$ and $Œ£ ‚Üí Œ£$, 
  gives us an end to end correctness argument for our executable abstract interpreter.
At this point our analysis is still not yet decidable; the abstract state space is still infinite.

% }-}

% Exposing Context Sensitivity {-{
\subsection{Exposing Context Sensitivity}

To expose context sensitivity (also called call-site sensitivity) we instantiate the AAM approach of cutting recursion in the state space to our framework.
This conceptually takes place in two steps.
First we introduce indirection between values and environments through a store and a type of addresses.
Second we abstract the choice of address to achieve an analysis.

We introduce abstract time and addresses behind an interface:
\input{snips/03_ContextSensitivity/00_AAM.tex}
which alters the definition of the monad to contain new state components:
\input{snips/03_ContextSensitivity/01_StateSpace.tex}

[LEFT OFF HERE]

% }-}

% Exposing Flow Sensitivity {-{
\subsection{Exposing Flow Sensitivity}

Novel in this work is the ability to expose flow sensitivity as an orthogonal parameter to a static analysis.
To do this we exploit both the monadic abstraction and our correctness framework which relates monadic actions to state machine transitions.
\emph{Our insight is that both computational and correctness components of flow-sensitivity can be obtain by varying the monad for the interpreter alone.}

The anlyses we have constructed thus far are path sensitive, meaning they will follow branching control flow precisely.
We can see that the analysis is path sensitive by inspecting the state space $Œ£$ that it induces: $ Œ£ := ùí´ (Exp √ó \AEnv √ó Kon √ó \ATime √ó \AStore)$.
A flow insensitive analysis pulls the store out of the powerset to a single global store: $Œ£ := (ùí´ (Exp √ó \AEnv √ó Kon √ó \ATime) √ó \AStore)$.
A flow sensitive path insensitive analysis shares the state space of path sensitivity but employs store widening to keep the state space explosion under control.
In this section we will show how variations in the monad can recover all three analysis variants: path sensitive, flow sensitive, and flow insensitive.

% }-}

% Intentional Optimizations {-{
\subsection{Intentional Optimizations}

\subsubsection{Abstract Garbage Collection}

\subsubsection{Flat Closures}

% }-}

% }-}

% Summary {-{
\section{Summary}

Our final interpreter enjoys the following properties:
\begin{itemize}
\item Abstract Domain can be altered independent of other features.
\item Flow Sensitivity can be altered independent of other features.
\item Context Sensitivity (and its granularity) can be altered indepndend of other features.
\item Intensional optimizations can be implemented once and integrate seamlessly with any of the above choices.
\item New state space components and their widening properties can be added seamlessly using compositional building blocks.
\item Interpreters are automatically related to a collecting semantics, enabling a straight forward least-fixed-point implementation strategy.
\item All analyses are correct by construction with no additional proof burdon beyond interpreter monotonicity and correctness of orthoganal parameters piecewise.
\end{itemize}

% }-}

\end{document}
