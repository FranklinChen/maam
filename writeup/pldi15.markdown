# Introduction

Traditional practice in the program analysis via abstract interpretation is to
fix a language (as a concrete semantics) and an abstraction (as an abstraction
map, concretization map or Galois connection) before constructing a static
analyzer that it sound with respect to both the abstraction and the concrete
semantics.  Thus, each pairing of abstraction and semantics requires a one-off
manual derivation of the abstract semantics and a construction of a proof of
soundness.

Work has focused on endowing abstractions with knobs, levers, and dials to tune
precision and compute efficiently.  These parameters come with overloaded
meanings such as object-, context-, path-, and heap-sensitivities, or some
combination thereof.  These efforts develop families of analyses _for a
specific language_ and prove the framework sound.

But this framework approach suffers from many of the same drawbacks as the
one-off analyzers.  They are language-specific, preventing reuse of concepts
across languages and require similar re-implementations and soundness proofs.
This process is still manual, tedious, difficult and error-prone.    And,
changes to the structure of the parameter-space require a completely new proof
of soundness.  And, it prevents fruitful insights and results developed in one
paradigm from being applied to others, e.g., functional to object-oriented and
_vice versa_.

We propose an automated alternative approach to structuring and implementing
program analysis.  Inspired by \citeauthor*{dvanhorn:Liang1995Monad}'s
\emph{Monad transformers for modular interpreters}
\citeyearpar{dvanhorn:Liang1995Monad}, we propose to start with concrete
interpreters in a specific monadic style. Changing the monad will change the
interpreter from a concrete interpreter into an abstract interpreter. As we
show, classical program abstractions can be embodied as language-independent
monads.  Moreover, these abstractions can be written as monad transformers,
thereby allowing their composition to achieve new forms of analysis.  We show
that these monad transformers obey the properties of \emph{Galois connections}
\cite{dvanhorn:Cousot1979Systematic} and introduce the concept of a
\emph{Galois transformer}, a monad transformer transports Galois connection.

Most significantly, these Galois transformers can be proved sound once and used
everywhere.  Abstract interpreters, which take the form of monad transformer
stacks coupled together with a monadic interpreter, inherit the soundness
properties of each element in the stack.  This approach enables reuse of
abstractions across languages and lays the foundation for a modular metatheory
of program analysis.

Using Galois transformers, we enable arbitrary composition of choices for various analysis components.
For example, our implementation, called `maam` supports command-line flags for garbage collection, k-CFA, and path- and flow-sensitivity.
``````````````````````````````````````````````````
./maam --gc --CFA=0 --flow-sen prog.lam
``````````````````````````````````````````````````
These flags are implemented completely independent of one another, 
  and their combination is applied to a single parameterized monadic interpreter.
Furthermore, using Galois transformers allows us to prove each combination correct in one fell swoop.

\paragraph{Setup}
We describe a simple language and a garbage-collecting allocating semantics as the 
  starting point of analysis design (Section \ref{semantics}).
We then briefly discuss three types of flow- and path-sensitivities and their corresponding variations 
  in analysis precision (Section \ref{flow-properties-in-analysis}).

\paragraph{Monadic Abstract Interpreters}
We develop an abstract interpreter for our example language as a monadic function with various parameters (Section \ref{analysis-parameters}), 
  one of which is a monadic effect interface combining state and nondeterminism effects (Section \ref{the-analysis-monad}).
Interpreters written in this style can be reasoned about using laws that must hold for each of these interfaces.
Likewise, instantiations for these parameters can be reasoned about in isolation from their instantiation.
When instantiated, our generic interpreter is capable of recovering the concrete semantics and a family of abstract interpreters, 
  with variations in abstract domain, call-site-sensitivity, and flow- and path-sensitivity (Section \ref{recovering-analyses}).

\paragraph{Isolating Path- and Flow-Sensitivity}
We give specific monads for instantiating the interpreter from Section \ref{the-interpreter} which give rise to path-sensitive and flow-insensitive 
  analyses (Section \ref{varying-path--and-flow-sensitivity}).
This leads to an isolated understanding of path- and flow-sensitivity as mere variations in the monad used for execution.
Furthermore, these monads are language independent, allowing one to reuse the same path- and flow-sensitive machinery for any language of interest.

\paragraph{Galois Transformers}
To ease the construction of monads for building abstract interpreters and their proofs of correctness, 
  we develop a framework of Galois transformers (Section \ref{a-compositional-monadic-framework}).
Galois transformers are an extension of monad transformers which transport Galois connections in addition to monadic operations.
Our Galois transformer framework allows us to reason about the correctness of an abstract interpreter piecewise for 
  each transformer in a stack.
These Galois transformers are also language independent, and they can be proven correct one and for all in isolation from a particular semantics.

\paragraph{Implementation}
We have implemented our technique in Haskell and briefly discuss how the parameters from Section \ref{analysis-parameters} translate into 
  code (Section \ref{implementation-1}).
Our implementation is publicly accessible through Hackage\footnote{http://hackage.haskell.org/package/maam}, Haskell's online package manager.


\paragraph{Contributions}
We make the following contributions:

- A framework for building abstract interpreters using monad transformers.
- A framework for constructing _Galois connections_ for abstract interpreters using _Galois transformers_, 
  an extension of monad transformers which also transport Galois connections.
- A new monad transformer for nondeterminism which we show is also a Galois transformer.
- An isolated understanding of flow- and path-sensitivity for static analysis as a property of the monad used for interpretation.

# Semantics

To demonstrate our framework we design an abstract interpreter for `ŒªIF`, a simple applied lambda calculus shown in Figure`~\ref{Syntax}`{.raw}.
`\begin{figure}`{.raw}
`````align````````````````````````````````````````
  i ‚àà  ‚Ñ§
  x ‚àà  Var
  a ‚àà  Atom  ::= i | x | [Œª](x).e
  ‚äï ‚àà  IOp   ::= [+] | [-]
  ‚äô ‚àà  Op    ::= ‚äï | @ 
  e ‚àà  Exp   ::= a | e ‚äô e | if0(e){e}{e}
``````````````````````````````````````````````````
`\caption{`{.raw} `ŒªIF` `}`{.raw}
\label{Syntax} 
\vspace{-2em}
`\end{figure}`{.raw}
`ŒªIF` extends traditional lambda calculus with integers, addition, subtraction and conditionals.
We use the operator `@` as explicit syntax for function application.
This allows for `Op` to be a single syntactic class for all operators and simplifies the presentation.

Before designing an abstract interpreter we first specify a formal semantics for `ŒªIF`.
Our semantics makes allocation explicit and separates values and continuations into separate stores.
Our approach to analysis will be to design a configurable interpreter that is capable of mirroring these semantics.

The state space `Œ£` for `ŒªIF` is a standard CESK machine augmented with a separate store for continuation values:
`````align````````````````````````````````````````
 œÑ ‚àà  Time    := ‚Ñ§
 l ‚àà  Addr    := Var √ó Time
 œÅ ‚àà  Env     := Var ‚áÄ Addr
 œÉ ‚àà  Store   := Addr ‚áÄ Val
 c ‚àà  Clo     ::= ‚ü®[Œª](x).e,œÅ‚ü© 
 v ‚àà  Val     ::= i | c
Œ∫l ‚àà  KAddr   := Time
Œ∫œÉ ‚àà  KStore  := KAddr ‚áÄ Frame √ó KAddr
fr ‚àà  Frame   ::= ‚ü®‚ñ° ‚äô e‚ü© | ‚ü®v ‚äô ‚ñ°‚ü© | ‚ü®if0(‚ñ°){e}{e}‚ü©
 œÇ ‚àà  Œ£       ::= Exp √ó Env √ó Store √ó KAddr √ó KStore
``````````````````````````````````````````````````

Atomic expressions are denoted by `A‚ü¶_,_,_‚üß`:
`````indent```````````````````````````````````````
A‚ü¶_,_,_‚üß ‚àà Env √ó Store √ó Atom ‚áÄ Val
A‚ü¶œÅ,œÉ,i‚üß := i
A‚ü¶œÅ,œÉ,x‚üß := œÉ(œÅ(x))
A‚ü¶œÅ,œÉ,[Œª](x).e‚üß := ‚ü®[Œª](x).e,œÅ‚ü© 
``````````````````````````````````````````````````
Primitive operations are denotation denoted by `Œ¥‚ü¶_,_,_‚üß`:
`````indent```````````````````````````````````````
Œ¥‚ü¶_,_,_‚üß ‚àà IOp √ó ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñ§
Œ¥‚ü¶[+],i‚ÇÅ,i‚ÇÇ‚üß := i‚ÇÅ + i‚ÇÇ
Œ¥‚ü¶[-],i‚ÇÅ,i‚ÇÇ‚üß := i‚ÇÅ - i‚ÇÇ
``````````````````````````````````````````````````

The semantics of compound expressions are given relationally via the step relation `_~~>_`:
`````indent```````````````````````````````````````
_~~>_ ‚àà ùí´(Œ£ √ó Œ£)
‚ü®e‚ÇÅ ‚äô e‚ÇÇ,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e‚ÇÅ,œÅ,œÉ,œÑ,Œ∫œÉ',œÑ+1‚ü©
  where Œ∫œÉ' := Œ∫œÉ[œÑ ‚Ü¶ ‚ü®‚ñ° ‚äô e‚ÇÇ‚ü©‚à∑Œ∫l]
‚ü®a,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ,œÉ,œÑ,Œ∫œÉ',tick(œÑ)‚ü©
  where 
    ‚ü®‚ñ° ‚äô e‚ü©‚à∑Œ∫l' := Œ∫œÉ(Œ∫l)
    Œ∫œÉ' := Œ∫œÉ[œÑ ‚Ü¶ ‚ü®A‚ü¶œÅ,œÉ,a‚üß ‚äô ‚ñ°‚ü©‚à∑Œ∫l']
‚ü®a,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ'',œÉ',Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    ‚ü®‚ü®[Œª](x).e,œÅ'‚ü© @ ‚ñ°‚ü©‚à∑Œ∫l':= Œ∫œÉ(Œ∫l)
    œÉ' := œÉ[(x,œÑ) ‚Ü¶ A‚ü¶œÅ,œÉ,a‚üß]
    œÅ'' := œÅ'[x ‚Ü¶ (x,œÑ)]
‚ü®i‚ÇÇ,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®i,œÅ,œÉ,Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    ‚ü®i‚ÇÅ ‚äï ‚ñ°‚ü©‚à∑Œ∫l' := Œ∫œÉ(Œ∫l)
    i := Œ¥‚ü¶‚äï,i‚ÇÅ,i‚ÇÇ‚üß
‚ü®i,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ,œÉ,Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    ‚ü®if0(‚ñ°){e‚ÇÅ}{e‚ÇÇ}‚ü©‚à∑Œ∫l' := Œ∫œÉ(Œ∫l)
    e := e‚ÇÅ when i = 0
    e := e‚ÇÇ when i ‚â† 0
``````````````````````````````````````````````````

Our abstract interpreter will support abstract garbage collection`~\cite{dvanhorn:Might:2006:GammaCFA}`{.raw}, 
  the concrete analogue of which is just standard garbage collection.
We include garbage collection for two reasons.
First, it is one of the few techniques that results in both performance _and_ precision improvements for abstract interpreters.
Second, later we will show how to write a monadic garbage collector, recovering both concrete and abstract garbage collection in one fell swoop.

Garbage collection is defined with a reachability function `R` which computes the transitively reachable address from `(œÅ,e)` in `œÉ`:
`````indent```````````````````````````````````````
R[_] ‚àà Store ‚Üí Env √ó Exp ‚Üí ùí´(Addr)
R[œÉ](œÅ,e) := Œº(X). 
  R‚ÇÄ(œÅ,e) ‚à™ X ‚à™ {l' | l' ‚àà R-Val(œÉ(l)) ; l ‚àà X}
``````````````````````````````````````````````````
We write `Œº(X). f(X)` as the least-fixed-point of a function `f`.
This definition uses two helper functions: `R‚ÇÄ` for computing the initial reachable set and `R-Val` for computing addresses reachable from addresses.
`````indent```````````````````````````````````````
R‚ÇÄ ‚àà Env √ó Exp ‚Üí ùí´(Addr)
R‚ÇÄ(œÅ,e) := {œÅ(x) | x ‚àà FV(e)}
R-Val ‚àà Val ‚Üí ùí´(Addr)
R-Val(i) := {}
R-Val(‚ü®[Œª](x).e,œÅ‚ü©) := {œÅ(x) | y ‚àà FV([Œª](x).e)}
``````````````````````````````````````````````````
where `FV` is the standard recursive definition for computing free variables of an expression.

Analogously, `KR` is the set of transitively reachable continuation addresses in `Œ∫œÉ`:
`````indent```````````````````````````````````````
KR[_] ‚àà KStore ‚Üí KAddr ‚Üí ùí´(KAddr)
KR[Œ∫œÉ](Œ∫l‚ÇÄ) := Œº(kl*). {Œ∫l‚ÇÄ} ‚à™ Œ∫l* ‚à™ {œÄ‚ÇÇ(Œ∫œÉ(Œ∫l)) | Œ∫l ‚àà kl*}
``````````````````````````````````````````````````

Our final semantics is given via the step relation `_~~>·µç·∂ú_` which nondeterministically either takes a semantic step or performs garbage collection.
`````indent```````````````````````````````````````
_~~>·µç·∂ú_ ‚àà ùí´(Œ£ √ó Œ£)
œÇ ~~>·µç·∂ú œÇ' 
  where œÇ ~~> œÇ'
‚ü®e,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~>·µç·∂ú ‚ü®e,œÅ,œÉ',Œ∫l,Œ∫œÉ',œÑ‚ü©
  where 
    œÉ' := {l ‚Ü¶ œÉ(l) | l ‚àà R[œÉ](œÅ,e)}
    Œ∫œÉ' := {Œ∫l ‚Ü¶ Œ∫œÉ(Œ∫l) | Œ∫l ‚àà KR[Œ∫œÉ](Œ∫l)}
``````````````````````````````````````````````````

An execution of the semantics is states as the least-fixed-point of a collecting semantics:
`````indent```````````````````````````````````````
Œº(X).{œÇ‚ÇÄ} ‚à™ X ‚à™ { œÇ' | œÇ ~~>·µç·∂ú œÇ' ; œÇ ‚àà X }
``````````````````````````````````````````````````
The analyses we present in this paper will be proven correct by establishing a Galois connection with this concrete collecting semantics.

# Flow Properties in Analysis

One key property of a static analysis is the way it tracks _flow_.
The term "flow" is heavily overloaded in static analysis.
We wish to draw a sharper distinction on what is a flow property.
In this paper we identify three different types of flow in analysis:

1. Path-sensitive and flow-sensitive
2. Path-insensitive and flow-sensitive
3. Path-insensitive and flow-insensitive

Consider a simple if-statement in our example language `ŒªIF` (extended with let-bindings) where an analysis cannot determine the value of `N`:
`````indent```````````````````````````````````````
1: let x := if0(N){1}{-1};
2: let y := if0(N){1}{-1};
3: e
``````````````````````````````````````````````````

\paragraph{Path-Sensitive Flow-Sensitive}
A path- and flow-sensitive analysis will track both control and data flow precisely.
At program point 2 the analysis considers separate worlds:
`````align````````````````````````````````````````
{N=0,,  x=   1}
{N‚â†0,,  x=-  1}
``````````````````````````````````````````````````
At program point 3 the analysis remains precise, resulting in environments:
`````align````````````````````````````````````````
{N=0,,  x=   1,,  y=   1} 
{N‚â†0,,  x=-  1,,  y=-  1}
``````````````````````````````````````````````````

\paragraph{Path-Insensitive Flow-Sensitive}
A path-insensitive flow-sensitive analysis will track control flow precisely but merge the heap after control flow branches.
At program point 2 the analysis considers separate worlds:
`````align````````````````````````````````````````
{N=ANY,,  x=   1}
{N=ANY,,  x=-  1}
``````````````````````````````````````````````````
At program point 3 the analysis is forced to again consider both branches, resulting in environments:
`````align````````````````````````````````````````
{N=ANY,,  x=   1,,  y=   1}
{N=ANY,,  x=   1,,  y=-  1}
{N=ANY,,  x=-  1,,  y=   1}
{N=ANY,,  x=-  1,,  y=-  1}
``````````````````````````````````````````````````

\paragraph{Path-Insensitive Flow-Insensitive}
A path-insensitive flow-insensitive analysis will compute a single global set of facts that must be true at all points of execution.
At program points 2 and 3 the analysis considers a single world with environment:
`````align````````````````````````````````````````
{N=ANY,, x={-1, 1}}
``````````````````````````````````````````````````
and 
`````align````````````````````````````````````````
{N=ANY,, x={-1, 1},, y={-1, 1}}
``````````````````````````````````````````````````
respectively.

In our framework we capture both path- and flow-sensitivity as orthogonal parameters to our interpreter.
Path-sensitivity will arise from the order of monad transformers used to construct the analysis.
Flow-sensitivity will arise from the Galois connection used to map interpreters to state space transition systems.
For brevity, and lack of better terms, we will abbreviate these analyses as "path-sensitive", "flow-sensitive" and "flow-insensitive".
This is only ambiguous for "flow-sensitive", as path-sensitivity implies flow-sensitivity, and flow-insensitivity implies path-insensitivity.

# Analysis Parameters

Before writing an abstract interpreter we first design its parameters.
The interpreter will be designed such that variations in these paramaters recover the concrete and a family of abstract interpretrs.
To do this we extend the ideas developed in \citet{davdar:van-horn:2010:aam} with a new parameter for path- and flow-sensitivity.
When finished, we will be able to recover a concrete interpreter which respects the concrete semantics, and a family of abstract interpreters.

There will be three parameters to our abstract interpreter, one of which is novel in this work:

1. The monad, novel in this work.
   This is the execution engine of the interpreter and captures the path- and flow-sensitivity of the analysis.
2. The abstract domain.
   For our language this is merely the abstraction for integers.
3. Abstract Time.
   Abstract time captures the call-site-sensitivity of the analysis.

For an object-oriented language, including a fourth parameter for object-sensitivity a la. \citet{dvanhorn:Smaragdakis2011Pick} is straightforward.

We place each of these parameters behind an abstract interface and leave their implementations opaque for the generic monadic interpreter.
We will give each of these parameters reasoning principles as we introduce them.
These principles allow us to reason about the correctness of the generic interpreter independent of a particular instantiation.
The goal is to factor as much of the proof-effort into what we can say about the generic interpreter.
An instantiation of the interpreter need only justify that each parameter meets their local interface.

## The Analysis Monad

The monad for the interpreter captures the _effects_ of interpretation.
There are two effects we wish to model in the interpreter, state and nondeterminism.
The state effect will mediate how the interpreter interacts with state cells in the state space, like `Env` and `Store`.
The nondeterminism effect will mediate the branching of the execution from the interpreter.
Our result is that path- and flow-sensitivities can be recovered by altering how these effects interact in the monad.

We briefly review monad, state and nondeterminism operators and their laws.

\paragraph{Base Monad Operations}
A type operator `M` is a monad if it support `bind`, a sequencing operator, and its unit `return`.
The monad interface is summarized in Figure`~\ref{MonadInterface}`{.raw}.
`\begin{figure}`{.raw}
`````align````````````````````````````````````````
     M  : Type ‚Üí Type
  bind  : ‚àÄ Œ± Œ≤, M(Œ±) ‚Üí (Œ± ‚Üí M(Œ≤)) ‚Üí M(Œ≤)
return  : ‚àÄ Œ±, Œ± ‚Üí M(Œ±)
``````````````````````````````````````````````````
\caption{Monad Interface}
\label{MonadInterface}
`\end{figure}`{.raw}

We use the monad laws to reason about our implementation in the absence of a particular implementation of `bind` and `return`:
`````align````````````````````````````````````````
unit‚ÇÅ :  bind(return(a))(k) = k(a)
unit‚ÇÇ :  bind(m)(return) = m
assoc :  bind(bind(m)(k‚ÇÅ))(k‚ÇÇ) 
      =  bind(m)(Œª(a).bind(k‚ÇÅ(a))(k‚ÇÇ))
``````````````````````````````````````````````````
`bind` and `return` mean something different for each monadic effect class.
For state, `bind` is a sequencer of state and `return` is the "no change in state" effect.
For nondeterminism, `bind` implements a merging of multiple branches and `return` is the singleton branch.

As is traditional with monadic programming, we use `do` and semicolon notation as syntactic sugar for `bind`.
For example: `a ‚Üê m ; k(a)` is just sugar for `bind(m)(k)`.
We replace semicolons with line breaks headed by a `do` command for multiline monadic definitions.

\paragraph{Monadic State Operations}
A type operator `M` supports the monadic state effect for a type `s` if it supports `get` and `put` actions over `s`.
The state monad interface is summarized in Figure`~\ref{StateMonadInterface}`{.raw}.
`\begin{figure}`{.raw}
`````align```````````````````````````````````````` 
  M  : Type ‚Üí type
  s  : Type
get  : M(s)
put  : s ‚Üí M(1)
``````````````````````````````````````````````````
\caption{State Monad Interface}
\label{StateMonadInterface}
`\end{figure}`{.raw}

We use the state monad laws to reason about state effects:
`````indent``````````````````````````````````````` 
put-put : put(s‚ÇÅ) ; put(s‚ÇÇ) = put(s‚ÇÇ)
put-get : put(s) ; get = return(s)
get-put : s ‚Üê get ; put(s) = return(1)
get-get : s‚ÇÅ ‚Üê get ; s‚ÇÇ ‚Üê get ; k(s‚ÇÅ,s‚ÇÇ) = s ‚Üê get ; k(s,s)
``````````````````````````````````````````````````

\paragraph{Nondeterminism Operations}
A type operator `M` support the nondeterminism effect if it supports an alternation operator `‚ü®+‚ü©` and its unit `mzero`.
The nondeterminism interface is summarized in Figure`~\ref{NondterminismInterface}`{.raw}.
`\begin{figure}`{.raw}
`````align```````````````````````````````````````` 
    M  : Type ‚Üí Type
mzero  : ‚àÄ Œ±, M(Œ±)
_‚ü®+‚ü©_  : ‚àÄ Œ±, M(Œ±) √ó M(Œ±) ‚Üí M(Œ±)
`````````````````````````````````````````````````` 
\caption{Nondeterminism Interface}
\label{NondeterminismInterface}
`\end{figure}`{.raw}

We use the nondeterminism laws to reason about nondeterminism effects:
`````indent```````````````````````````````````````
‚ä•-zero‚ÇÅ : bind(mzero)(k) = mzero
‚ä•-zero‚ÇÇ : bind(m)(Œª(a).mzero) = mzero
‚ä•-unit‚ÇÅ : mzero ‚ü®+‚ü© m = m
‚ä•-unit‚ÇÇ : m ‚ü®+‚ü© mzero = m 
+-assoc : m‚ÇÅ ‚ü®+‚ü© (m‚ÇÇ ‚ü®+‚ü© m‚ÇÉ) = (m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ) ‚ü®+‚ü© m‚ÇÉ
+-comm : m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ = m‚ÇÇ ‚ü®+‚ü© m‚ÇÅ
+-dist : 
  bind(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(k) = bind(m‚ÇÅ)(k) ‚ü®+‚ü© bind(m‚ÇÇ)(k)
``````````````````````````````````````````````````

Together, all the monadic operators we have shown capture the essence of combining explicit state-passing and set comprehension.
Our interpreter will use these operators and avoid referencing an explicit configuration `œÇ` or explicit collections of results.

## The Abstract Domain

The abstract domain is encapsulated by the `Val` type in the semantics.
To parameterize over it, we make `Val` opaque but require it support various operations.
There is a constraint on `Val` its-self: it must be a join-semilattice with `‚ä•` and `‚äî` respecting the usual laws.
We require `Val` to be a join-semilattice so it can be merged in the `Store`.
The interface for the abstract domain is shown in Figure`~\ref{AbstractDomainInterface}`{.raw}.
`\begin{figure}`{.raw}
`````align````````````````````````````````````````
      Val  : Type
        ‚ä•  : Val
      _‚äî_  : Val √ó Val ‚Üí Val
    int-I  : ‚Ñ§ ‚Üí Val
int-if0-E  : Val ‚Üí ùí´(Bool)
    clo-I  : Clo ‚Üí Val
    clo-E  : Val ‚Üí ùí´(Clo)
 Œ¥‚ü¶_,_,_‚üß  : IOp √ó Val √ó Val ‚Üí Val
``````````````````````````````````````````````````
\caption{Abstract Domain Interface}
\label{AbstractDomainInterface}
`\end{figure}`{.raw}

The laws for this interface are designed to induce a Galois connection between `‚Ñ§` and `Val`:
`````indent```````````````````````````````````````
{true}  ‚äë int-if0-E(int-I(i))     if i = 0
{false} ‚äë int-if0-E(int-I(i))     if i ‚â† 0
v ‚äí ‚®Ü‚∏§b ‚àà int-if0-E(v)‚∏• Œ∏(b)
  where 
    Œ∏(true)  = int-I(0)
    Œ∏(false) = ‚®Ü‚∏§i ‚àà ‚Ñ§ | i ‚â† 0‚∏• int-I(i)
``````````````````````````````````````````````````
Closures must follow similar laws:
`````indent```````````````````````````````````````
{c} ‚äë clo-E(cloI(c))
v ‚äë ‚®Ü‚∏§c ‚àà clo-E(v)‚∏• clo-I(c)
``````````````````````````````````````````````````
And `Œ¥` must be sound w.r.t. the abstract semantics:
`````indent```````````````````````````````````````
int-I(i‚ÇÅ + i‚ÇÇ) ‚äë Œ¥‚ü¶[+],int-I(i‚ÇÅ),int-I(i‚ÇÇ)‚üß
int-I(i‚ÇÅ - i‚ÇÇ) ‚äë Œ¥‚ü¶[-],int-I(i‚ÇÅ),int-I(i‚ÇÇ)‚üß 
``````````````````````````````````````````````````

Supporting additional primitive types like booleans, lists, or arbitrary inductive datatypes is analogous.
Introduction functions inject the type into `Val`.
Elimination functions project a finite set of discrete observations.
Introduction and elimination operators must follow a Galois connection discipline.

Of note is our restraint from allowing operations over `Val` to have monadic effects.
We set things up specifically in this way so that `Val` and the monad `M` can be varied independent of each other.

## Abstract Time 

The interface for abstract time is familiar from Abstracting Abstract Machines`~\cite{davdar:van-horn:2010:aam}`{.raw}(AAM)--which introduces 
  abstract time as a single parameter from variations in call-site-sensitivity--and is shown in Figure`~\ref{AbstractTimeInterface}`{.raw}.
`\begin{figure}`{.raw}
`````align````````````````````````````````````````
Time  : Type
tick  : Exp √ó KAddr √ó Time ‚Üí Time
``````````````````````````````````````````````````
\caption{Abstract Time Interface}
\label{AbstractTimeInterface}
`\end{figure}`{.raw}
In AAM, `tick` is defined to have access to all of `Œ£`.
This comes from the generality of the framework--to account for all possible `tick` functions.
We only discuss instantiating `Addr` to support k-CFA, so we specialize the `Œ£` parameter to `Exp √ó KAddr`.
Also in AAM is the opaque function `alloc : Var √ó Time ‚Üí Addr`.
Because we will only ever use the identity function for `alloc`, we omit its abstraction and instantiation in our development.

Remarkably, we need not state laws for `tick`.
Our interpreter will always merge values which reside at the same address to achieve soundness.
Therefore, any supplied implementations of `tick` is valid.

# The Interpreter

We now present a generic monadic interpreter for `ŒªIF` parameterized over `M`, `Val` and `Time`.

First we implement `A‚ü¶_‚üß`, a _monadic_ denotation for atomic expressions, shown in Figure \ref{InterpreterA}.

`\begin{figure}`{.raw}
`````indent```````````````````````````````````````
A‚ü¶_‚üß ‚àà Atom ‚Üí M(Val)
A‚ü¶i‚üß := return(int-I(i))
A‚ü¶x‚üß := do
  œÅ ‚Üê get-Env
  œÉ ‚Üê get-Store
  l ‚Üê ‚Üë‚Çö(œÅ(x))
  return(œÉ(x))
A‚ü¶[Œª](x).e‚üß := do
  œÅ ‚Üê get-Env
  return(clo-I(‚ü®[Œª](x).e,œÅ‚ü©))
``````````````````````````````````````````````````
\caption{Monadic denotation for atoms}
\label{InterpreterA} 
`\end{figure}`{.raw}
`get-Env` and `get-Store` are primitive operations for monadic state.
`clo-I` comes from the abstract domain interface.
`‚Üë‚Çö` is the lifting of values from powerset into the monad:
`````indent```````````````````````````````````````
‚Üë‚Çö : ‚àÄ Œ±, ùí´(Œ±) ‚Üí M(Œ±)
‚Üë‚Çö({a‚ÇÅ .. a‚Çô}) := return(a‚ÇÅ) ‚ü®+‚ü© .. ‚ü®+‚ü© return(a‚Çô)
``````````````````````````````````````````````````

Next we implement `step`, a _monadic_ small-step function for compound expressions, shown in Figure \ref{InterpreterStep}.
`\begin{figure}`{.raw}
`````indent```````````````````````````````````````
step : Exp ‚Üí M(Exp)
step(e‚ÇÅ ‚äô e‚ÇÇ) := do
  tickM(e‚ÇÅ ‚äô e‚ÇÇ)
  push(‚ü®‚ñ° ‚äô e‚ÇÇ‚ü©)
  return(e‚ÇÅ)
step(a) := do
  tickM(a)
  fr ‚Üê pop
  v ‚Üê A‚ü¶a‚üß
  case fr of
    ‚ü®‚ñ° ‚äô e‚ü© ‚Üí do
      push(‚ü®v ‚äô ‚ñ°‚ü©)
      return(e)
    ‚ü®v' @ ‚ñ°‚ü© ‚Üí do
      ‚ü®[Œª](x).e,œÅ'‚ü© ‚Üê ‚Üë‚Çö(clo-E(v'))
      œÑ ‚Üê get-Time
      œÉ ‚Üê get-Store
      put-Env(œÅ'[x ‚Ü¶ (x,œÑ)])
      put-Store(œÉ ‚äî [(x,œÑ) ‚Ü¶ {v}])
      return(e)
    ‚ü®v' ‚äï ‚ñ°‚ü© ‚Üí do
      return(Œ¥(‚äï,v',v))
    ‚ü®if0(‚ñ°){e‚ÇÅ}{e‚ÇÇ}‚ü© ‚Üí do
      b ‚Üê ‚Üë‚Çö(int-if0-E(v))
      if(b) then return(e‚ÇÅ) else return(e‚ÇÇ)
``````````````````````````````````````````````````
\caption{Monadic step function}
\label{InterpreterStep} 
`\end{figure}`{.raw}
`step` uses helper functions `push` and `pop` for manipulating stack frames:
`````indent```````````````````````````````````````
push : Frame ‚Üí M(1)
push(fr) := do
  Œ∫l ‚Üê get-KAddr
  Œ∫œÉ ‚Üê get-KStore
  Œ∫l' ‚Üê get-Time
  put-KStore(Œ∫œÉ ‚äî [Œ∫l' ‚Ü¶ {fr‚à∑Œ∫l}])
  put-KAddr(Œ∫l')
pop : M(Frame)
pop := do
  Œ∫l ‚Üê get-KAddr
  Œ∫œÉ ‚Üê get-KStore
  fr‚à∑Œ∫l' ‚Üê ‚Üë‚Çö(Œ∫œÉ(Œ∫l))
  put-KAddr(Œ∫l')
  return(fr)
``````````````````````````````````````````````````
and a monadic version of `tick` called `tickM`:
`````indent```````````````````````````````````````
tickM : Exp ‚Üí M(1)
tickM(e) = do
  œÑ ‚Üê get-Time
  Œ∫l ‚Üê get-KAddr
  put-Time(tick(e,Œ∫l,œÑ))
``````````````````````````````````````````````````

We can also implement abstract garbage collection in a fully general away against the monadic effect interface:
`````indent```````````````````````````````````````
gc : Exp ‚Üí M(1)
gc(e) := do
  œÅ ‚Üê get-Env
  œÉ ‚Üê get-Store
  Œ∫œÉ ‚Üê get-KStore
  put-Store({l ‚Ü¶ œÉ(l) | l ‚àà R[œÉ](œÅ,e))
  put-KStore({Œ∫l ‚Ü¶ Œ∫œÉ(Œ∫l) | Œ∫l ‚àà KR[Œ∫œÉ](Œ∫l)})
``````````````````````````````````````````````````
where `R` and `KR` are as defined in Section`~\ref{semantics}`{.raw}.
The interpreter looks deterministic, however the nondeterminism is abstracted away behind `‚Üë‚Çö` and monadic bind.

In generalizing the semantics to account for nondeterminism, updates to both the value and continuation store must merge rather than strong update.
This is because we place no restriction on the semantics for `Time`, and we must preserve soundness in the presence of reused addresses.
Our interpreter is therefore operating over a modified state space:
`````indent```````````````````````````````````````
œÉ  ‚àà Store  : Addr ‚Üí Val
Œ∫œÉ ‚àà KStore : KAddr ‚Üí ùí´(Frame √ó KAddr)
``````````````````````````````````````````````````
We have already established a join-semilattice structure in the interface for `Val` in the abstract domain interface.
Developing a custom join-semilattice for continuations is possible, and is the key component of recent developments in pushdown abstraction.
For this presentation we use `ùí´(Frame √ó KAddr)` as an abstraction for continuations for simplicity.

To execute the interpreter we must introduce one more parameter.
In the concrete semantics, execution takes the form of a least-fixed-point computation over the collecting semantics
This in general requires a join-semilattice structure for some `Œ£` and a transition function `Œ£ ‚Üí Œ£`.
We bridge this gap between monadic interpreters and transition functions with an extra constraint on the monad `M`.
We require that monadic actions `Exp ‚Üí M(Exp)` form a Galois connection with a transition system `Œ£ ‚Üí Œ£`.
This Galois connection serves two purposes.
First, it allows us to implement the analysis by converting our interpreter to the transition system `Œ£ ‚Üí Œ£` through `Œ≥`.
Second, this Galois connection serves to _transport other Galois connections_ as part of our correctness framework.
For example, given concrete and abstract versions of `Val`, we carry `CVal Œ±‚áÑŒ≥ AVal` through the Galois connection to establish `CŒ£ Œ±‚áÑŒ≥ AŒ£`.

A collecting-semantics execution of our interpreter is defined as the least-fixed-point of `step` transported through the Galois connection.
`````indent```````````````````````````````````````
Œº(X). œÇ‚ÇÄ ‚äî X ‚äî Œ≥(step)(X)
``````````````````````````````````````````````````
where `œÇ‚ÇÄ` is the injection of the initial program `e‚ÇÄ` into `Œ£ `.

# Recovering Analyses

To recover concrete and abstract interpreters we need only instantiate our generic monadic interpreter with concrete and abstract components.

## Recovering a Concrete Interpreter

For the concrete value space we instantiate `Val` to `CVal`, a powerset of values:
`````indent```````````````````````````````````````
v ‚àà CVal := ùí´(CClo + ‚Ñ§)
``````````````````````````````````````````````````

The concrete value space `CVal` has straightforward introduction and elimination rules:
`````indent```````````````````````````````````````
int-I : ‚Ñ§ ‚Üí CVal
int-I(i) := {i}
int-if0-E : CVal ‚Üí ùí´(Bool)
int-if0-E(v) := { true | 0 ‚àà v } ‚à™ { false | i ‚àà v ‚àß i ‚â† 0 }
``````````````````````````````````````````````````
and the concrete `Œ¥` you would expect:
`````indent```````````````````````````````````````
Œ¥‚ü¶_,_,_‚üß : IOp √ó CVal √ó CVal ‚Üí CVal
Œ¥‚ü¶[+],v‚ÇÅ,v‚ÇÇ‚üß := { i‚ÇÅ + i‚ÇÇ | i‚ÇÅ ‚àà v‚ÇÅ ; i‚ÇÇ ‚àà v‚ÇÇ }
Œ¥‚ü¶[-],v‚ÇÅ,v‚ÇÇ‚üß := { i‚ÇÅ - i‚ÇÇ | i‚ÇÅ ‚àà v‚ÇÅ ; i‚ÇÇ ‚àà v‚ÇÇ }
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CVal` satisfies the abstract domain laws shown in Section \ref{the-abstract-domain} Figure`~\ref{AbstractDomainInterface}`{.raw}.
`\end{proposition}`{.raw}

Concrete time `CTime` captures program contours as a product of `Exp` and `CKAddr`:
`````indent```````````````````````````````````````
œÑ ‚àà CTime := (Exp √ó KAddr)‚ãÜ
``````````````````````````````````````````````````
and `tick` is just a cons operator:
`````indent```````````````````````````````````````
tick : Exp √ó CKAddr √ó CTime ‚Üí CTime
tick (e,Œ∫l,œÑ) := (e,Œ∫l)‚à∑œÑ
``````````````````````````````````````````````````

For the concrete monad we instantiate `M` to a path-sensitive `CM` which contains a powerset of concrete state space components.
`````indent```````````````````````````````````````
œà ‚àà Œ® := CEnv √ó CStore √ó CKAddr √ó CKStore √ó CTime
m ‚àà CM(Œ±) := Œ® ‚Üí ùí´(Œ± √ó Œ®)
``````````````````````````````````````````````````

Monadic operators `bind` and `return` encapsulate both state-passing and set-flattening:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ±, CM(Œ±) ‚Üí (Œ± ‚Üí CM(Œ≤)) ‚Üí CM(Œ≤)
bind(m)(f)(œà) := 
  {(y,œà'') | (y,œà'') ‚àà f(a)(œà') ; (a,œà') ‚àà m(œà)}
return : ‚àÄ Œ±, Œ± ‚Üí CM(Œ±)
return(a)(œà) := {(a,œà)}
``````````````````````````````````````````````````

State effects merely return singleton sets:
`````indent```````````````````````````````````````
get-Env : CM(CEnv)
get-Env(‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©) := {(œÅ,‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©)}
put-Env : CEnv ‚Üí ùí´(1)
put-Env(œÅ')(‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©) := {(1,‚ü®œÅ',œÉ,Œ∫,œÑ‚ü©)}
``````````````````````````````````````````````````

Nondeterminism effects are implemented with set union:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, CM(Œ±)
mzero(œà) := {}
_‚ü®+‚ü©_ : ‚àÄ Œ±, CM(Œ±) √ó CM(Œ±) ‚Üí CM(Œ±)
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(œà) := m‚ÇÅ(œà) ‚à™ m‚ÇÇ(œà)
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CM` satisfies monad, state, and nondeterminism laws shown in 
  Section \ref{the-analysis-monad} Figures \ref{MonadInterface}, \ref{StateMonadInterface} and \ref{NondeterminismInterface}.
`\end{proposition}`{.raw}

Finally, we must establish a Galois connection between `Exp ‚Üí CM(Exp)` and `CŒ£ ‚Üí CŒ£` for some choice of `CŒ£`.
For the path-sensitive monad `CM` instantiate with `CVal` and `CTime`, , `CŒ£` is defined:
`````indent```````````````````````````````````````
CŒ£ := ùí´(Exp √ó Œ®)
``````````````````````````````````````````````````

The Galois connection between `CM` and `CŒ£` is straightforward:
`````indent```````````````````````````````````````
Œ≥ : (Exp ‚Üí CM(Exp)) ‚Üí (CŒ£ ‚Üí CŒ£)
Œ≥(f)(eœà*) := {(e,œà') | (e,œà') ‚àà f(e)(œà) ; (e,œà) ‚àà eœà*}
Œ± : (CŒ£ ‚Üí CŒ£) ‚Üí (Exp ‚Üí CM(Exp))
Œ±(f)(e)(œà) := f({(e,œà)})
``````````````````````````````````````````````````

The injection `œÇ‚ÇÄ` for a program `e‚ÇÄ` is:
`````indent```````````````````````````````````````
œÇ‚ÇÄ := {‚ü®e,‚ä•,‚ä•,‚àô,‚ä•,‚àô‚ü©}
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`Œ≥` and `Œ±` form an isomorphism.
`\end{proposition}`{.raw}

`\begin{corollary}`{.raw}
`Œ≥` and `Œ±` form a Galois connection.
`\end{corollary}`{.raw}

## Recovering an Abstract Interpreter

We pick a simple abstraction for integers, `{[-],0,[+]}`, although our technique scales seamlessly to other domains.
`````indent```````````````````````````````````````
AVal := ùí´(AClo + {[-],0,[+]})
``````````````````````````````````````````````````

Introduction and elimination functions for `AVal` are defined:
`````indent```````````````````````````````````````
int-I : ‚Ñ§ ‚Üí AVal
int-I(i) := [-] if i < 0
int-I(i) := 0   if i = 0
int-I(i) := [+] if i > 0
int-if0-E : AVal ‚Üí ùí´(Bool)
int-if0-E(v) := { true | 0 ‚àà v } ‚à™ { false | [-] ‚àà v ‚à® [+] ‚àà v }
``````````````````````````````````````````````````
Introduction and elimination for `AClo` is identical to the concrete domain.

The abstract `Œ¥` operator is defined:
`````indent```````````````````````````````````````
Œ¥ : IOp √ó AVal √ó AVal ‚Üí AVal 
Œ¥(+,v‚ÇÅ,v‚ÇÇ) := 
    { i     | 0 ‚àà v‚ÇÅ ‚àß i ‚àà v‚ÇÇ }
  ‚à™ { i     | i ‚àà v‚ÇÅ ‚àß 0 ‚àà v‚ÇÇ }
  ‚à™ { [+]     | [+] ‚àà v‚ÇÅ ‚àß [+] ‚àà v‚ÇÇ } 
  ‚à™ { [-]     | [-] ‚àà v‚ÇÅ ‚àß [-] ‚àà v‚ÇÇ } 
  ‚à™ { [-],0,[+] | [+] ‚àà v‚ÇÅ ‚àß [-] ‚àà v‚ÇÇ }
  ‚à™ { [-],0,[+] | [-] ‚àà v‚ÇÅ ‚àß [+] ‚àà v‚ÇÇ }
``````````````````````````````````````````````````
The definition for `Œ¥(-,v‚ÇÅ,v‚ÇÇ)` is analogous.

`\begin{proposition}`{.raw}
`AVal` satisfies the abstract domain laws shown in  Section`~\ref{the-abstract-domain}`{.raw} Figure \ref{AbstractDomainInterface}.
`\end{proposition}`{.raw}

`\begin{proposition}`{.raw}
`CVal Œ±‚áÑŒ≥ AVal` and their operations `int-I`, `int-if0-E` and `Œ¥` are ordered `‚äë` respectively through the Galois connection.
`\end{proposition}`{.raw}

Next we abstract `Time` to `ATime` as the finite domain of k-truncated lists of execution contexts:
`````indent```````````````````````````````````````
ATime := (Exp √ó AKAddr)‚ãÜ‚Çñ
``````````````````````````````````````````````````
The `tick` operator becomes cons followed by k-truncation:
`````indent```````````````````````````````````````
tick : Exp √ó AKAddr √ó ATime ‚Üí ATime
tick(e,Œ∫l,œÑ) = ‚åä(e,Œ∫l)‚à∑œÑ‚åã‚Çñ
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CTime Œ±‚áÑŒ≥ ATime` and `tick` is ordered `‚äë` through the Galois connection.
`\end{proposition}`{.raw}

The monad `AM` need not change in implementation from `CM`; they are identical up the choice of `Œ®`.
`````indent```````````````````````````````````````
œà ‚àà Œ® := AEnv √ó AStore √ó AKAddr √ó AKStore √ó ATime
``````````````````````````````````````````````````

The resulting state space `AŒ£` is finite, and its least-fixed-point iteration will give a sound and computable analysis.

# Varying Path- and Flow-Sensitivity

We are able to recover a flow-insensitivity in the analysis through a new definition for `M`: `AM·∂†‚Å±`.
To do this we pull `AStore` out of the powerset, exploiting its join-semilattice structure:
`````indent```````````````````````````````````````
Œ® := AEnv √ó AKAddr √ó AKStore √ó ATime
AM·∂†‚Å±(Œ±) := Œ® √ó AStore ‚Üí ùí´(Œ± √ó Œ®) √ó AStore
``````````````````````````````````````````````````

The monad operator `bind` performs the store merging needed to capture a flow-insensitive analysis.
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, AM·∂†‚Å±(Œ±) ‚Üí (Œ± ‚Üí AM·∂†‚Å±(Œ≤)) ‚Üí AM·∂†‚Å±(Œ≤)
bind(m)(f)(œà,œÉ) := ({bs‚ÇÅ‚ÇÅ .. bs‚Çô‚ÇÅ .. bs‚Çô‚Çò},œÉ‚ÇÅ ‚äî .. ‚äî œÉ‚Çô)
  where
    ({(a‚ÇÅ,œà‚ÇÅ) .. (a‚Çô,œà‚Çô)},œÉ') := m(œà,œÉ)
    ({bœà·µ¢‚ÇÅ .. bœà·µ¢‚Çò},œÉ·µ¢) := f(a·µ¢)(œà·µ¢,œÉ')
``````````````````````````````````````````````````
The unit for `bind` returns one nondeterminism branch and a single store:
`````indent```````````````````````````````````````
return : ‚àÄ Œ±, Œ± ‚Üí AM·∂†‚Å±(Œ±)
return(a)(œà,œÉ) := ({a,œà},œÉ)
``````````````````````````````````````````````````

State effects `get-Env` and `put-Env` are also straightforward, returning one branch of nondeterminism:
`````indent```````````````````````````````````````
get-Env : AM·∂†‚Å±(AEnv)
get-Env(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(œÅ,‚ü®œÅ,Œ∫,œÑ‚ü©)},œÉ)
put-Env : AEnv ‚Üí AM·∂†‚Å±(1)
put-Env(œÅ')(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(1,‚ü®œÅ',Œ∫,œÑ‚ü©)},œÉ)
``````````````````````````````````````````````````

State effects `get-Store` and `put-Store` are analogous to `get-Env` and `put-Env`:
`````indent```````````````````````````````````````
get-Store : AM·∂†‚Å±(AEnv)
get-Store(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(œÉ,‚ü®œÅ,Œ∫,œÑ‚ü©},œÉ)
put-Store : AStore ‚Üí AM·∂†‚Å±(1)
put-Store(œÉ')(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(1,‚ü®œÅ,Œ∫,œÑ‚ü©)},œÉ')
``````````````````````````````````````````````````

Nondeterminism operations will union the powerset and join the store pairwise:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, M(Œ±)
mzero(œà,œÉ) := ({}, ‚ä•)
_‚ü®+‚ü©_ : ‚àÄ Œ±, M(Œ±) √ó M(Œ±) ‚Üí M Œ± 
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(œà,œÉ) := (aœà*‚ÇÅ ‚à™ aœà*‚ÇÇ,œÉ‚ÇÅ ‚äî œÉ‚ÇÇ)
  where (aœà*·µ¢,œÉ·µ¢) := m·µ¢(œà,œÉ)
``````````````````````````````````````````````````

Finally, the Galois connection relating `AM·∂†‚Å±` to a state space transition over `AŒ£·∂†‚Å±` must also compute set unions and store joins pairwise:
`````indent```````````````````````````````````````
AŒ£·∂†‚Å± := ùí´(Exp √ó Œ®) √ó AStore
Œ≥ : (Exp ‚Üí AM·∂†‚Å±(Exp)) ‚Üí (AŒ£·∂†‚Å± ‚Üí AŒ£·∂†‚Å±)
Œ≥(f)(eœà*,œÉ) := ({eœà‚ÇÅ‚ÇÅ .. eœà‚Çô‚ÇÅ .. eœà‚Çô‚Çò}, œÉ‚ÇÅ ‚äî .. ‚äî œÉ‚Çô)
  where 
    {(e‚ÇÅ,œà‚ÇÅ) .. (e‚Çô,œà‚Çô)} := eœà*
    ({eœà·µ¢‚ÇÅ .. eœà·µ¢‚Çò},œÉ·µ¢) := f(e·µ¢)(œà·µ¢,œÉ)
Œ±  : (AŒ£·∂†‚Å± ‚Üí AŒ£·∂†‚Å±) ‚Üí (Exp ‚Üí AM·∂†‚Å±(Exp))
Œ±(f)(e)(œà,œÉ) := f({(e,œà)},œÉ)
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`Œ≥` and `Œ±` form an isomorphism.
`\end{proposition}`{.raw}

`\begin{corollary}`{.raw}
`Œ≥` and `Œ±` form a Galois connection.
`\end{corollary}`{.raw}

`\begin{proposition}`{.raw}
There exists Galois connections:
`````align````````````````````````````````````````
CM Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ AM Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ AM·∂†‚Å±
``````````````````````````````````````````````````
`\end{proposition}`{.raw}
The first Galois connection `CM Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ AM` is justified by the Galois connections between `CVal Œ±‚áÑŒ≥ AVal` and `CTime Œ±‚áÑŒ≥ ATime`.
The second Galois connection `AM Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ AM·∂†‚Å±` is justified by calculation over their definitions.
We aim to recover this proof more easily through compositional components in Section \ref{a-compositional-monadic-framework}.

`\begin{corollary}`{.raw}
`````align````````````````````````````````````````
CŒ£ Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ AŒ£ Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ AŒ£·∂†‚Å±
``````````````````````````````````````````````````
`\end{corollary}`{.raw}
This property is derived by transporting each Galois connection between monads through their respective Galois connections to `Œ£`.


`\begin{proposition}`{.raw}
The following orderings hold between the three induced transition relations:
`````align````````````````````````````````````````
Œ±‚ÇÅ ‚àò CŒ≥(step) ‚àò Œ≥‚ÇÅ ‚äë AŒ≥(step) ‚äë Œ≥‚ÇÇ ‚àò AŒ≥·∂†‚Å±(step) ‚àò Œ±‚ÇÇ
``````````````````````````````````````````````````
`\end{proposition}`{.raw}
This is a direct consequence of the monotonicity of step and the Galois connections between monads.

We note that the implementation for our interpreter and abstract garbage collector remain the same for each interpreter.
They scale seamlessly to flow-sensitive and flow-insensitive variants when instantiated with the appropriate monad.

# A Compositional Monadic Framework

In our development thus far, any modification to the interpreter requires redesigning the monad `AM` and constructing new proofs.
We want to avoid reconstructing complicated monads for our interpreters, especially as languages and analyses grow and change.
Even more, we want to avoid reconstructing complicated _proofs_ that such changes will necessarily alter.
Toward this goal we introduce a compositional framework for constructing monads which are correct-by-construction.
To do this we extend the well-known structure of monad transformer that that of _Galois transformer_.

There are two types of monadic effects used in our monadic interpreter: state and nondeterminism.
Each of these effects have corresponding monad transformers.
Our definition of a monad transformer for nondeterminism is novel in this work.

In the proceeding definitions, we must necessarily use `bind`, `return`, and other operations from the underlying monad.
We notate these `bind‚Çò`, `return‚Çò`, `do‚Çò`, `‚Üê‚Çò`,  etc. for clarity.

## State Monad Transformer

Briefly we review the state monad transformer, `S‚Çú[s]`:
`````indent```````````````````````````````````````
S‚Çú[_] : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
S‚Çú[s](m)(Œ±) := s ‚Üí m(Œ± √ó s)
``````````````````````````````````````````````````


The state monad transformer can transport monadic operations from `m` to `S‚Çú[s](m)`:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, S‚Çú[s](m)(Œ±) ‚Üí (Œ± ‚Üí S‚Çú[s](m)(Œ≤)) ‚Üí S‚Çú[s](m)(Œ≤)
bind(m)(f)(s) := do‚Çò
  (x,s') ‚Üê‚Çò m(s)
  f(x)(s')
return : ‚àÄ Œ± m, Œ± ‚Üí S‚Çú[s](m)(Œ±)
return(x)(s) := return‚Çò(x,s)
``````````````````````````````````````````````````

The state monad transformer can also transport nondeterminism effects from `m` to `S‚Çú[s](m)`:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, S‚Çú[s](m)(Œ±)
mzero(s) := mzero‚Çò 
_‚ü®+‚ü©_ : ‚àÄ Œ±, S‚Çú[s](m)(Œ±) √ó S‚Çú[s](m)(Œ±) ‚Üí S‚Çú[s](m)(Œ±)
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(s) := m‚ÇÅ(s) ‚ü®+‚ü©‚Çò m‚ÇÇ(s) 
``````````````````````````````````````````````````

Finally, the state monad transformer exposes `get` and `put` operations given that `m` is a monad:
`````indent```````````````````````````````````````
get : S‚Çú[s](m)(s)
get(s) := return‚Çò(s,s)
put : s ‚Üí S‚Çú[s](m)(1)
put(s')(s) := return‚Çò(1,s')
``````````````````````````````````````````````````

## Nondeterminism Monad Transformer

We have developed a new monad transformer for nondeterminism which composes with state in both directions.
Previous attempts to define a monad transformer for nondeterminism have resulted in monad operations which do not respect monad laws.

Our nondeterminism monad transformer shares the "expected" type, embedding `ùí´` inside `m`:
`````indent```````````````````````````````````````
ùí´‚Çú : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
ùí´‚Çú(m)(Œ±) := m(ùí´(Œ±))
``````````````````````````````````````````````````

The nondeterminism monad transformer can transport monadic operations from `m` to `ùí´‚Çú` _provided that `m` is also a join-semilattice functor_:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, ùí´‚Çú(m)(Œ±) ‚Üí (Œ± ‚Üí ùí´‚Çú(m)(Œ≤)) ‚Üí ùí´‚Çú(m)(Œ≤)
bind(m)(f) := do‚Çò
  {x‚ÇÅ .. x‚Çô} ‚Üê‚Çò m
  f(x‚ÇÅ) ‚äî‚Çò .. ‚äî‚Çò f(x‚Çô)
return : ‚àÄ Œ±, Œ± ‚Üí ùí´‚Çú(m)(Œ±)
return(x) := return‚Çò({x})
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`bind` and `return` satisfy the monad laws.
`\end{proposition}`{.raw}
The key lemma in this proof is the functorality of `m`, namely that:
`````align````````````````````````````````````````
return‚Çò(x ‚äî y) = return‚Çò(x) ‚äî return‚Çò(y)
``````````````````````````````````````````````````

The nondeterminism monad transformer can transport state effects from `m` to `ùí´‚Çú`:
`````indent```````````````````````````````````````
get : ùí´‚Çú(m)(s)
get = map‚Çò(Œª(s).{s})(get‚Çò)
put : s ‚Üí ùí´‚Çú(m)(s)
put(s) = map‚Çò(Œª(1).{1})(put‚Çò(s))
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`get` and `put` satisfy the state monad laws.
`\end{proposition}`{.raw}
The proof is by simple calculation.

Finally, our nondeterminism monad transformer exposes nondeterminism effects as a straightforward application of the underlying monad's join-semilattice functorality:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, ùí´‚Çú(m)(Œ±)
mzero := ‚ä•‚Çò
_‚ü®+‚ü©_ : ‚àÄ Œ±, ùí´‚Çú(m)(Œ±) x ùí´‚Çú(m)(Œ±) ‚Üí ùí´‚Çú(m)(Œ±)
m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ := m‚ÇÅ ‚äî‚Çò m‚ÇÇ
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`mzero` and `‚ü®+‚ü©` satisfy the nondeterminism monad laws.
`\end{proposition}`{.raw}
The proof is trivial as a consequence of the underlying monad being a join-semilattice functor.

## Mapping to State Spaces

Both our execution and correctness frameworks requires that monadic actions in `M` map to some state space transitions `Œ£`.
We extend the earlier statement of Galois connection to the transformer setting:
`````indent```````````````````````````````````````
mstep : ‚àÄ Œ± Œ≤, (Œ± ‚Üí M(Œ≤)) Œ±‚áÑŒ≥ (Œ£(Œ±) ‚Üí Œ£(Œ≤))
``````````````````````````````````````````````````
Here `M` must map _arbitrary_ monadic actions `Œ± ‚Üí M(Œ≤)` to state space transitions for a state space _functor_ `Œ£(_)`
We only show the `Œ≥` sides of the mappings in this section, which allow one to execute the analyses.

For the state monad transformer `S‚Çú[s]` mstep is defined:
`````indent```````````````````````````````````````
mstep-Œ≥ : ‚àÄ Œ± Œ≤ m, 
  (Œ± ‚Üí S‚Çú[s](m)(Œ≤)) ‚Üí (Œ£‚Çò(Œ± √ó s) ‚Üí Œ£‚Çò(Œ≤ √ó s))
mstep-Œ≥(f) := mstep‚Çò-Œ≥(Œª(a,s). f(a)(s))
``````````````````````````````````````````````````

For the nondeterminism transformer `ùí´‚Çú`, mstep has two possible definitions.
One where `Œ£` is `Œ£‚Çò ‚àò ùí´`:
`````indent```````````````````````````````````````
mstep‚ÇÅ-Œ≥ : ‚àÄ Œ± Œ≤ m, 
  (Œ± ‚Üí ùí´‚Çú(m)(Œ≤)) ‚Üí (Œ£‚Çò(ùí´(Œ±)) ‚Üí Œ£‚Çò(ùí´(Œ≤)))
mstep‚ÇÅ-Œ≥(f) := mstep‚Çò-Œ≥(F)
  where F({x‚ÇÅ .. x‚Çô}) = f(x‚ÇÅ) ‚ü®+‚ü© .. ‚ü®+‚ü© f(x‚Çô))
``````````````````````````````````````````````````
and one where `Œ£` is `ùí´ ‚àò Œ£‚Çò`:
`````indent```````````````````````````````````````
mstep‚ÇÇ-Œ≥ : ‚àÄ Œ± Œ≤ m, 
  (Œ± ‚Üí ùí´‚Çú(m)(Œ≤)) ‚Üí (ùí´(Œ£‚Çò(Œ±)) ‚Üí ùí´(Œ£‚Çò(Œ≤)))
mstep‚ÇÇ-Œ≥(f)({œÇ‚ÇÅ .. œÇ‚Çô}) := aŒ£P‚ÇÅ ‚à™ .. ‚à™ aŒ£P‚Çô
  where 
    commuteP-Œ≥ : ‚àÄ Œ±, Œ£‚Çò(ùí´(Œ±)) ‚Üí ùí´(Œ£‚Çò(Œ±))
    aŒ£P·µ¢ := commuteP-Œ≥(mstep‚Çò-Œ≥(f)(œÇ·µ¢)) 
``````````````````````````````````````````````````
The operation `commuteP-Œ≥` must be defined for the underlying `Œ£‚Çò`.
In general, `commuteP` must form a Galois connection.
However, this property exists for the identity monad, and is preserved by `S‚Çú[s]`, the only monad we will compose `ùí´‚Çú` with in this work.
`````indent```````````````````````````````````````
commuteP-Œ≥ : ‚àÄ Œ±, Œ£‚Çò(ùí´(Œ±) √ó s) ‚Üí ùí´(Œ£‚Çò(Œ± √ó s))
commuteP-Œ≥ := commuteP‚Çò ‚àò map(F)
  where
    F({Œ±‚ÇÅ .. Œ±‚Çô}) = {(Œ±‚ÇÅ,s) .. (Œ±‚Çô,s)})
``````````````````````````````````````````````````
Of all the `Œ≥` mappings defined, the `Œ≥` side of `commuteP` is the only mapping that loses information in the `Œ±` direction.
Therefore, `mstep‚∏§S‚Çú[s]‚∏•` and `mstep‚∏§ùí´‚Çú1‚∏•` are really isomorphism transformers, and `mstep‚∏§ùí´‚Çú2‚∏•` is the only Galois connection transformer.
The Galois connections for `mstep` for both `S‚Çú[s]` or `P‚Çú` rely crucially on `mstep‚Çò-Œ≥` and `mstep‚Çò-Œ±` be homomorphic, i.e. that:
`````align````````````````````````````````````````
Œ±(id) ‚äë return
Œ±(f ‚àò g) ‚äë Œ±(f) ‚ü®‚àò‚ü© Œ±(g)
``````````````````````````````````````````````````
and likewise for `Œ≥`, where `‚ü®‚àò‚ü© ` is composition in the Kleisli category for the monad `M`.

For convenience, we name the pairing of `ùí´‚Çú` with `mstep‚ÇÅ` `FI‚Çú`, and with `mstep‚ÇÇ` `FS‚Çú` for flow-insensitive and flow-sensitive respectively.

`\begin{proposition}`{.raw}
`Œ£‚∏§FS‚Çú‚∏• Œ±‚áÑŒ≥ Œ£‚∏§FI‚Çú‚∏•`.
`\end{proposition}`{.raw}
The proof is by consequence of `commuteP`.

`\begin{proposition}`{.raw}
`S‚Çú[s] ‚àò ùí´‚Çú Œ±‚áÑŒ≥ ùí´‚Çú ‚àò S‚Çú[s]`.
`\end{proposition}`{.raw}
The proof is by calculation after unfolding the definitions.

## Galois Transformers

The capstone of our compositional framework is the fact that monad transformers `S‚Çú[s]` and `ùí´‚Çú` are also _Galois transformers_.
Whereas a monad transformer is a functor between functors, a Galois transformer is a functor between Galois functors.

`\begin{definition}`{.raw}
A monad transformer `T` is a Galois transformer if for Galois functors `m‚ÇÅ` and `m‚ÇÇ`, `m‚ÇÅ Œ±‚áÑŒ≥ m‚ÇÇ ‚áí T(m‚ÇÅ) Œ±‚áÑŒ≥ T(m‚ÇÇ)`.
`\end{definition}`{.raw}

`\begin{proposition}`{.raw}
`S‚Çú[s]` and `ùí´‚Çú` are Galois transformers.
`\end{proposition}`{.raw}
The proofs are straightforward applications of the underlying `m‚ÇÅ Œ±‚áÑŒ≥ m‚ÇÇ`.

Furthermore, the state monad transformer `S‚Çú[s]` is Galois functorial in its state parameter `s`.

## Building Transformer Stacks

We can now build monad transformer stacks from combinations of `S‚Çú[s]`, `FI‚Çú` and `FS‚Çú` that have the following properties:

- The resulting monad has the combined effects of all pieces of the transformer stack.
- Actions in the resulting monad map to a state space transition system `Œ£ ‚Üí Œ£` for some `Œ£`.
- Galois connections between `CŒ£` and `AŒ£` are established piecewise from monad transformer components.
- Monad transformer components are proven correct once and for all.

We instantiate our interpreter to the following monad stacks in decreasing order of precision:

\vspace{1em}
`\begin{tabular}{l | l | l}`{.raw}
`S‚Çú[AEnv]`      `&`{.raw} `S‚Çú[AEnv]`       `&`{.raw} `S‚Çú[AEnv]`     `\\`{.raw}
`S‚Çú[AKAddr]`    `&`{.raw} `S‚Çú[AKAddr]`     `&`{.raw} `S‚Çú[AKAddr]`   `\\`{.raw}
`S‚Çú[AKStore]`   `&`{.raw} `S‚Çú[AKStore]`    `&`{.raw} `S‚Çú[AKStore]`  `\\`{.raw}
`S‚Çú[ATime]`    `&`{.raw} `S‚Çú[ATime]`     `&`{.raw} `S‚Çú[ATime]`   `\\`{.raw}
`S‚Çú[AStore]`   `&`{.raw} `FS‚Çú`           `&`{.raw} `FI‚Çú`         `\\`{.raw}
`FS‚Çú`          `&`{.raw} `S‚Çú[AStore]`    `&`{.raw} `S‚Çú[AStore]`  `\\`{.raw}
`\end{tabular}`{.raw}
\vspace{1em}

\noindent
From left to right, these give path-sensitive, flow-sensitive, and flow-insensitive analyses.
Furthermore, each monad stack with abstract components is assigned a Galois connection by-construction with their concrete analogues:

\vspace{1em}
`\begin{tabular}{l | l | l}`{.raw}
`S‚Çú[CEnv]`      `&`{.raw} `S‚Çú[CEnv]`       `&`{.raw} `S‚Çú[CEnv]`     `\\`{.raw}
`S‚Çú[CKAddr]`    `&`{.raw} `S‚Çú[CKAddr]`     `&`{.raw} `S‚Çú[CKAddr]`   `\\`{.raw}
`S‚Çú[CKStore]`   `&`{.raw} `S‚Çú[CKStore]`    `&`{.raw} `S‚Çú[CKStore]`  `\\`{.raw}
`S‚Çú[CTime]`    `&`{.raw} `S‚Çú[CTime]`     `&`{.raw} `S‚Çú[CTime]`   `\\`{.raw}
`S‚Çú[CStore]`   `&`{.raw} `FS‚Çú`           `&`{.raw} `FI‚Çú`         `\\`{.raw}
`FS‚Çú`          `&`{.raw} `S‚Çú[CStore]`    `&`{.raw} `S‚Çú[CStore]`  `\\`{.raw}
`\end{tabular}`{.raw}
\vspace{1em}

Another benefit of our approach is that we can selectively widen the value store and the continuation store independent of each other.
To do this we merely swap the order of transformers:

\vspace{1em}
`\begin{tabular}{l | l | l}`{.raw}
`S‚Çú[AEnv]`      `&`{.raw} `S‚Çú[AEnv]`       `&`{.raw} `S‚Çú[AEnv]`     `\\`{.raw}
`S‚Çú[AKAddr]`    `&`{.raw} `S‚Çú[AKAddr]`     `&`{.raw} `S‚Çú[AKAddr]`   `\\`{.raw}
`S‚Çú[ATime]`    `&`{.raw} `S‚Çú[ATime]`     `&`{.raw} `S‚Çú[ATime]`   `\\`{.raw}
`S‚Çú[AKStore]`   `&`{.raw} `FS‚Çú`           `&`{.raw} `FI‚Çú`         `\\`{.raw}
`S‚Çú[AStore]`   `&`{.raw} `S‚Çú[AKStore]`    `&`{.raw} `S‚Çú[AKStore]`  `\\`{.raw}
`FS‚Çú`          `&`{.raw} `S‚Çú[AStore]`    `&`{.raw} `S‚Çú[AStore]`  `\\`{.raw}
`\end{tabular}`{.raw}
\vspace{1em}

\noindent
yielding analyses which are flow-sensitive and flow-insensitive for both the continuation and value stores.

# Implementation

We have implemented our framework in Haskell and applied it to compute analyses for `ŒªIF`.
Our implementation provides path-sensitivity, flow-sensitivity, and flow-insensitivity as a semantics-independent monad library.
The code shares a striking resemblance with the math.

Our interpreter for `ŒªIF` is parameterized as discussed in Section`~\ref{analysis-parameters}`{.raw}.
We express a valid analysis with the following Haskell constraint:
`````indent```````````````````````````````````````
type Analysis(Œ¥,Œº,m) ‚à∑ Constraint = 
  (AAM(Œº),Delta(Œ¥),AnalysisMonad(Œ¥,Œº,m))
``````````````````````````````````````````````````
Constraints `AAM(Œº)` and `Delta(Œ¥)` are interfaces for abstract time and the abstract domain.

\noindent
The constraint `AnalysisMonad(m)` requires only that `m` has the required effects[^1]:
`````indent```````````````````````````````````````
type AnalysisMonad(Œ¥,Œº,m) ‚à∑ Constraint = (
   Monad(m(Œ¥,Œº)), 
   MonadNondeterminism(m(Œ¥,Œº)),
   MonadState(Env(Œº))(m(Œ¥,Œº)),
   MonadState(Store(Œ¥,Œº))(m(Œ¥,Œº)),
   MonadState(Time(Œº,Call))(m(Œ¥,Œº)))
``````````````````````````````````````````````````
Our interpreter is implemented against this interface and concrete and abstract interpreters are recovered by instantiating `Œ¥`, `Œº` and `m`.

[^1]: 
    We use a CPS representation and a single store in our implementation.
    This requires `Time`, which is generic to the language, to take `Call` as a parameter rather than `Exp √ó KAddr`.

Using Galois transformers, we enable arbitrary composition of choices for various analysis components.
For example, our implementation, called `maam` supports command-line flags for garbage collection, k-CFA, and path- and flow-sensitivity.
``````````````````````````````````````````````````
./maam --gc --CFA=0 --flow-sen prog.lam
``````````````````````````````````````````````````
These flags are implemented completely independent of one another, 
  and their combination is applied to a single parameterized monadic interpreter.
Furthermore, using Galois transformers allows us to prove each combination correct in one fell swoop.

Our implementation is publicly available and can be installed as a cabal package by executing:
`````align````````````````````````````````````````
cabal install maam
``````````````````````````````````````````````````

# Related Work

Program analysis comes in many forms such as points-to
\cite{dvanhorn:Andersen1994Program}, flow
\cite{dvanhorn:Jones:1981:LambdaFlow}, or shape analysis
\cite{dvanhorn:Chase1990Analysis}, and the literature is vast. (See
\citet{dvanhorn:hind-paste01,dvanhorn:Midtgaard2012Controlflow} for
surveys.)  Much of the research has focused on developing families or
frameworks of analyses that endow the abstraction with a number of
knobs, levers, and dials to tune precision and compute efficiently
(some examples include \citet{dvanhorn:Shivers:1991:CFA,
dvanhorn:nielson-nielson-popl97, dvanhorn:Milanova2005Parameterized,
davdar:van-horn:2010:aam}; there are many more).  These parameters
come in various forms with overloaded meanings such as object-
\cite{dvanhorn:Milanova2005Parameterized,
dvanhorn:Smaragdakis2011Pick}, context-
\cite{dvanhorn:Sharir:Interprocedural, dvanhorn:Shivers:1991:CFA},
path- \cite{davdar:das:2002:esp}, and heap-
\cite{davdar:van-horn:2010:aam} sensitivities, or some combination
thereof \cite{dvanhorn:Kastrinis2013Hybrid}.

These various forms can all be cast in the theory of abstraction
interpretation of \citet{dvanhorn:Cousot:1977:AI,
dvanhorn:Cousot1979Systematic} and understood as computable
approximations of an underlying concrete interpreter.  Our work
demonstrates that if this underlying concrete interpreter is written
in monadic style, monad transformers are a useful way to organize and
compose these various kinds of program abstractions in a modular and
language-independent way.  

This work is inspired by the combination of
 \citeauthor{dvanhorn:Cousot:1977:AI}'s theory of abstract
 interpretation based on Galois connections
 \citeyearpar{dvanhorn:Cousot:1977:AI, dvanhorn:Cousot1979Systematic,
 dvanhorn:Cousot98-5}, \citeauthor{dvanhorn:Liang1995Monad}'s monad
 transformers for modular interpreters
 \citeyearpar{dvanhorn:Liang1995Monad} and
 \citeauthor{dvanhorn:Sergey2013Monadic}'s monadic abstract
 interpreters \citeyearpar{dvanhorn:Sergey2013Monadic}, and continues in the tradition of applying monads to programming language semantics pioneered by \citet{davdar:Moggi:1989:Monads}.

\citet{dvanhorn:Liang1995Monad} first demonstrated how monad
transformers could be used to define building blocks for constructing
(concrete) interpreters.  Their interpreter monad
\mbox{\(\mathit{InterpM}\)} bears a strong resemblance to ours.  We
show this "building blocks" approach to interpreter construction
extends to \emph{abstract} interpreter construction, too, by using
Galois transfomers.  Moreover, we show that these monad transformers
can be proved sound via a Galois connection to their concrete
counterparts, ensuring the soundness of any stack built from sound
blocks of Galois transformers.  Soundness proofs of various forms of
analysis are notoriously brittle with respect to language and analysis
features.  A reusable framework of Galois transformers offers a
potential way forward for a modular metatheory of program analysis.

\citet{dvanhorn:Cousot98-5} develops a "calculational approach" to
analysis design whereby analyses are not designed and then verified
\emph{post facto} but rather derived by positing an abstraction and
calculating it through the concrete interpreter using Galois
connections.  These calculations are done by hand.  Our approach
offers a limited ability to automate the calculation process by
relying on monad transformers to combine different abstractions.

\citet{dvanhorn:Sergey2013Monadic} first introduced Monadic Abstract
Interpreters (MAI), in which interpreters are also written in monadic
style and variations in analysis are recovered through new monad
implementations.  However, each monad in MAI is designed from scratch
for a specific language to have specific analysis properties.  The MAI
work is analogous to monadic interpreter of
\citet{dvanhorn:Wadler1992Essence}, in which the monad structure is
monolithic and must be reconstructed for each new language feature.
Our work extends the ideas in MAI in a way that isolates each
parameter to be independent of others, similar to the approach of
\citet{dvanhorn:Liang1995Monad}.  We factor out the monad as a truly
semantics independent feature.  This factorization reveals an
orthogonal tuning knob for path- and flow-sensitivity.  Even more, we
give the user building blocks for constructing monads that are correct
and give the desired properties by construction.  Our framework is
also motivated by the needs of reasoning formally about abstract
interpreters, no mention of which is made in MAI.

We build directly on the work of Abstracting Abstract Machines (AAM) by \citet{davdar:van-horn:2010:aam}
  in our parameterization of abstract time and call-site-sensitivity.
More notably, we follow the AAM philosophy of instrumenting a concrete semantics _first_ and performing a systematic abstraction _second_.
This greatly simplifies the Galois connection arguments during systematic abstraction.
However, this is at the cost of proving that the instrumented semantics simulate the original concrete semantics.


# Conclusion

We have shown that \emph{Galois transfomers}, monad transfomers that
form Galois connections, are effective, language-inde\-pendent building
blocks for constructing program analyzers and form the basis of a
modular, reusable, and composable metatheory for program analysis.

In the end, we hope language independent characterizations of analysis
ingredients will both facilate the systematic construction of program
analyses and bridge the gap between various communities which often
work in isolation, despite the fruitful results of mapping between
langauge paradigms such as the work of \citet{dvanhorn:Might2010Resolving},
showing that object-oriented $k$-CFA can be applied to functional
languages to avoid the exponential time lower bound
\cite{dvanhorn:VanHorn-Mairson:ICFP08}.
