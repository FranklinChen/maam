# Introduction

Traditional practice in the program analysis literature, be it for
points-to, flow, shape analysis or others, is to fix a language and
its abstraction (a computable, sound approximation to the "concrete"
semantics of the language) and investigate its effectiveness [CITE
overload].  These one-off abstractions require effort to design and
prove sound.  Consequently later work has focused on endowing the
abstraction with a number of knobs, levers, and dials to tune
precision and compute efficiently [CITE overload].  These parameters
come in various forms with overloaded meanings such as
object`~\cite{dvanhorn:Milanova2005Parameterized}`{.raw}, context [CITE],
path [CITE], and heap [CITE] sensitivities, or some combination
thereof [CITE].  These efforts develop families of analyses for a
specific language and prove the framework sound.

But even this framework approach suffers from many of the same drawbacks as the
one-off analyzers.  They are language specific, preventing reuse across
languages and thus requiring similar abstraction implementations and soundness
proofs.  This process is difficult and error prone.  It results in a cottage
industry of research papers on varying frameworks for varying languages.  It
prevents fruitful insights and results developed in one paradigm from being
applied to others [PLDI'10].

In this paper, we propose an alternative approach to structuring and
implementing program analysis.  We propose to use concrete interpreters in
monadic style.  As we show, classical program abstractions can be embodied as
language-independent monads.  Moveover, these abstractions can be written as
monad transformers, thereby allowing their composition to achieve new forms of
analysis.  Most significantly, these monad transformers can be proved sound
once and for all.  Abstract interpreters, which take the form of monad
transformer stacks coupled together with a monadic interpreter, inherit the
soundness properties of each element in the stack.  This approach enables reuse
of abstractions across languages and lays the foundation for a modular
metatheory of program analysis.

## Contributions

Our contributions are:

- A compositional meta-theory framework for building correct-by-construction abstract interpreters.
  This framework is built using a restricted class of monad transformers.
- An isolated understanding of flow and path sensitivity for static analysis.
  We understand this spectrum as mere variations in the order of monad transformer composition in our framework.

## Outline

We will demonstrate our framework by example, walking the reader through the design and implementation of an abstract interpreter.
Section [2][Semantics] gives the concrete semantics for a small functional language.
Section [3][Flow Properties in Analysis] gives a brief tutorial on the path and flow sensitivity in the setting of our example language.
Section [4][Analysis Parameters] describes the parameters of our analysis, one of which is the interpreter monad.
Section [5][The Interpreter] shows the full definition of a highly parameterized monadic interpreter.
Section [6][Recovering Analyses] shows how to recover concrete and abstract interpreters.
Section [7][Varying Path and Flow Sensitivity] 
  shows how to manipulate the path and flow sensitivity of the interpreter through varyations in the monad.
Section [8][A Compositional Monadic Framework] demonstrates our compositional meta-theory framework built on monad transformers.
Section [9][Implementation] briefly discusses our implementation of the framework in Haskell.
Section [10][Related Word] discusses related work and Section [11][Conclusion] concludes.

# Semantics

To demonsrate our framework we design an abstract interpreter for `ŒªIF` a simple applied lambda calculus, 
  which is shown in Figure \ref{Syntax}.
`\begin{figure}`{.raw}
`````align````````````````````````````````````````
  i ‚àà  ‚Ñ§
  x ‚àà  Var
  a ‚àà  Atom  ::= i | x | [Œª](x).e
  ‚äï ‚àà  IOp   ::= [+] | [-]
  ‚äô ‚àà  Op    ::= ‚äï | @ 
  e ‚àà  Exp   ::= a | e ‚äô e | if0(e){e}{e}
``````````````````````````````````````````````````
`\caption{`{.raw}
`ŒªIF`
`} \label{Syntax} \end{figure}`{.raw}
`ŒªIF` extends traditional lambda calculus with integers, addition, subtration and conditionals.
We use the operator `@` as explicit syntax for function application.
This allows for `Op` to be a single syntactic class for all operators and simplifies the presentation.

Before designing an abstract interpreter we first specify a formal semantics for `ŒªIF`.
Our semantics makes allocation explicit and separates values and continuations into separate stores.
Our approach to analysis will be to design a configurable interpreter that is capable of mirroring these semantics.

The state space `Œ£` for `ŒªIF` is a standard CESK machine augmented with a separate store for continuation values:
`````align````````````````````````````````````````
 œÑ ‚àà  Time    := ‚Ñ§
 l ‚àà  Addr    := Var √ó Time
 œÅ ‚àà  Env     := Var ‚áÄ Addr
 œÉ ‚àà  Store   := Addr ‚áÄ Val
 c ‚àà  Clo     ::= ‚ü®[Œª](x).e,œÅ‚ü© 
 v ‚àà  Val     ::= i | c
Œ∫l ‚àà  KAddr   := Time
Œ∫œÉ ‚àà  KStore  := KAddr ‚áÄ Frame √ó KAddr
fr ‚àà  Frame   ::= ‚ü®‚ñ° ‚äô e‚ü© | ‚ü®v ‚äô ‚ñ°‚ü© | ‚ü®if0(‚ñ°){e}{e}‚ü©
 œÇ ‚àà  Œ£       ::= Exp √ó Env √ó Store √ó KAddr √ó KStore
``````````````````````````````````````````````````

Atomic expressions are given meaning through the denotation function `A‚ü¶_,_,_‚üß`:
`````indent```````````````````````````````````````
A‚ü¶_,_,_‚üß ‚àà Env √ó Store √ó Atom ‚áÄ Val
A‚ü¶œÅ,œÉ,i‚üß := i
A‚ü¶œÅ,œÉ,x‚üß := œÉ(œÅ(x))
A‚ü¶œÅ,œÉ,[Œª](x).e‚üß := ‚ü®[Œª](x).e,œÅ‚ü© 
``````````````````````````````````````````````````
Primitive operations are given meaning through the denotation function `Œ¥‚ü¶_,_,_‚üß`:
`````indent```````````````````````````````````````
Œ¥‚ü¶_,_,_‚üß ‚àà IOp √ó ‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñ§
Œ¥‚ü¶[+],i‚ÇÅ,i‚ÇÇ‚üß := i‚ÇÅ + i‚ÇÇ
Œ¥‚ü¶[-],i‚ÇÅ,i‚ÇÇ‚üß := i‚ÇÅ - i‚ÇÇ
``````````````````````````````````````````````````

The semantics of compound expressions are given relationally via the step relation `_~~>_`:
`````indent```````````````````````````````````````
_~~>_ ‚àà ùí´(Œ£ √ó Œ£)
‚ü®e‚ÇÅ ‚äô e‚ÇÇ,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e‚ÇÅ,œÅ,œÉ,œÑ,Œ∫œÉ',œÑ+1‚ü©
  where Œ∫œÉ' := Œ∫œÉ[œÑ ‚Ü¶ ‚ü®‚ñ° ‚äô e‚ÇÇ‚ü©‚à∑Œ∫l]
‚ü®a,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ,œÉ,œÑ,Œ∫œÉ',tick(œÑ)‚ü©
  where 
    ‚ü®‚ñ° ‚äô e‚ü©‚à∑Œ∫l' := Œ∫œÉ(Œ∫l)
    Œ∫œÉ' := Œ∫œÉ[œÑ ‚Ü¶ ‚ü®A‚ü¶œÅ,œÉ,a‚üß ‚äô ‚ñ°‚ü©‚à∑Œ∫l']
‚ü®a,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ'',œÉ',Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    ‚ü®‚ü®[Œª](x).e,œÅ'‚ü© @ ‚ñ°‚ü©‚à∑Œ∫l':= Œ∫œÉ(Œ∫l)
    œÉ' := œÉ[(x,œÑ) ‚Ü¶ A‚ü¶œÅ,œÉ,a‚üß]
    œÅ'' := œÅ'[x ‚Ü¶ (x,œÑ)]
‚ü®i‚ÇÇ,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®i,œÅ,œÉ,Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    ‚ü®i‚ÇÅ ‚äï ‚ñ°‚ü©‚à∑Œ∫l' := Œ∫œÉ(Œ∫l)
    i := Œ¥‚ü¶‚äï,i‚ÇÅ,i‚ÇÇ‚üß
‚ü®i,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ,œÉ,Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    ‚ü®if0(‚ñ°){e‚ÇÅ}{e‚ÇÇ}‚ü©‚à∑Œ∫l' := Œ∫œÉ(Œ∫l)
    e := e‚ÇÅ when i = 0
    e := e‚ÇÇ when i ‚â† 0
``````````````````````````````````````````````````

Our abstract intepreter will support abstract garbage collection [CITE], the concrete analogue of which is just standard garbage collection.
Garbage collection is defined with a reachability function `R` which computes the transitively reachable address from `(œÅ,e)` in `œÉ`:
`````indent```````````````````````````````````````
R[_] ‚àà Store ‚Üí Env √ó Exp ‚Üí ùí´(Addr)
R[œÉ](œÅ,e) := Œº(X). 
  R‚ÇÄ(œÅ,e) ‚à™ X ‚à™ {l' | l' ‚àà R-Val(œÉ(l)) ; l ‚àà X}
``````````````````````````````````````````````````
We write `Œº(X). f(X)` as the least-fixed-point of a function `f`.
This definition uses two helper functions: `R‚ÇÄ` for computing the initial reachable set adn `R-Val` for computing addresses reachable from addresses.
`````indent```````````````````````````````````````
R‚ÇÄ ‚àà Env √ó Exp ‚Üí ùí´(Addr)
R‚ÇÄ(œÅ,e) := {œÅ(x) | x ‚àà FV(e)}
R-Val ‚àà Val ‚Üí ùí´(Addr)
R-Val(i) := {}
R-Val(‚ü®[Œª](x).e,œÅ‚ü©) := {œÅ(x) | y ‚àà FV([Œª](x).e)}
``````````````````````````````````````````````````
`FV` is the standard recursive definition for computing free variables of an expression:
`````indent```````````````````````````````````````
FV ‚àà Exp ‚Üí ùí´(Var)
FV(x) := {x}
FV(i) := {}
FV([Œª](x).e) := FV(e) - {x}
FV(e‚ÇÅ ‚äô e‚ÇÇ) := FV(e‚ÇÅ) ‚à™ FV(e‚ÇÇ)
FV(if0(e‚ÇÅ){e‚ÇÇ}{e‚ÇÉ}) := FV(e‚ÇÅ) ‚à™ FV(e‚ÇÇ) ‚à™ FV(e‚ÇÉ)
``````````````````````````````````````````````````

Analagously, `KR` is the set of transitively reachabel continuation addresses in `Œ∫œÉ`:
`````indent```````````````````````````````````````
KR[_] ‚àà KStore ‚Üí KAddr ‚Üí ùí´(KAddr)
KR[Œ∫œÉ](Œ∫l) := Œº(kŒ∏). Œ∫Œ∏‚ÇÄ ‚à™ Œ∫Œ∏ ‚à™ {œÄ‚ÇÇ(Œ∫œÉ(Œ∫l)) | Œ∫l ‚àà Œ∫Œ∏}
``````````````````````````````````````````````````

Our final semantics is given via the step relation `_~~>·µç·∂ú_` which nondeterministically either takes a semantic step or performs garbage collection.
`````indent```````````````````````````````````````
_~~>·µç·∂ú_ ‚àà ùí´(Œ£ √ó Œ£)
œÇ ~~>·µç·∂ú œÇ' 
  where œÇ ~~> œÇ'
‚ü®e,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~>·µç·∂ú ‚ü®e,œÅ,œÉ',Œ∫l,Œ∫œÉ,œÑ‚ü©
  where 
    œÉ' := {l ‚Ü¶ œÉ(l) | l ‚àà R[œÉ](œÅ,e)}
    Œ∫œÉ' := {Œ∫l ‚Ü¶ Œ∫œÉ(Œ∫l) | Œ∫l ‚àà KR[Œ∫œÉ](Œ∫l)}
``````````````````````````````````````````````````

An execution of the semantics is states as the least-fixed-point of a collecting semantics:
`````indent```````````````````````````````````````
Œº(X).{œÇ‚ÇÄ} ‚à™ X ‚à™ { œÇ' | œÇ ~~>·µç·∂ú œÇ' ; œÇ ‚àà X }
``````````````````````````````````````````````````
The analyses we present in this paper will be proven correct by establishing a Galois connection with this concrete collecting semantics.

# Flow Properties in Analysis

One key property of a static analysis is the way it tracks _flow_.
The term "flow" is heavily overloaded in static analysis, for example CFA is literally the abbreviation of "control flow analysis".
We wish to draw a sharper distinction on what is a flow property.
First we identify three different types of flow in analysis:

1. Path sensitive and flow sensitive
2. Path insensitive and flow sensitive
3. Path insensitive and flow insensitive

Consider a simple if-statement in our example language `ŒªIF` (extended with let-bindings) where an analysis cannot determine the value of `N`:
`````indent```````````````````````````````````````
1: let x := if0(N){1}{-1};
2: let y := if0(N){1}{-1};
3: e
``````````````````````````````````````````````````

\paragraph{Path Sensitive Flow Sensitive}
A path and flow sensitive analysis will track both control and data flow precisely.
At program point 2 the analysis considers separate worlds:
`````align````````````````````````````````````````
{N=0,,  x=   1}
{N‚â†0,,  x=-  1}
``````````````````````````````````````````````````
At program point 3 the analysis remains precise, resulting in environments:
`````align````````````````````````````````````````
{N=0,,  x=   1,,  y=   1} 
{N‚â†0,,  x=-  1,,  y=-  1}
``````````````````````````````````````````````````

\paragraph{Path Insensitive Flow Sensitive}
A path insensitive flow sensitive analysis will track control flow precisely but merge the heap after control flow branches.
At program point 2 the analysis considers separate worlds:
`````align````````````````````````````````````````
{N=ANY,,  x=   1}
{N=ANY,,  x=-  1}
``````````````````````````````````````````````````
At program point 3 the analysis is forced to again consider both branches, resulting in environments:
`````align````````````````````````````````````````
{N=ANY,,  x=   1,,  y=   1}
{N=ANY,,  x=   1,,  y=-  1}
{N=ANY,,  x=-  1,,  y=   1}
{N=ANY,,  x=-  1,,  y=-  1}
``````````````````````````````````````````````````

\paragraph{Path Insensitive Flow Insensitive}
A path insensitive flow insensitive analysis will compute a single global set of facts that must be true at all points of execution.
At program points 2 and 3 the analysis considers a single world with environment:
`````align````````````````````````````````````````
{N=ANY,, x={-1, 1}}
``````````````````````````````````````````````````
and 
`````align````````````````````````````````````````
{N=ANY,, x={-1, 1},, y={-1, 1}}
``````````````````````````````````````````````````
respectively.

In our framework we capture both path and flow sensitivity as orthogonal parameters to our interpreter.
Path sensitivity will arise from the order of monad transformers used to construct the analysis.
Flow sensitivity will arise from the Galois connection used to map interpreters to state space transition systems.
For brevity, and lack of better terms, we will abbreviate these analyses as "path sensitive", "flow sensitive" and "flow insensitive".
This is only ambiguous for "flow sensitive", as path sensitivity implies flow sensitivity, and flow insensitivity implies path insensitivity.

# Analysis Parameters

Before writing an abstract interpreter we first design its parameters.
The interpreter will be designed such that variations in these paramaters recover the concrete and a family of abstract interpretrs.
To do this we extend the ideas developed in AAM[CITE] with a new parameter for flow-sensitivity.
When finished, we will be able to recover a concrete interpreter--which respects the concrete semantics--and a family of abstract interpreters.

First we describe the parameters to the interpreter.
Then we conclude the section with an implementation which is generic to these parameters.

There will be three parameters to our abstract interpreter, one of which is novel in this work:

1. The monad, novel in this work.
   This is the execution engine of the interpreter and captures the flow-sensitivity of the analysis.
2. The abstract domain.
   For our language is merely an abstraction for integers.
3. The abstraction for time. 
   Abstract time captures the call-site sensitivity of the analysis, as introduced by [CITE].

We place each of these parameters behind an abstract interface and leave their implementations opaque for the generic monadic interpreter.
We will give each of these parameters reasoning principles as we introduce them.
These reasoning principles allow us to reason about the correctness of the generic interpreter independent of a particular instantiation.
The goal is to factor as much of the proof-effort into what we can say about the generic interpreter.
An instantiation of the interpreter need only justify that each parameter meets their local interface.

## The Monad

The monad for the interpreter is capturing the _effects_ of interpretation.
There are two effects we wish to model in the interpreter, state and nondeterminism.
The state effect will mediate how the interpreter interacts with state cells in the state space, like `Env` and `Store`.
The nondeterminism effect will mediate the branching of the execution from the interpreter.
Our result is that path and flow sensitivities can be recovered by altering how these effects interact in the monad.

We briefly review monad, state and nondeterminism operators and thier laws.

### Monad Properties
To be a monad, a type operator `M` must support the `bind` operation:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, M(Œ±) ‚Üí (Œ± ‚Üí M(Œ≤)) ‚Üí M(Œ≤)
``````````````````````````````````````````````````
as well as a unit for `bind` called `return`:
`````indent```````````````````````````````````````
return : ‚àÄ Œ±, Œ± ‚Üí M(Œ±)
``````````````````````````````````````````````````

We use the monad laws to reason about our implementation in the absence of a particular implementatino of `bind` and `return`:
`````indent```````````````````````````````````````
unit‚ÇÅ : bind(return(a))(k) = k(a)
unit‚ÇÇ : bind(m)(return) = m
assoc : bind(bind(m)(k‚ÇÅ))(k‚ÇÇ) = bind(m)(Œª(a).bind(k‚ÇÅ(a))(k‚ÇÇ))
``````````````````````````````````````````````````
`bind` and `return` mean something different for each monadic effect class.
For state, `bind` is a sequencer of state and `return` is the "no change in state" effect.
For nondeterminism, `bind` implements a merging of multiple branches and `return` is the singleton branch.
These operators capture the essence of the combination of explicit state-passing and set comprehension in the interpreter.
Our interpreter will use these operators and avoid referencing an explicit configuration `œÇ` or explicit collections of results.

As is traditional with monadic programming, we use `do` and semicolon notation as syntactic sugar for `bind`.
For example:
`````indent```````````````````````````````````````
do 
  a ‚Üê m 
  k(a)
``````````````````````````````````````````````````
and
`````indent```````````````````````````````````````
a ‚Üê m ; k(a)
``````````````````````````````````````````````````
are both just sugar for
`````indent``````````````````````````````````````` 
bind(m)(k)
``````````````````````````````````````````````````

### Monad State Properties
Interacting with a state component like `Env` is achieved through `get-Env` and `put-Env` effects:
`````indent``````````````````````````````````````` 
get-Env : M(Env)
put-Env : Env ‚Üí M(1)
``````````````````````````````````````````````````

We use the state monad laws to reason about state effects:
`````indent``````````````````````````````````````` 
put-put : put(s‚ÇÅ) ; put(s‚ÇÇ) = put(s‚ÇÇ)
put-get : put(s) ; get = return(s)
get-put : s ‚Üê get ; put(s) = return(1)
get-get : s‚ÇÅ ‚Üê get ; s‚ÇÇ ‚Üê get ; k(s‚ÇÅ,s‚ÇÇ) = s ‚Üê get ; k(s,s)
``````````````````````````````````````````````````
The effects for `get-Store`, `get-KAddr` and `get-KStore` are identical.

### Monad Nondeterminism Properties

Nondeterminism is achieved through operators `mzero` and `‚ü®+‚ü©`:
`````indent``````````````````````````````````````` 
mzero : ‚àÄ Œ±, M(Œ±)
_‚ü®+‚ü©_ : ‚àÄ Œ±, M(Œ±) √ó M(Œ±) ‚Üí M(Œ±)
`````````````````````````````````````````````````` 

We use the nondeterminism laws to reason about nondeterminism effects:
`````indent```````````````````````````````````````
‚ä•-zero‚ÇÅ : bind(mzero)(k) = mzero
‚ä•-zero‚ÇÇ : bind(m)(Œª(a).mzero) = mzero
‚ä•-unit‚ÇÅ : mzero ‚ü®+‚ü© m = m
‚ä•-unit‚ÇÇ : m ‚ü®+‚ü© mzero = m 
+-assoc : m‚ÇÅ ‚ü®+‚ü© (m‚ÇÇ ‚ü®+‚ü© m‚ÇÉ) = (m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ) ‚ü®+‚ü© m‚ÇÉ
+-comm : m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ = m‚ÇÇ ‚ü®+‚ü© m‚ÇÅ
+-dist : bind(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(k) = bind(m‚ÇÅ)(k) ‚ü®+‚ü© bind(m‚ÇÇ)(k)
``````````````````````````````````````````````````

## The Abstract Domain

The abstract domain is encapsulated by the `Val` type in the semantics.
To parameterize over it, we make `Val` opaque but require it support various operations.
There is a constraint on `Val` its-self: it must be a join-semilattice with `‚ä•` and `‚äî` respecting the usual laws.
We require `Val` to be a join-semilattice so it can be merged in the `Store`.

The interface for integers consists of introduction and elimiation rules:
`````indent```````````````````````````````````````
int-I : ‚Ñ§ ‚Üí Val
int-if0-E : Val ‚Üí ùí´(Bool)
``````````````````````````````````````````````````

The laws for this interface are designed to induce a Galois connection between `‚Ñ§` and `Val`:
`````indent```````````````````````````````````````
{true}  ‚äë int-if0-E(int-I(i))     if i = 0
{false} ‚äë int-if0-E(int-I(i))     if i ‚â† 0
v ‚äí ‚®Ü‚∏§b ‚àà int-if0-E(v)‚∏• Œ∏(b)
  where 
    Œ∏(true)  = int-I(0)
    Œ∏(false) = ‚®Ü‚∏§i ‚àà ‚Ñ§ | i ‚â† 0‚∏• int-I(i)
``````````````````````````````````````````````````

Additionally we must abstract closures:
`````indent```````````````````````````````````````
clo-I : Clo ‚Üí Val
clo-E : Val ‚Üí ùí´(Clo)
``````````````````````````````````````````````````
which follow similar laws:
`````indent```````````````````````````````````````
{c} ‚äë clo-E(cloI(c))
v ‚äë ‚®Ü‚∏§c ‚àà clo-E(v)‚∏• clo-I(c)
``````````````````````````````````````````````````

The denotation for primitive operations `Œ¥` must also be opaque:
`````indent```````````````````````````````````````
Œ¥‚ü¶_,_,_‚üß : IOp √ó Val √ó Val ‚Üí Val
``````````````````````````````````````````````````

We can also give soundness laws for `Œ¥` using int-I and int-if0-E:
`````indent```````````````````````````````````````
int-I(i‚ÇÅ + i‚ÇÇ) ‚äë Œ¥‚ü¶[+],int-I(i‚ÇÅ),int-I(i‚ÇÇ)‚üß
int-I(i‚ÇÅ - i‚ÇÇ) ‚äë Œ¥‚ü¶[-],int-I(i‚ÇÅ),int-I(i‚ÇÇ)‚üß 
``````````````````````````````````````````````````

Supporting additional primitive types like booleans, lists, or arbitrary inductive datatypes is analagous.
Introduction functions inject the type into `Val`.
Elimination functions project a finite set of discrete observations.
Introduction and elimination operators must follow a Galois connection discipline.

Of note is our restraint from allowing operations over `Val` to have monadic effects.
We set things up specifically in this way so that `Val` and the monad `M` can be varied independent of each other.

## Abstract Time 

The interface for abstract time is familiar from the AAM literature:
`````indent```````````````````````````````````````
tick : Exp √ó KAddr √ó Time ‚Üí Time
``````````````````````````````````````````````````

In traditional AAM, `tick` is defined to have access to all of `Œ£`.
This comes from the generality of the framework--to account for all possibile `tick` functions.
We only discuss instantiating `Addr` to support k-CFA, so we specialize the `Œ£` parameter to `Exp √ó KAddr`.
Also in AAM is the opaque function `alloc : Var √ó Time ‚Üí Addr`.
Because we will only ever use the identity function for `alloc`, we omit its abstraction and instantiation in our development.

Remarkably, we need not state laws for `tick`.
Our interpreter will always merge values which reside at the same address to achieve soundness.
Therefore, any supplied implementations of `tick` is valid.

# The Interpreter

We now present a generic monadic interpreter for `ŒªIF` paramaterized over `M`, `Val` and `Time`.

In moving our semantics to an analysis, we will need to reuse addresses in the state space.
This induces `Store` and `KStore` to join when binding new values to in-use addresses.
The state space for our interpreter will therefore use the following domain for `Store` and `KStore`:
`````indent```````````````````````````````````````
œÉ  ‚àà Store  : Addr ‚Üí Val
Œ∫œÉ ‚àà KStore : KAddr ‚Üí ùí´(Frame √ó KAddr)
``````````````````````````````````````````````````

We have already established a join-semilattice structure for `Val`.
Developing a custom join-semilattice for continuations is possible, and is the key component of recent developments in pushdown abstraction.
For this presentation we use `ùí´(Frame √ó KAddr)` as an abstraction for continuations for simplicity.

Before defining the interpreter we define some helper functions which interact with the underlying monad `M`.

First, values in `ùí´(Œ±)` can be lifted to monadic values `M(Œ±)` using `return` and `mzero`, which we name `‚Üë‚Çö`:
`````indent```````````````````````````````````````
‚Üë‚Çö : ‚àÄ Œ±, ùí´(Œ±) ‚Üí M(Œ±)
‚Üë‚Çö({a‚ÇÅ .. a‚Çô}) := return(a‚ÇÅ) ‚ü®+‚ü© .. ‚ü®+‚ü© return(a‚Çô)
``````````````````````````````````````````````````

Allocating addresses and updating time can be implemented using monadic state effects:
`````indent```````````````````````````````````````
allocM : Var ‚Üí M(Addr)
allocM(x) := do
  œÑ ‚Üê get-Time
  return(x,œÑ)
Œ∫allocM : M(KAddr)
Œ∫allocM := do
  œÑ ‚Üê get-Time
  return(œÑ)
tickM : Exp ‚Üí M(1)
tickM(e) = do
  œÑ ‚Üê get-Time
  Œ∫l ‚Üê get-KAddr
  put-Time(tick(e,Œ∫l,œÑ))
``````````````````````````````````````````````````

Finally, we introduce helper functions for manipulating stack frames:
`````indent```````````````````````````````````````
push : Frame ‚Üí M(1)
push(fr) := do
  Œ∫l ‚Üê get-KAddr
  Œ∫œÉ ‚Üê get-KStore
  Œ∫l' ‚Üê Œ∫allocM
  put-KStore(Œ∫œÉ ‚äî [Œ∫l' ‚Ü¶ {fr‚à∑Œ∫l}])
  put-KAddr(Œ∫l')
pop : M(Frame)
pop := do
  Œ∫l ‚Üê get-KAddr
  Œ∫œÉ ‚Üê get-KStore
  fr‚à∑Œ∫l' ‚Üê ‚Üë‚Çö(Œ∫œÉ(Œ∫l))
  put-KAddr(Œ∫l')
  return(fr)
``````````````````````````````````````````````````

To implement our interpreter we define a denotation function for atomic expressions and a step function for compound expressions.
The denotation for atomic expressions is written as a monadic computation from atomic expresssions to values.
`````indent```````````````````````````````````````
A‚ü¶_‚üß ‚àà Atom ‚Üí M(Val)
A‚ü¶i‚üß := return(int-I(i))
A‚ü¶x‚üß := do
  œÅ ‚Üê get-Env
  œÉ ‚Üê get-Store
  l ‚Üê ‚Üë‚Çö(œÅ(x))
  return(œÉ(x))
A‚ü¶[Œª](x).e‚üß := do
  œÅ ‚Üê get-Env
  return(clo-I(‚ü®[Œª](x).e,œÅ‚ü©))
``````````````````````````````````````````````````
The step function is written as a small-step monadic computation from expressions to the next expression to evaluate, and is shown in 
Figure \ref{Interpreter}.
Interpreting compound expressions is simple, the interpreter pushes a stack frame and continues with the first operand.
Interpreting atomic expressions must pop and inspect the stack and perform the denotation of the operation:
`\begin{figure}`{.raw}
`````indent```````````````````````````````````````
step : Exp ‚Üí M(Exp)
step(e‚ÇÅ ‚äô e‚ÇÇ) := do
  tickM(e‚ÇÅ ‚äô e‚ÇÇ)
  push(‚ü®‚ñ° ‚äô e‚ÇÇ‚ü©)
  return(e‚ÇÅ)
step(a) := do
  tickM(a)
  fr ‚Üê pop
  v ‚Üê A‚ü¶a‚üß
  case fr of
    ‚ü®‚ñ° ‚äô e‚ü© ‚Üí do
      push(‚ü®v ‚äô ‚ñ°‚ü©)
      return(e)
    ‚ü®v' @ ‚ñ°‚ü© ‚Üí do
      ‚ü®[Œª](x).e,œÅ'‚ü© ‚Üê ‚Üë‚Çö(clo-E(v'))
      l ‚Üê alloc(x)
      œÉ ‚Üê get-Store
      put-Env(œÅ'[x‚Ü¶l])
      put-Store(œÉ[l‚Ü¶v])
      return(e)
    ‚ü®v' ‚äï ‚ñ°‚ü© ‚Üí do
      return(Œ¥(‚äï,v',v))
    ‚ü®if0(‚ñ°){e‚ÇÅ}{e‚ÇÇ}‚ü© ‚Üí do
      b ‚Üê ‚Üë‚Çö(int-if0-E(v))
      if(b) then return(e‚ÇÅ) else return(e‚ÇÇ)
``````````````````````````````````````````````````
\caption{The Generic Monadic Interpreter}
\label{Interpreter}
`\end{figure}`{.raw}

We can also implement abstract garbage collection in a fully general away against the monadic effect interface:
`````indent```````````````````````````````````````
gc : Exp ‚Üí M(1)
gc(e) := do
  œÅ ‚Üê get-Env
  œÉ ‚Üê get-Store
  Œ∫œÉ ‚Üê get-KStore
  l*‚ÇÄ ‚Üê R‚ÇÄ(œÅ,e)
  Œ∫l‚ÇÄ ‚Üê get-KAddr
  let l*' := Œº(Œ∏). l*‚ÇÄ ‚à™ Œ∏ ‚à™ R[œÉ](Œ∏)
  let Œ∫l*' := Œº(Œ∫Œ∏). {Œ∫l‚ÇÄ} ‚à™ Œ∫Œ∏ ‚à™ KR[Œ∫œÉ](Œ∫Œ∏)
  put-Store({l ‚Ü¶ œÉ(l) | l ‚àà l*'})
  put-KStore({Œ∫l ‚Ü¶ Œ∫œÉ(Œ∫l) | Œ∫l ‚àà Œ∫l*'})
``````````````````````````````````````````````````
where `R‚ÇÄ` is defined as before and `R`, `KR` and `R-Clo` are defined:
`````indent```````````````````````````````````````
R : Store ‚Üí ùí´(Addr) ‚Üí ùí´(Addr)
R[œÉ](Œ∏) := { l' | l' ‚àà R-Clo(c) ; c ‚àà clo-E(v) ; v ‚àà œÉ(l) ; l ‚àà Œ∏ }
R-Clo : Clo ‚Üí ùí´(Addr)
R-Clo(‚ü®[Œª](x).e,œÅ‚ü©) := { œÅ(x) | x ‚àà FV([Œª](x).e) }
KR : KStore ‚Üí ùí´(KAddr) ‚Üí ùí´(KAddr)
KR[œÉ](Œ∫Œ∏) := { œÄ‚ÇÇ(fr) | fr ‚àà Œ∫œÉ(Œ∫l) ; Œ∫l ‚àà Œ∏ }
``````````````````````````````````````````````````

To execute the interpreter we must introduce one more parameter.
In the concrete semantics, execution takes the form of a least-fixed-point computation over the collecting semantics
This in general requires a join-semilattice structure for some `Œ£` and a transition function `Œ£ ‚Üí Œ£`.
We bridge this gap between monadic interpreters and transition functions with an extra constraint on the monad `M`.
We require that monadic actions `Œ± ‚Üí M(Œ≤)` form a Galois connection with a transition system `Œ£ ‚Üí Œ£`.

There is one last parameter to our development: a connection between our monadic interpreter and a state space transition system.
We state this connection formally as a Galois connection `(Œ£ ‚Üí Œ£)Œ±‚áÑŒ≥(Exp ‚Üí M(Exp))`.
This Galois connection serves two purposes.
First, it allows us to implement the analysis by converting our interpreter to the transition system `Œ£ ‚Üí Œ£` through `Œ≥`.
Second, this Galois connection serves to _transport other Galois connections_.
For example, given concrete and abstract versions of `Val`, we carry `CVal Œ±‚áÑŒ≥ AVal` through the Galois connection to establish `CŒ£ Œ±‚áÑŒ≥ AŒ£`.

A collecting-semantics execution of our interpreter is defined as the least-fixed-point of `step` transported through the Galois connection.
`````indent```````````````````````````````````````
Œº(X). œÇ‚ÇÄ ‚äî X ‚äî Œ≥(step)(X)
``````````````````````````````````````````````````
where `œÇ‚ÇÄ` is the injection of the initial program `e‚ÇÄ` into `Œ£ `.

# Recovering Analyses

To recover concrete and abstract interpreters we need only instantiate our generic monadic interpreter with concrete and abstract components.

## Recovering a Concrete Interpreter

For the concrete value space we instantiate `Val` to `CVal`, a powerset of values:
`````indent```````````````````````````````````````
v ‚àà CVal := ùí´(Clo + ‚Ñ§)
``````````````````````````````````````````````````

The concrete value space `CVal` has straightforward introduction and elimination rules:
`````indent```````````````````````````````````````
int-I : ‚Ñ§ ‚Üí CVal
int-I(i) := {i}
int-if0-E : CVal ‚Üí ùí´(Bool)
int-if0-E(v) := { true | 0 ‚àà v } ‚à™ { false | i ‚àà v ‚àß i ‚â† 0 }
``````````````````````````````````````````````````
and the concrete `Œ¥` you would expect:
`````indent```````````````````````````````````````
Œ¥‚ü¶_,_,_‚üß : IOp √ó CVal √ó CVal ‚Üí CVal
Œ¥‚ü¶[+],v‚ÇÅ,v‚ÇÇ‚üß := { i‚ÇÅ + i‚ÇÇ | i‚ÇÅ ‚àà v‚ÇÅ ; i‚ÇÇ ‚àà v‚ÇÇ }
Œ¥‚ü¶[-],v‚ÇÅ,v‚ÇÇ‚üß := { i‚ÇÅ - i‚ÇÇ | i‚ÇÅ ‚àà v‚ÇÅ ; i‚ÇÇ ‚àà v‚ÇÇ }
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CVal` satisfies the abstract domain laws from section [X][The Abstract Domain].
`\end{proposition}`{.raw}

Concrete time `CTime` captures program contours as a product of `Exp` and `KAddr`:
`````indent```````````````````````````````````````
œÑ ‚àà CTime := (Exp √ó KAddr)‚ãÜ
``````````````````````````````````````````````````
and `tick` is just a cons operator:
`````indent```````````````````````````````````````
tick : Exp √ó KAddr √ó CTime ‚Üí CTime
tick (e,Œ∫l,œÑ) := (e,Œ∫l)‚à∑œÑ
``````````````````````````````````````````````````

For the concrete monad we instantiate `M` to a path-sensitive `CM` which contains a powerset of concrete state space components.
`````indent```````````````````````````````````````
œà ‚àà Œ® := Env √ó CStore √ó KAddr √ó KStore √ó CTime
m ‚àà CM(Œ±) := Œ® ‚Üí ùí´(Œ± √ó Œ®)
``````````````````````````````````````````````````

Monadic operators `bind` and `return` encapsulate both state-passing and set-flattening:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ±, CM(Œ±) ‚Üí (Œ± ‚Üí CM(Œ≤)) ‚Üí CM(Œ≤)
bind(m)(f)(œà) := 
  {(y,œà'') | (y,œà'') ‚àà f(a)(œà') ; (a,œà') ‚àà m(œà)}
return : ‚àÄ Œ±, Œ± ‚Üí CM(Œ±)
return(a)(œà) := {(a,œà)}
``````````````````````````````````````````````````

State effects merely return singleton sets:
`````indent```````````````````````````````````````
get-Env : CM(Env)
get-Env(‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©) := {(œÅ,‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©)}
put-Env : Env ‚Üí ùí´(1)
put-Env(œÅ')(‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©) := {(1,‚ü®œÅ',œÉ,Œ∫,œÑ‚ü©)}
``````````````````````````````````````````````````

Nondeterminism effects are implemented with set union:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, CM(Œ±)
mzero(œà) := {}
_‚ü®+‚ü©_ : ‚àÄ Œ±, CM(Œ±) √ó CM(Œ±) ‚Üí CM(Œ±)
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(œà) := m‚ÇÅ(œà) ‚à™ m‚ÇÇ(œà)
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CM` satisfies monad, state, and nondeterminism laws.
`\end{proposition}`{.raw}

Finally, we must establish a Galois connection between `Exp ‚Üí CM(Exp)` and `CŒ£ ‚Üí CŒ£` for some choice of `CŒ£`.
For the path sensitive monad `CM` instantiate with `CVal` and `CTime`, , `CŒ£` is defined:
`````indent```````````````````````````````````````
CŒ£ := ùí´(Exp √ó Œ®)
``````````````````````````````````````````````````

The Galois connection between `CM` and `CŒ£` is straightforward:
`````indent```````````````````````````````````````
Œ≥ : (Exp ‚Üí CM(Exp)) ‚Üí (CŒ£ ‚Üí CŒ£)
Œ≥(f)(eœà*) := {(e,œà') | (e,œà') ‚àà f(e)(œà) ; (e,œà) ‚àà eœà*}
Œ± : (CŒ£ ‚Üí CŒ£) ‚Üí (Exp ‚Üí CM(Exp))
Œ±(f)(e)(œà) := f({(e,œà)})
``````````````````````````````````````````````````

The injection `œÇ‚∏¢CM‚∏£‚ÇÄ` for a program `e‚ÇÄ` is:
`````indent```````````````````````````````````````
œÇ‚ÇÄ := {‚ü®e,‚ä•,‚ä•,‚àô,‚ä•,‚àô‚ü©}
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`Œ≥` and `Œ±` form an isomorphism.
`\end{proposition}`{.raw}

`\begin{corollary}`{.raw}
`Œ≥` and `Œ±` form a Galois connection.
``\end{corollary}`{.raw}`{.raw}

## Recovering an Abstract Interpreter

We pick a simple abstraction for integers, `{[-],0,[+]}`, although our technique scales seamlessly to other domains.
`````indent```````````````````````````````````````
AVal := ùí´(Clo + {[-],0,[+]})
``````````````````````````````````````````````````

Introduction and elimination functions for `AVal` are defined:
`````indent```````````````````````````````````````
int-I : ‚Ñ§ ‚Üí AVal
int-I(i) := [-] if i < 0
int-I(i) := 0   if i = 0
int-I(i) := [+] if i > 0
int-if0-E : AVal ‚Üí ùí´(Bool)
int-if0-E(v) := { true | 0 ‚àà v } ‚à™ { false | [-] ‚àà v ‚à® [+] ‚àà v }
``````````````````````````````````````````````````
Introduction and elmination for `Clo` is identical to the concrete domain.

The abstract `Œ¥` operator is defined:
`````indent```````````````````````````````````````
Œ¥ : IOp √ó AVal √ó AVal ‚Üí AVal 
Œ¥(+,v‚ÇÅ,v‚ÇÇ) := 
    { i     | 0 ‚àà v‚ÇÅ ‚àß i ‚àà v‚ÇÇ }
  ‚à™ { i     | i ‚àà v‚ÇÅ ‚àß 0 ‚àà v‚ÇÇ }
  ‚à™ { [+]     | [+] ‚àà v‚ÇÅ ‚àß [+] ‚àà v‚ÇÇ } 
  ‚à™ { [-]     | [-] ‚àà v‚ÇÅ ‚àß [-] ‚àà v‚ÇÇ } 
  ‚à™ { [-],0,[+] | [+] ‚àà v‚ÇÅ ‚àß [-] ‚àà v‚ÇÇ }
  ‚à™ { [-],0,[+] | [-] ‚àà v‚ÇÅ ‚àß [+] ‚àà v‚ÇÇ }
``````````````````````````````````````````````````
The definition for `Œ¥(-,v‚ÇÅ,v‚ÇÇ)` is analagous.

`\begin{proposition}`{.raw}
`AVal` satisfies the abstract domain laws from section [X][The Abstract Domain].
`\end{proposition}`{.raw}

`\begin{proposition}`{.raw}
`CVal Œ±‚áÑŒ≥ AVal` and their operations `int-I`, `int-if0-E` and `Œ¥` are ordered `‚äë` respectively through the Galois connection.
`\end{proposition}`{.raw}

Next we abstract `Time` to `ATime` as the finite domain of k-truncated lists of execution contexts:
`````indent```````````````````````````````````````
ATime := (Exp √ó KAddr)‚ãÜ‚Çñ
``````````````````````````````````````````````````
The `tick` operator becomes cons followed by k-truncation:
`````indent```````````````````````````````````````
tick : Exp √ó KAddr √ó ATime ‚Üí ATime
tick(e,Œ∫l,œÑ) = ‚åä(e,Œ∫l)‚à∑œÑ‚åã‚Çñ
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CTime Œ±‚áÑŒ≥ ATime` and `tick` is ordered `‚äë` through the Galois connection.
`\end{proposition}`{.raw}

The monad `AM` need not change in implementation from `CM`; they are identical up to choices for `AStore` (which maps to `AVal`) and `ATime`.
`````indent```````````````````````````````````````
œà ‚àà Œ® := Env √ó AStore √ó KAddr √ó KStore √ó ATime
``````````````````````````````````````````````````

The resulting state space `AŒ£` is finite, and its least-fixed-point iteration will give a sound and computable analysis.

# Varying Path and Flow Sensitivity

We are able to recover a flow-insensitivity in the analysis through a new definition for `AM`: `AM·∂†‚Å±`.
To do this we pull `AStore` out of the powerset, exploiting its join-semilattice structure:
`````indent```````````````````````````````````````
Œ® := Env √ó KAddr √ó KStore √ó ATime
AM·∂†‚Å±(Œ±) := Œ® √ó AStore ‚Üí ùí´(Œ± √ó Œ®) √ó AStore
``````````````````````````````````````````````````

The monad operator `bind` performs the store merging needed to capture a flow-insensitive analysis.
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, AM·∂†‚Å±(Œ±) ‚Üí (Œ± ‚Üí AM·∂†‚Å±(Œ≤)) ‚Üí AM·∂†‚Å±(Œ≤)
bind(m)(f)(œà,œÉ) := ({bs‚ÇÅ‚ÇÅ .. bs‚Çô‚ÇÅ .. bs‚Çô‚Çò},œÉ‚ÇÅ ‚äî .. ‚äî œÉ‚Çô)
  where
    ({(a‚ÇÅ,œà‚ÇÅ) .. (a‚Çô,œà‚Çô)},œÉ') := m(œà,œÉ)
    ({bœà·µ¢‚ÇÅ .. bœà·µ¢‚Çò},œÉ·µ¢) := f(a·µ¢)(œà·µ¢,œÉ')
``````````````````````````````````````````````````
The unit for `bind` returns one nondeterminism branch and a single store:
`````indent```````````````````````````````````````
return : ‚àÄ Œ±, Œ± ‚Üí AM(Œ±)
return(a)(œà,œÉ) := ({a,œà},œÉ)
``````````````````````````````````````````````````

State effects `get-Env` and `put-Env` are also straightforward, returning one branch of nondeterminism:
`````indent```````````````````````````````````````
get-Env : AM·∂†‚Å±(Env)
get-Env(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(œÅ,‚ü®œÅ,Œ∫,œÑ‚ü©)},œÉ)
put-Env : Env ‚Üí AM·∂†‚Å±(1)
put-Env(œÅ')(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(1,‚ü®œÅ',Œ∫,œÑ‚ü©)},œÉ)
``````````````````````````````````````````````````

State effects `get-Store` and `put-Store` are analagous to `get-Env` and `put-Env`:
`````indent```````````````````````````````````````
get-Store : AM·∂†‚Å±(Env)
get-Store(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(œÉ,‚ü®œÅ,Œ∫,œÑ‚ü©},œÉ)
put-Store : AStore ‚Üí AM·∂†‚Å±(1)
put-Store(œÉ')(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(1,‚ü®œÅ,Œ∫,œÑ‚ü©)},œÉ')
``````````````````````````````````````````````````

Nondeterminism operations will union the powerset and join the store pairwise:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, M(Œ±)
mzero(œà,œÉ) := ({}, ‚ä•)
_‚ü®+‚ü©_ : ‚àÄ Œ±, M(Œ±) √ó M(Œ±) ‚Üí M Œ± 
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(œà,œÉ) := (aœà*‚ÇÅ ‚à™ aœà*‚ÇÇ,œÉ‚ÇÅ ‚äî œÉ‚ÇÇ)
  where (aœà*·µ¢,œÉ·µ¢) := m·µ¢(œà,œÉ)
``````````````````````````````````````````````````

Finally, the Galois connection relating `AM·∂†‚Å±` to a state space transition over `AŒ£·∂†‚Å±` must also compute set unions and store joins:
`````indent```````````````````````````````````````
AŒ£·∂†‚Å± := ùí´(Exp √ó Œ®) √ó AStore
Œ≥ : (Exp ‚Üí AM·∂†‚Å±(Exp)) ‚Üí (Œ£·∂†‚Å± ‚Üí Œ£·∂†‚Å±)
Œ≥(f)(eœà*,œÉ) := ({eœà‚ÇÅ‚ÇÅ .. eœà‚Çô‚ÇÅ .. eœà‚Çô‚Çò}, œÉ‚ÇÅ ‚äî .. ‚äî œÉ‚Çô)
  where 
    {(e‚ÇÅ,œà‚ÇÅ) .. (e‚Çô,œà‚Çô)} := eœà*
    ({eœà·µ¢‚ÇÅ .. eœà·µ¢‚Çò},œÉ·µ¢) := f(e·µ¢)(œà·µ¢,œÉ)
Œ±  : (Œ£·∂†‚Å± ‚Üí Œ£·∂†‚Å±) ‚Üí (Exp ‚Üí AM·∂†‚Å±(Exp))
Œ±(f)(e)(œà,œÉ) := f({(e,œà)},œÉ)
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`Œ≥` and `Œ±` form an isomorphism.
`\end{proposition}`{.raw}

`\begin{corollary}`{.raw}
`Œ≥` and `Œ±` form a Galois connection.
`\end{corollary}`{.raw}

`\begin{proposition}`{.raw}
There exists Galois connection `CŒ£ Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ AŒ£ Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ AŒ£·∂†‚Å±` and `Œ±‚ÇÅ ‚àò CŒ≥(step) ‚àò Œ≥‚ÇÅ ‚äë AŒ≥(step) ‚äë Œ≥‚ÇÇ ‚àò AŒ≥·∂†‚Å±(step) ‚àò Œ±‚ÇÇ`.
`\end{proposition}`{.raw}

The first Galois connection `CŒ£ Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ AŒ£` is justified by the Galois connections between `CVal Œ±‚áÑŒ≥ AVal` and `CTime Œ±‚áÑŒ≥ ATime`.
The second Galois connection `AŒ£ Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ AŒ£·∂†‚Å±` is justified by first calculating the Galois connection between monads `AM` and `CM`,
  and then transporting it through their respective Galois connections to `AŒ£` and `AŒ£·∂†‚Å±`.
These proofs are tedious calculations over the definitions which we do not repeat here.
However, we will recover these proof in a later section through our compositional framework which greatly reduces the proof burden.

We note that the implementation for our interpreter and abstract garbage collector remain the same.
They both scale seamlessly to flow-sensitive and flow-insensitive variants when instantiated with the appropriate monad.

# A Compositional Monadic Framework

In our development thus far, any modification to the interpreter requires redesigning the monad `AM` and constructing new proofs.
We want to avoid reconstructing complicated monads for our interpreters, especially as languages and analyses grow and change.
Even more, we want to avoid reconstructing complicated _proofs_ that such changes will necessarily alter.
Toward this goal we introduce a compositional framework for constructing monads which are correct-by-construction.
To do this we build upon the well-known structure of monad transformer.

There are two types of monadic effects used in our monadic interprer: state and nondeterminism.
Each of these effects have corresponding monad transformers.
Monad transformers for state effects were described by Jones in [CITE].
Our definition of a monad transformer for nondeterminism is novel in this work.

## State Monad Transformer

Briefly we review the state monad transformer, `S‚Çú[s]`:
`````indent```````````````````````````````````````
S‚Çú[_] : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
S‚Çú[s](m)(Œ±) := s ‚Üí m(Œ± √ó s)
``````````````````````````````````````````````````

For monad transformers, `bind` and `return` will use monad operations from the underlying `m`, which we notate `bind‚Çò` and `return‚Çò`.
When writing in do-notation, we write `do‚Çò` and `‚Üê‚Çò` for clarity.

The state monad transformer can transport monadic operations from `m` to `S‚Çú[s](m)`:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, S‚Çú[s](m)(Œ±) ‚Üí (Œ± ‚Üí S‚Çú[s](m)(Œ≤)) ‚Üí S‚Çú[s](m)(Œ≤)
bind(m)(f)(s) := do‚Çò
  (x,s') ‚Üê‚Çò m(s)
  f(x)(s')
return : ‚àÄ Œ± m, Œ± ‚Üí S‚Çú[s](m)(Œ±)
return(x)(s) := return‚Çò(x,s)
``````````````````````````````````````````````````

The state monad transformer can also transport nondeterminism effects from `m` to `S‚Çú[s](m)`:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, S‚Çú[s](m)(Œ±)
mzero(s) := mzero‚Çò 
_‚ü®+‚ü©_ : ‚àÄ Œ±, S‚Çú[s](m)(Œ±) x S‚Çú[s](m)(Œ±) ‚Üí S‚Çú[s](m)(Œ±)
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(s) := m‚ÇÅ(s) ‚ü®+‚ü©‚Çò m‚ÇÇ(s) 
``````````````````````````````````````````````````

Finally, the state monad transformer exposes `get` and `put` operations given that `m` is a monad:
`````indent```````````````````````````````````````
get : S‚Çú[s](m)(s)
get(s) := return‚Çò(s,s)
put : s ‚Üí S‚Çú[s](m)(1)
put(s')(s) := return‚Çò(1,s')
``````````````````````````````````````````````````

## Nondeterminism Monad Transformer

We have developed a new monad transformer for nondeterminism which can compose with state in both directions.
Previous attempts to define a monad transformer for nondeterminism have resulted in monad operations which do not respect monad laws.

Our nondeterminism monad transformer shares the "expected" type, embedding `ùí´` inside `m`:
`````indent```````````````````````````````````````
ùí´‚Çú : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
ùí´‚Çú(m)(Œ±) := m(ùí´(Œ±))
``````````````````````````````````````````````````

The nondeterminism monad transformer can transport monadic operations from `m` to `ùí´‚Çú` _provided that `m` is also a join-semilattice functor_:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, ùí´‚Çú(m)(Œ±) ‚Üí (Œ± ‚Üí ùí´‚Çú(m)(Œ≤)) ‚Üí ùí´‚Çú(m)(Œ≤)
bind(m)(f) := do‚Çò
  {x‚ÇÅ .. x‚Çô} ‚Üê‚Çò m
  f(x‚ÇÅ) ‚äî‚Çò .. ‚äî‚Çò f(x‚Çô)
return : ‚àÄ Œ±, Œ± ‚Üí ùí´‚Çú(m)(Œ±)
return(x) := return‚Çò({x})
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`bind` and `return` satisfy the monad laws.
`\end{proposition}`{.raw}

The key lemma in this proof is the functorality of `m`, namely that:
`````align````````````````````````````````````````
return‚Çò(x ‚äî y) = return‚Çò(x) ‚äî return‚Çò(y)
``````````````````````````````````````````````````

The nondeterminism monad transformer can transport state effects from `m` to `ùí´‚Çú`:
`````indent```````````````````````````````````````
get : ùí´‚Çú(m)(s)
get = map‚Çò(Œª(s).{s})(get‚Çò)
put : s ‚Üí ùí´‚Çú(m)(s)
put(s) = map‚Çò(Œª(1).{1})(put‚Çò(s))
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`get` and `put` satisfy the state monad laws.
`\end{proposition}`{.raw}

The proof is by simpl calculation.

Finally, our nondeterminism monad transformer expses nondeterminism effects as a trivial applciation of the underlying monad's join-semilattice functorality:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, ùí´‚Çú(m)(Œ±)
mzero := ‚ä•·µê
_‚ü®+‚ü©_ : ‚àÄ Œ±, ùí´‚Çú(m)(Œ±) x ùí´‚Çú(m)(Œ±) ‚Üí ùí´‚Çú(m)(Œ±)
m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ := m‚ÇÅ ‚äî‚Çò m‚ÇÇ
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`mzero` and `‚ü®+‚ü©` satisfy the nondterminism monad laws.
`\end{proposition}`{.raw}

The proof is trivial as a consequence of the underlying monad being a join-semilattice functor.

## Mapping to State Spaces

Both our execution and correctness frameworks requires that monadic actions in `M` map to some state space transitions `Œ£`.
We extend the earlier statement of Galois connection to the transformer setting:
`````indent```````````````````````````````````````
mstep : ‚àÄ Œ± Œ≤, (Œ± ‚Üí M(Œ≤)) Œ±‚áÑŒ≥ (Œ£(Œ±) ‚Üí Œ£(Œ≤))
``````````````````````````````````````````````````
Here `M` must map _arbitrary_ monadic actions `Œ± ‚Üí M(Œ≤)` to state space transitions for a state space _functor_ `Œ£(_)`
We only show the `Œ≥` sides of the mappings in this section, which allow one to execute the analyses.

For the state monad transformer `S‚Çú[s]` mstep is defined:
`````indent```````````````````````````````````````
mstep-Œ≥ : ‚àÄ Œ± Œ≤ m, (Œ± ‚Üí S‚Çú[s](m)(Œ≤)) ‚Üí (Œ£‚Çò(Œ± √ó s) ‚Üí Œ£‚Çò(Œ≤ √ó s))
mstep-Œ≥(f) := mstep‚Çò-Œ≥(Œª(a,s). f(a)(s))
``````````````````````````````````````````````````

For the nondeterminism transformer `ùí´‚Çú`, mstep has two possible definitions.
One where `Œ£` is `Œ£·µê ‚àò ùí´`:
`````indent```````````````````````````````````````
mstep‚ÇÅ-Œ≥ : ‚àÄ Œ± Œ≤ m, (Œ± ‚Üí ùí´‚Çú(m)(Œ≤)) ‚Üí (Œ£‚Çò(ùí´(Œ±)) ‚Üí Œ£‚Çò(ùí´(Œ≤)))
mstep‚ÇÅ-Œ≥(f) := mstep‚Çò-Œ≥(Œª({x‚ÇÅ .. x‚Çô}). f(x‚ÇÅ) ‚ü®+‚ü© .. ‚ü®+‚ü© f(x‚Çô))
``````````````````````````````````````````````````
and one where `Œ£` is `ùí´ ‚àò Œ£·µê`:
`````indent```````````````````````````````````````
mstep‚ÇÇ-Œ≥ : ‚àÄ Œ± Œ≤ m, (Œ± ‚Üí ùí´‚Çú(m)(Œ≤)) ‚Üí (ùí´(Œ£‚Çò(Œ±)) ‚Üí ùí´(Œ£‚Çò(Œ≤)))
mstep‚ÇÇ-Œ≥(f)({œÇ‚ÇÅ .. œÇ‚Çô}) := aŒ£P‚ÇÅ ‚à™ .. ‚à™ aŒ£P‚Çô
  where 
    commuteP-Œ≥ : ‚àÄ Œ±, Œ£‚Çò(ùí´(Œ±)) ‚Üí ùí´(Œ£‚Çò(Œ±))
    aŒ£P·µ¢ := commuteP-Œ≥(mstep‚Çò-Œ≥(f)(œÇ·µ¢)) 
``````````````````````````````````````````````````
The operation `computeP-Œ≥` must be defined for the underlying `Œ£·µê`.
In general, `commuteP` must form a Galois connection.
However, this property exists for the identity monad, and is preserverd by `S‚Çú[s]`, the only monad we will compose `ùí´‚Çú` with in this work.
`````indent```````````````````````````````````````
commuteP-Œ≥ : ‚àÄ Œ±, Œ£‚Çò(ùí´(Œ±) √ó s) ‚Üí ùí´(Œ£‚Çò(Œ± √ó s))
commuteP-Œ≥ := commuteP‚Çò ‚àò map(Œª({Œ±‚ÇÅ .. Œ±‚Çô},s). {(Œ±‚ÇÅ,s) .. (Œ±‚Çô,s)})
``````````````````````````````````````````````````
Of all the `Œ≥` mappings defined, the `Œ≥` side of `commuteP` is the only mapping that loses information in the `Œ±` direction.
Therefore, `mstep‚∏§S‚Çú[s]‚∏•` and `mstep‚∏§ùí´‚Çú1‚∏•` are really isomorphism transformers, and `mstep‚∏§ùí´‚Çú2‚∏•` is the only Galois connection transformer.
The Galois connections for `mstep` for both `S‚Çú[s]` or `P‚Çú` rely crucially on `mstep‚Çò-Œ≥` and `mstep‚Çò-Œ±` to be functorial (i.e., homomorphic).

For convenience, we name the pairing of `ùí´‚Çú` with `mstep‚ÇÅ` `FI‚Çú`, and with `mstep‚ÇÇ` `FS‚Çú` for flow insensitive and flow sensitive respectively.

`\begin{proposition}`{.raw}
`Œ£‚∏§FS‚Çú‚∏• Œ±‚áÑŒ≥ Œ£‚∏§FI‚Çú‚∏•`.
`\end{proposition}`{.raw}

The proof is by consequence of `commuteP`.

`\begin{proposition}`{.raw}
`S‚Çú[s] ‚àò ùí´‚Çú Œ±‚áÑŒ≥ ùí´‚Çú ‚àò S‚Çú[s]`.
`\end{proposition}`{.raw}

We can now build monad transformer stacks from combinations of `S‚Çú[s]`, `FI‚Çú` and `FS‚Çú` that have the following properties:

- The resulting monad has the combined effects of all pieces of the transformer stack.
- Actions in the resulting monad map to a state space transition system `Œ£ ‚Üí Œ£` for some `Œ£`.
-- - Galois connections between states `s‚ÇÅ` and `s‚ÇÇ` are transported along the Galois connection between 
--   `(Œ± ‚Üí S‚Çú[s‚ÇÅ](m)(Œ≤)) Œ±‚áÑŒ≥ (Œ£[s‚ÇÅ](Œ±) ‚Üí Œ£[s‚ÇÅ](Œ≤))` and `(Œ± ‚Üí S‚Çú[s‚ÇÇ](m)(Œ≤)) Œ±‚áÑŒ≥ (Œ£[s‚ÇÇ](Œ±) ‚Üí Œ£[s‚ÇÇ](Œ≤))`
--   resulting in `(Œ£[s‚ÇÅ](Œ±) ‚Üí Œ£[s‚ÇÅ](Œ≤)) Œ±‚áÑŒ≤ (Œ£[s‚ÇÇ](Œ±) ‚Üí Œ£[s‚ÇÇ](Œ≤))`.

We can now instantiate our interpreter to the following monad stacks in decreasing order of precision:
`````align````````````````````````````````````````
S‚Çú[Env] ‚àò S‚Çú[KAddr] ‚àò S‚Çú[KStore] ‚àò S‚Çú[ATime] ‚àò S‚Çú[AStore] ‚àò FS‚Çú
``````````````````````````````````````````````````
which yields a path-sensitive flow-sensitive analysis,
`````align````````````````````````````````````````
S‚Çú[Env] ‚àò S‚Çú[KAddr] ‚àò S‚Çú[KStore] ‚àò S‚Çú[ATime] ‚àò FS‚Çú ‚àò S‚Çú[AStore]
``````````````````````````````````````````````````
which yeilds a path-insensitive flow-sensitive analysis, and
`````align````````````````````````````````````````
S‚Çú[Env] ‚àò S‚Çú[KAddr] ‚àò S‚Çú[KStore] ‚àò S‚Çú[ATime] ‚àò FI‚Çú ‚àò S‚Çú[AStore]
``````````````````````````````````````````````````
which yields a path-insensitive flow-insensitive analysis.
Furthermore, the Galois connections for our interpreter instantiated to each state space `Œ£` is justified fully by construction.


# Implementation

We have implemented our framework in Haskell and applied it to compute analyses for `ŒªIF`.
Our implementation provides path sensitivity, flow sensitivity, and flow insensitivity as a semantics-independent monad library.
The code shares a striking resemblance with the math.

Our interpreter for `ŒªIF` is paramaterized as discussed in Section [4][Analysis Parameters].
We express a valid analysis with the following Haskell constraint:
`````indent```````````````````````````````````````
type Analysis(Œ¥,Œº,m) ‚à∑ Constraint = 
  (AAM(Œº),Delta(Œ¥),AnalysisMonad(Œ¥,Œº,m))
``````````````````````````````````````````````````
Constraints `AAM(Œº)` and `Delta(Œ¥)` are interfaces for abstract time and the abstract domain.
The constraint `AnalysisMonad(m)` requires only that `m` has the required effects[^1]:
`````indent```````````````````````````````````````
type AnalysisMonad(Œ¥,Œº,m) ‚à∑ Constraint = (
   Monad(m(Œ¥,Œº)), 
   MonadNondeterminism(m(Œ¥,Œº)),
   MonadState(Env(Œº))(m(Œ¥,Œº)),
   MonadState(Store(Œ¥,Œº))(m(Œ¥,Œº)),
   MonadState(Time(Œº,Call))(m(Œ¥,Œº)))
``````````````````````````````````````````````````
Our interpreter is implemented against this interface and concrete and abstract interpreters are recovered by instantiating `Œ¥`, `Œº` and `m`.

[^1]: 
    We use a CPS representation and a single store in our implementation.
    This requires `Time`, which is generic to the language, to take `Call` as a paramter rather than `Exp √ó KAddr`.

Our implementation is publically available and can be installed as a cabal package by executing:
`````align````````````````````````````````````````
cabal install maam
``````````````````````````````````````````````````

# Related Work

The most directly related work is the development of Monadic Abstract Interpreters (MAI) by \citet{davdar:Sergey:2013:Monalysis}.
In MAI, interpreters are also written in monadic style and variations in analysis are recovered through new monad implementations.
However, each monad in MAI is designed from scratch for a specific language to have specific analysis properties.
Our work extends the ideas in MAI in a way that isolates each parameter to be independent of others.
We factor out the monad as a truly semantics independent feature.
This factorization reveals an orthogonal tuning knob for path and flow sensitivity
Even more, we give the user building blocks for constructing monads that are correct and give the desired properties by construction.
Our framework is also motivated by the needs of reasoning formally about abstract interpreters, no mention of which is made in MAI.

We build directly on the work of Abstracting Abstract Machines (AAM) by \citet{davdar:van-horn:2010:aam}
  in our parameterization of abstract time and call-site sensitivity.
More notably, we follow the AAM philosophy of instrumenting a concrete semantics _first_ and performing a systematic abstraction _second_.
This greatly simplifies the Galois connection arguments during systematic abstraction.
However, this is at the cost of proving that the instrumented semantics simulate the original concrete semantics.

# Conclusion
