# Introduction

Traditional practice in program analysis via abstract interpretation is to fix
a language (as a concrete semantics) and an abstraction (as an abstraction map,
concretization map or Galois connection) before constructing a static analyzer
that it sound with respect to both the abstraction and the concrete semantics.
Thus, each pairing of abstraction and semantics requires a one-off manual
derivation of the abstract semantics and a construction of a proof of
soundness.

Work has focused on endowing abstractions with knobs, levers, and dials to tune
precision and compute efficiently.  These parameters come with overloaded
meanings such as object, context, path, and heap sensitivities, or some
combination thereof.  These efforts develop families of analyses _for a
specific language_ and prove the framework sound.

But this framework approach suffers from many of the same drawbacks as the
one-off analyzers.  They are language-specific, preventing reuse of concepts
across languages and require similar re-implementations and soundness proofs.
This process is still manual, tedious, difficult and error-prone. And, changes
to the structure of the parameter-space require a completely new proof of
soundness.  And, it prevents fruitful insights and results developed in one
paradigm from being applied to others, e.g., functional to object-oriented and
_vice versa_.

We propose an automated alternative approach to structuring and implementing
program analysis.  Inspired by \citeauthor*{dvanhorn:Liang1995Monad}'s
\emph{Monad transformers for modular interpreters}
\citeyearpar{dvanhorn:Liang1995Monad}, we propose to start with concrete
interpreters in a specific monadic style. Changing the monad will change the
interpreter from a concrete interpreter into an abstract interpreter. As we
show, classical program abstractions can be embodied as language-independent
monads.  Moreover, these abstractions can be written as monad _transformers_,
thereby allowing their composition to achieve new forms of analysis.  We show
that these monad transformers obey the properties of \emph{Galois connections}
\cite{dvanhorn:Cousot1979Systematic} and introduce the concept of a
\emph{Galois transformer}, a monad transformer which transports Galois
connections.

Most significantly, Galois transformers can be proved sound once and used
everywhere.  Abstract interpreters, which take the form of monad transformer
stacks coupled together with a monadic interpreter, inherit the soundness
properties of each element in the stack.  This approach enables reuse of
abstractions across languages and lays the foundation for a modular metatheory
of program analysis.

Using Galois transformers, we enable arbitrary composition of analysis
parameters. For example, our implementation--called `maam`--supports
command-line flags for garbage collection, k-CFA, and path  and
flow sensitivity.
``````````````````````````````````````````````````
./maam --gc --CFA=0 --flow-sen prog.lam
``````````````````````````````````````````````````
These flags are implemented independently of one another and are applied to a
single parameterized monadic interpreter. Furthermore, using Galois
transformers allows us to prove each combination correct in one fell swoop.

\paragraph{Setup}
We describe a simple language and a garbage-collecting allocating semantics as
the starting point of analysis design (Section \ref{semantics}). We then
briefly discuss three types of flow  and path sensitivities and their
corresponding variations in analysis precision (Section
\ref{flow-properties-in-analysis}).

\paragraph{Monadic Abstract Interpreters}
We develop an abstract interpreter for our example language as a monadic
function with various parameters (Section \ref{analysis-parameters}), one of
which is a monadic effect interface combining state and nondeterminism effects
(Section \ref{the-analysis-monad}). Interpreters written in this style can be
reasoned about using laws that must hold for each of these interfaces.
Likewise, instantiations for these parameters can be reasoned about in
isolation from their instantiation. When instantiated, our generic interpreter
is capable of recovering the concrete semantics and a family of abstract
interpreters, with variations in abstract domain, call-site sensitivity, and
flow  and path sensitivity (Section \ref{recovering-analyses}).

\paragraph{Isolating Path  and Flow Sensitivity}
We give specific monads for instantiating the interpreter from Section
\ref{the-interpreter} which give rise to path-sensitive and flow-insensitive
analyses (Section \ref{varying-path-and-flow-sensitivity}). This leads to an
isolated understanding of path  and flow sensitivity as mere variations in the
monad used for execution. Furthermore, these monads are language independent,
allowing one to reuse the same path  and flow sensitivity machinery for any
language of interest.

\paragraph{Galois Transformers}
To ease the construction of monads for building abstract interpreters and their
proofs of correctness, we develop a framework of Galois transformers (Section
\ref{a-compositional-monadic-framework}). Galois transformers are an extension
of monad transformers which transport Galois connections in addition to monadic
operations. Our Galois transformer framework allows us to reason about the
correctness of an abstract interpreter piecewise for each transformer in a
stack. Galois transformers are language independent and they can be proven
correct one and for all in isolation from a particular semantics.

\paragraph{Implementation}
We implement our technique in Haskell and briefly discuss how the parameters
from Section \ref{analysis-parameters} translate into code (Section
\ref{implementation-1}). Our implementation is publicly available on
Hackage\footnote{http://hackage.haskell.org/package/maam}, Haskell's package
manager.


\paragraph{Contributions}
We make the following contributions:

- A framework for building abstract interpreters using monad transformers.
- A framework for constructing Galois connections using _Galois
  transformers_, an extension of monad transformers which also transport Galois
  connections.
- A new monad transformer for nondeterminism which we show is also a Galois
  transformer.
- An isolated understanding of flow  and path sensitivity for static analysis
  as a property of the interpreter monad.

# Semantics

To demonstrate our framework we design an abstract interpreter for `ŒªIF`, a
simple applied lambda calculus shown in Figure`~\ref{SS}`{.raw}. `ŒªIF` extends
traditional lambda calculus with integers, addition, subtraction and
conditionals. We use the operator `[@]` as explicit abstract syntax for
function application.

`\begin{figure}`{.raw}
\vspace{-1em}
`````align````````````````````````````````````````
 i ‚àà  ‚Ñ§       x ‚àà Var
 a ‚àà  Atom    ::= i | x | [Œª](x).e
 ‚äï ‚àà  IOp     ::= [+] | [-]
 ‚äô ‚àà  Op      ::= ‚äï | [@]
 e ‚àà  Exp     ::= a | e ‚äô e | [if0](e){e}{e}
<>
 œÑ ‚àà  Time    := ‚Ñ§
 l ‚àà  Addr    := Var √ó Time
 œÅ ‚àà  Env     := Var ‚áÄ Addr
 œÉ ‚àà  Store   := Addr ‚áÄ Val
 c ‚àà  Clo     ::= ‚ü®[Œª](x).e,œÅ‚ü© 
 v ‚àà  Val     ::= i | c
Œ∫l ‚àà  KAddr   := Time
Œ∫œÉ ‚àà  KStore  := KAddr ‚áÄ Frame √ó KAddr
fr ‚àà  Frame   ::= ‚ü®‚ñ° ‚äô e‚ü© | ‚ü®v ‚äô ‚ñ°‚ü© | ‚ü®[if0](‚ñ°){e}{e}‚ü©
 œÇ ‚àà  Œ£       ::= Exp √ó Env √ó Store √ó KAddr √ó KStore
``````````````````````````````````````````````````
`\caption{`{.raw} `ŒªIF` Syntax and Concrete State Space `}`{.raw}
\label{SS} 
\vspace{-1em}
`\end{figure}`{.raw}

Before designing an abstract interpreter we first specify a formal semantics
for `ŒªIF`. Our semantics makes allocation explicit using two separate stores
for values (`Store`) and the control stack (`KStore`). We will recover these
semantics from our generic abstract interpreter in Section
\ref{recovering-analyses}.

We give semantics to atomic expressions and primitive operators denotationally
through `A‚ü¶_‚üß` and `Œ¥‚ü¶_‚üß` respectively as shown in
Figure`~\ref{ConcreteDenotationFunctions}`{.raw}; and to compound expressions
relationally as shown in Figure`~\ref{ConcreteStepRelation}`{.raw}.

`\begin{figure}`{.raw}
\vspace{-1em}
`````indent```````````````````````````````````````
A‚ü¶_‚üß ‚àà Atom ‚Üí (Env √ó Store ‚áÄ Val)
A‚ü¶i‚üß(œÅ,œÉ) := i
A‚ü¶x‚üß(œÅ,œÉ) := œÉ(œÅ(x))
A‚ü¶[Œª](x).e‚üß(œÅ,œÉ) := ‚ü®[Œª](x).e,œÅ‚ü© 
<>
Œ¥‚ü¶_‚üß ‚àà IOp ‚Üí (‚Ñ§ √ó ‚Ñ§ ‚Üí ‚Ñ§)
Œ¥‚ü¶[+]‚üß(i‚ÇÅ,i‚ÇÇ) := i‚ÇÅ + i‚ÇÇ
Œ¥‚ü¶[-]‚üß(i‚ÇÅ,i‚ÇÇ) := i‚ÇÅ - i‚ÇÇ
``````````````````````````````````````````````````
\caption{Concrete Denotation Functions}
\label{ConcreteDenotationFunctions} 
\vspace{-1em}
`\end{figure}`{.raw}

`\begin{figure}`{.raw}
\vspace{-1em}
`````indent```````````````````````````````````````
_[~~>]_ ‚àà ùí´(Œ£ √ó Œ£)
‚ü®e‚ÇÅ ‚äô e‚ÇÇ,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e‚ÇÅ,œÅ,œÉ,œÑ,Œ∫œÉ',œÑ+1‚ü©
  where Œ∫œÉ' := Œ∫œÉ[œÑ ‚Ü¶ (‚ü®‚ñ° ‚äô e‚ÇÇ‚ü©,Œ∫l)]
‚ü®a,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ,œÉ,œÑ,Œ∫œÉ',œÑ+1‚ü©
  where 
    (‚ü®‚ñ° ‚äô e‚ü©,Œ∫l') := Œ∫œÉ(Œ∫l)
    Œ∫œÉ' := Œ∫œÉ[œÑ ‚Ü¶ (‚ü®A‚ü¶a‚üß(œÅ,œÉ) ‚äô ‚ñ°‚ü©,Œ∫l')]
‚ü®a,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ'',œÉ',Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    (‚ü®‚ü®[Œª](x).e,œÅ'‚ü© [@] ‚ñ°‚ü©,Œ∫l') := Œ∫œÉ(Œ∫l)
    œÅ'' := œÅ'[x ‚Ü¶ (x,œÑ)]
    œÉ' := œÉ[(x,œÑ) ‚Ü¶ A‚ü¶a‚üß(œÅ,œÉ)]
‚ü®i‚ÇÇ,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®i,œÅ,œÉ,Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    (‚ü®i‚ÇÅ ‚äï ‚ñ°‚ü©,Œ∫l') := Œ∫œÉ(Œ∫l)
    i := Œ¥‚ü¶‚äï‚üß(i‚ÇÅ,i‚ÇÇ)
‚ü®i,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~> ‚ü®e,œÅ,œÉ,Œ∫l',Œ∫œÉ,œÑ+1‚ü©
  where 
    (‚ü®[if0](‚ñ°){e‚ÇÅ}{e‚ÇÇ}‚ü©,Œ∫l') := Œ∫œÉ(Œ∫l)
    e := e‚ÇÅ when i = 0
    e := e‚ÇÇ when i ‚â† 0
``````````````````````````````````````````````````
\caption{Concrete Step Relation}
\label{ConcreteStepRelation} 
\vspace{-1em}
`\end{figure}`{.raw}

Our abstract interpreter will support abstract garbage
collection`~\cite{dvanhorn:Might:2006:GammaCFA}`{.raw}, the concrete analogue
of which is just standard garbage collection. We include abstract garbage
collection for two reasons. First, it is one of the few techniques that results
in both performance _and_ precision improvements for abstract interpreters.
Second, later we will systematically recover both concrete and abstract garbage
collectors through a single monadic garbage collector.

Garbage collection is defined using a reachability function `R` which computes
the transitively reachable address from `(œÅ,e)` in `œÉ`:
`````indent```````````````````````````````````````
R ‚àà Store √ó Env √ó Exp ‚Üí ùí´(Addr)
R(œÉ,œÅ,e) := Œº(X). 
  X ‚à™ R‚ÇÄ(œÅ,e) ‚à™ {l' | l' ‚àà R-Val(œÉ(l)) ; l ‚àà X}
``````````````````````````````````````````````````
We write `Œº(X). f(X)` as the least-fixed-point of a function `f`. This
definition uses two helper functions: `R‚ÇÄ` for computing the initial reachable
set and `R-Val` for computing addresses reachable from values.
`````indent```````````````````````````````````````
R‚ÇÄ ‚àà Env √ó Exp ‚Üí ùí´(Addr)
R‚ÇÄ(œÅ,e) := {œÅ(x) | x ‚àà FV(e)}
<>
R-Val ‚àà Val ‚Üí ùí´(Addr)
R-Val(i) := {}
R-Val(‚ü®[Œª](x).e,œÅ‚ü©) := {œÅ(y) | y ‚àà FV([Œª](x).e)}
``````````````````````````````````````````````````
We omit the definition of `FV`, which is the standard recursive definition for
computing free variables of an expression.

Analogously, `KR` is the set of transitively reachable continuation addresses
in `Œ∫œÉ`:
`````indent```````````````````````````````````````
KR ‚àà KStore √ó KAddr ‚Üí ùí´(KAddr)
KR(Œ∫œÉ,Œ∫l‚ÇÄ) := Œº(X). X ‚à™ {Œ∫l‚ÇÄ} ‚à™ {œÄ‚ÇÇ(Œ∫œÉ(Œ∫l)) | Œ∫l ‚àà X}
``````````````````````````````````````````````````

Our final semantics is given via the step relation `_[~~>‚∏¢gc‚∏£]_` which
nondeterministically either takes a semantic step or performs garbage
collection.
`````indent```````````````````````````````````````
_[~~>‚∏¢gc‚∏£]_ ‚àà ùí´(Œ£ √ó Œ£)
œÇ ~~>‚∏¢gc‚∏£ œÇ' 
  where œÇ ~~> œÇ'
‚ü®e,œÅ,œÉ,Œ∫l,Œ∫œÉ,œÑ‚ü© ~~>‚∏¢gc‚∏£ ‚ü®e,œÅ,œÉ',Œ∫l,Œ∫œÉ',œÑ‚ü©
  where 
    œÉ' := {l ‚Ü¶ œÉ(l) | l ‚àà R(œÉ,œÅ,e)}
    Œ∫œÉ' := {Œ∫l ‚Ü¶ Œ∫œÉ(Œ∫l) | Œ∫l ‚àà KR(Œ∫œÉ,Œ∫l)}
``````````````````````````````````````````````````

An execution of the semantics is the least-fixed-point of a collecting
semantics:
`````indent```````````````````````````````````````
Œº(X).X ‚à™ {œÇ‚ÇÄ} ‚à™ { œÇ' | œÇ ~~>‚∏¢gc‚∏£ œÇ' ; œÇ ‚àà X }
``````````````````````````````````````````````````
where `œÇ‚ÇÄ` is the injection of the initial program `e‚ÇÄ`:
`````indent```````````````````````````````````````
œÇ‚ÇÄ := ‚ü®e‚ÇÄ,‚ä•,‚ä•,0,‚ä•,1‚ü©
``````````````````````````````````````````````````
The analyses we present in this paper will be proven correct by establishing a
Galois connection with this concrete collecting semantics.

# Flow Properties in Analysis

The term "flow" is heavily overloaded in static analysis. In this paper we
identify three types of analysis flow:

1. Path sensitivity
2. Flow sensitivity
3. Flow insensitivity


Our framework exposes the essence of analysis flow, and therefore allows for
many other choices in addition to these three. However, these properties occur
frequently in the literature and have well-understood definitions, so we
restrict our discussion them.

Consider a combination of if-statements in our example language `ŒªIF` (extended
with let-bindings) where an analysis cannot determine the value of `N`:
`````raw``````````````````````````````````````````
\begin{alignat*}{3}
``````````````````````````````````````````````````
`````rawmacro`````````````````````````````````````
& 1: [let] x :=           && ‚ê£‚ê£[in]                 \\
& ‚ê£‚ê£2: [if0](N){          && ‚ê£‚ê£5: [let] y :=        \\
& ‚ê£‚ê£‚ê£‚ê£3: [if0](N){1}{2}   && ‚ê£‚ê£‚ê£‚ê£6: [if0](N){5}{6}  \\
& ‚ê£‚ê£} [else] {            && ‚ê£‚ê£[in]                 \\
& ‚ê£‚ê£‚ê£‚ê£4: [if0](N){3}{4}   && ‚ê£‚ê£7: [exit](x, y)      \\
& ‚ê£‚ê£}                     && \\
``````````````````````````````````````````````````
`````raw``````````````````````````````````````````
\end{alignat*}
``````````````````````````````````````````````````

\paragraph{Path-Sensitive}
A path-sensitive analysis will track both data and control flow precisely. At
program points 3 and 4 the analysis considers separate worlds:
`````align````````````````````````````````````````
3: {N=0} \quad 4: {N‚â†0}
``````````````````````````````````````````````````
At program point 6 the analysis continues in two separate, precise worlds:
`````align````````````````````````````````````````
6: {N=0,, x=1} {N‚â†0,, x=4}
``````````````````````````````````````````````````
At program point 7 the analysis correctly corrolates the values of `x` and
`y`:
`````align````````````````````````````````````````
7: {N=0,, x=1,, y=5} {N‚â†0,, x=4,, y=6}
``````````````````````````````````````````````````

\paragraph{Flow-Sensitive}
A flow-sensitive analysis will collect a _single_ set of facts about each
variable _at each program point_. At program points 3 and 4, the analysis
considers separate worlds:
`````align````````````````````````````````````````
3: {N=0} \quad 4: {N‚â†0}
``````````````````````````````````````````````````
Each nested if-statement then evaluates only one side of the branch. At program
point 6 the analysis is only allowed one set of facts, so it must merge the
possible values that `x` and `N` could take:
`````align````````````````````````````````````````
6: {N‚àà‚Ñ§,, x‚àà{1,4}}
``````````````````````````````````````````````````
The analysis must then explore both branches at program point 6 resulting in no
corrolation between values for `x` and `y`:
`````align````````````````````````````````````````
7: {N‚àà‚Ñ§,, x‚àà{1,4},, y‚àà{5,6}}
``````````````````````````````````````````````````

\paragraph{Flow-Insensitive}
A flow-insensitive analysis will collect a _single_ set of facts about each
variable which must hold true _for the entire program_. Because the value of
`N` is unknown at _some_ point in the program, the value of `x` must consider
both branches of the nested if-statement. This results in the global set of
facts giving four values to `x`.
`````align````````````````````````````````````````
{N‚àà‚Ñ§,, x‚àà{1,2,3,4},, y‚àà{5,6}}
``````````````````````````````````````````````````

In our framework we capture each flow property as a purely orthogonal parameter
to the abstract interpreter. Flow properties will compose seamlessly with
choices of call-site sensitivity, object sensitivity, abstract garbage
collection, mcfa a la \citet{dvanhorn:Might2010Resolving}, shape analysis,
abstract domain, etc. Most importantly, we empower the analysis designer to
_compartmentalize_ the flow sensitivity of each component in the abstract state
space. Constructing an analysis which is flow-sensitive in the data store and
path-sensitive in the control store is just as easy as constructing a single
flow property across the board, and one can alternate between them for free.

# Analysis Parameters

Before writing an abstract interpreter we first design its parameters. The
interpreter will be designed such that variations in these parameters will
recover both concrete and a family of abstract interpreters. To do this we
extend the ideas developed in \citet{davdar:van-horn:2010:aam} with a new
parameter for path  and flow sensitivity. When finished, we will recover both
the concrete semantics and a family of abstractions through instantiations of
these parameters.

There will be three parameters to our abstract interpreter, one of which is
novel in this work:

1. The monad, novel in this work, is the execution engine of the interpreter
   and captures path and flow sensitivity.
2. The abstract domain, which for this language is merely an abstraction for
   integers.
3. Abstract Time, capturing call-site and object sensitivities.

We place each of these parameters behind an abstract interface and leave their
implementations opaque for the generic monadic interpreter. We give each of
these parameters reasoning principles as we introduce them. These principles
allow us to reason about the correctness of the generic interpreter independent
of a particular instantiation. The goal is to factor as much of the
proof-effort into what we can say about the generic interpreter. An
instantiation of the interpreter need only justify that each parameter meets
its local interface.

## The Analysis Monad

The monad for the interpreter captures the _effects_ of interpretation. There
are two effects we wish to model in the interpreter: state and nondeterminism.
The state effect will mediate how the interpreter interacts with state cells in
the state space: `Env`, `Store`, `KAddr` and `KStore`. The nondeterminism
effect will mediate branching in the execution of the interpreter. Our result
is that path and flow sensitivities can be recovered by altering how these
effects interact in the monad.

We briefly review monad, state and nondeterminism operators and their laws.

\paragraph{Monadic Sequencing}
A type operator `M` is a monad if it supports `bind`, a sequencing operator,
and its unit `return`.
`````align```````````````````````````````````````` 
M        : Type ‚Üí Type
bind     : ‚àÄ Œ± Œ≤, M(Œ±) ‚Üí (Œ± ‚Üí M(Œ≤)) ‚Üí M(Œ≤)
return   : ‚àÄ Œ±, Œ± ‚Üí M(Œ±)
``````````````````````````````````````````````````

We use monad laws (left and right units, and associativity) to reason about our
interpreter in the absence of a particular implementation of `bind` and
`return`. As is traditional with monadic programming, we use semicolon notation
as syntactic sugar for `bind`. For example: `a ‚Üê m ; k(a)` is just sugar for
`bind(m)(k)`. We replace semicolons with line breaks headed by a `do` command
for multiline monadic definitions.

\paragraph{State Effect}
A type operator `M` supports the monadic state effect for a type `s` if it
supports `get` and `put` actions over `s`.
`````align```````````````````````````````````````` 
M        : Type ‚Üí Type
s        : Type
get      : M(s)
put      : s ‚Üí M(1)
``````````````````````````````````````````````````
We use the state monad laws to reason about state effects, and we refer the
reader to \citet{dvanhorn:Liang1995Monad} for the definitions.

\paragraph{Nondeterminism Effect}
A type operator `M` support the monadic nondeterminism effect if it supports an
alternation operator `‚ü®+‚ü©` and its unit `mzero`.
`````align```````````````````````````````````````` 
M        : Type ‚Üí Type
_[‚ü®+‚ü©]_  : ‚àÄ Œ±, M(Œ±) √ó M(Œ±) ‚Üí M(Œ±)
mzero    : ‚àÄ Œ±, M(Œ±)
``````````````````````````````````````````````````
Nondeterminism laws state that `M(Œ±)` must have a join-semilattice structure,
that `mzero` be a zero for `bind`, and that `bind` distributes through `‚ü®+‚ü©`.

\paragraph{Monad Examples}
The state monad `State‚Çõ(Œ±)` is defined as `s ‚Üí (Œ± √ó s)` and supports monadic
sequencing (`bind` and `return`) and state effects (`get` and `put`). The
nondeterminism monad `Nondet(Œ±)` is defined as `ùí´(Œ±)` and supports monadic
sequencing (`bind` and `return`) and nondeterminism effects (`_[‚ü®+‚ü©]_` and
`mzero`).

The combined interface of monadic sequencing, state and nondeterminism captures
the abstract essence of definitions which use explicit state-passing and set
comprehensions. Our interpreter will be defined up to this effect interface and
avoid referencing an explicit configuration `œÇ` or explicit collections of
results. This level of indirection will they be exploited: different monads
will meet the same effect interface, but yield different analysis properties.

## The Abstract Domain

`````align````````````````````````````````````````
    int-I  : ‚Ñ§ ‚Üí Val
int-if0-E  : Val ‚Üí ùí´(Bool)
    clo-I  : Clo ‚Üí Val
    clo-E  : Val ‚Üí ùí´(Clo)
``````````````````````````````````````````````````

The abstract domain is encapsulated by the `Val` type in the semantics. To
parameterize over the abstract domain we make `Val` opaque, but require that it
support various operations.

`Val` must be a join-semilattice with `‚ä•` and `‚äî` respecting the usual
laws. We require `Val` to be a join-semilattice so it can be merged in the
`Store` to preserve soundness. 
`````align````````````````````````````````````````
‚ä•      : Val
_[‚äî]_  : Val √ó Val ‚Üí Val
``````````````````````````````````````````````````

`Val` must also support conversions to and from concrete values. These
conversions take the form of introduction and elimination rules. Introduction
rules inject concrete values into abstract values. Elimination rules project
abstract values into a _finite_ set of concrete observations. For example, we
do not require that abstract values support elimination to integers, only the
finite observation of comparing with zero.
`````align````````````````````````````````````````
    int-I  : ‚Ñ§ ‚Üí Val
int-if0-E  : Val ‚Üí ùí´(Bool)
    clo-I  : Clo ‚Üí Val
    clo-E  : Val ‚Üí ùí´(Clo)
``````````````````````````````````````````````````

The laws for the introduction and elmination rules are designed to induce a
Galois connection between `ùí´(‚Ñ§)` and `Val`:
`````indent```````````````````````````````````````
{true}  ‚äë int-if0-E(int-I(i))     if i = 0
{false} ‚äë int-if0-E(int-I(i))     if i ‚â† 0
‚®Ü‚∏§b ‚àà int-if0-E(v), i ‚àà Œ∏(b)‚∏• int-I(i) ‚äë v
  where 
    Œ∏(true)  = {0}
    Œ∏(false) = {i | i ‚àà ‚Ñ§ ; i ‚â† 0}
``````````````````````````````````````````````````
Closures must follow similar laws, inducing a Galois connection between
`ùí´(Clo)` and `Val`:
`````indent```````````````````````````````````````
{c} ‚äë clo-E(cloI(c))
‚®Ü‚∏§c ‚àà clo-E(v)‚∏• clo-I(c) ‚äë v
``````````````````````````````````````````````````
Finally, `Œ¥` must be sound and complete w.r.t. the abstract semantics:
`````indent```````````````````````````````````````
int-I(i‚ÇÅ + i‚ÇÇ) ‚äë Œ¥‚ü¶[+]‚üß(int-I(i‚ÇÅ),int-I(i‚ÇÇ))
int-I(i‚ÇÅ - i‚ÇÇ) ‚äë Œ¥‚ü¶[-]‚üß(int-I(i‚ÇÅ),int-I(i‚ÇÇ))
‚®Ü‚∏§b‚ÇÅ ‚àà int-if0-E(v‚ÇÅ), b‚ÇÇ ‚àà int-if0-E(v‚ÇÇ), i ‚àà Œ∏(b‚ÇÅ,b‚ÇÇ)‚∏• int-I(i) ‚äë Œ¥‚ü¶‚äô‚üß(v‚ÇÅ,v‚ÇÇ)
  where
    Œ∏(true,true) = {0}
    Œ∏(true,false) = {i | i ‚àà ‚Ñ§ ; i ‚â† 0}
    Œ∏(false,true) = {i | i ‚àà ‚Ñ§ ; i ‚â† 0}
    Œ∏(false,false) = ‚Ñ§
``````````````````````````````````````````````````

Supporting additional primitive types like booleans, lists, or arbitrary
inductive datatypes is analogous. Introduction functions inject the type into
`Val`. Elimination functions project a finite set of discrete observations.
Introduction, elimination and `Œ¥` operators must be sound and complete
following a Galois connection discipline.

## Abstract Time 

The interface for abstract time is familiar from
`\citet{davdar:van-horn:2010:aam}`{.raw}(AAM) which introduces abstract time as
a single parameter from variations in call-site sensitivity, and
`\citet{dvanhorn:Smaragdakis2011Pick}`{.raw} which instantiates the parameter
to achieve both call-site and object sensitivity.
`````align````````````````````````````````````````
Time  : Type
tick  : Exp √ó KAddr √ó Time ‚Üí Time
``````````````````````````````````````````````````

Remarkably, we need not state laws for `tick`. Our interpreter will always
merge values which reside at the same address to achieve soundness. Therefore,
any supplied implementations of `tick` is valid from a soundness perspective.
Different choices in `tick` merely yield different tradoffs in precision and
performance of the abstract semantics.

# The Interpreter

We now present a generic monadic interpreter for `ŒªIF` parameterized over `M`,
`Val` and `Time`. First we implement `A‚ü¶_‚üß`, a _monadic_ denotation for atomic
expressions.
`````indent```````````````````````````````````````
A‚ü¶_‚üß ‚àà Atom ‚Üí M(Val)
A‚ü¶i‚üß := return(int-I(i))
A‚ü¶x‚üß := do
  œÅ ‚Üê get-Env
  œÉ ‚Üê get-Store
  if x ‚àà œÅ
    then return(œÉ(œÅ(x)))
    else return(‚ä•)
A‚ü¶[Œª](x).e‚üß := do
  œÅ ‚Üê get-Env
  return(clo-I(‚ü®[Œª](x).e,œÅ‚ü©))
``````````````````````````````````````````````````
`get-Env` and `get-Store` are primitive operations for monadic state. `clo-I`
comes from the abstract domain interface. 

Next we implement `step`, a _monadic_ small-step function for compound
expressions, shown in Figure \ref{InterpreterStep}. `step` uses helper
functions `push` and `pop` for manipulating stack frames, `‚Üë‚Çö` for lifting
values from `ùí´` into `M`, and a monadic version of `tick` called `tickM`, each
of which are shown in Figure \ref{InterpreterHelpers}. The interpreter looks
deterministic, however the nondeterminism is abstracted away behind `‚Üë‚Çö` and
monadic bind `x ‚Üê e‚ÇÅ ; e‚ÇÇ`.

`\begin{figure}`{.raw}
\vspace{-1em}
`````indent```````````````````````````````````````
step : Exp ‚Üí M(Exp)
step(e‚ÇÅ ‚äô e‚ÇÇ) := do
  tickM(e‚ÇÅ ‚äô e‚ÇÇ)
  push(‚ü®‚ñ° ‚äô e‚ÇÇ‚ü©)
  return(e‚ÇÅ)
step(a) := do
  tickM(a)
  fr ‚Üê pop
  v ‚Üê A‚ü¶a‚üß
  case fr of
    ‚ü®‚ñ° ‚äô e‚ü© ‚Üí do
      push(‚ü®v ‚äô ‚ñ°‚ü©)
      return(e)
    ‚ü®v' [@] ‚ñ°‚ü© ‚Üí do
      ‚ü®[Œª](x).e,œÅ'‚ü© ‚Üê ‚Üë‚Çö(clo-E(v'))
      œÑ ‚Üê get-Time
      œÉ ‚Üê get-Store
      put-Env(œÅ'[x ‚Ü¶ (x,œÑ)])
      put-Store(œÉ ‚äî [(x,œÑ) ‚Ü¶ {v}])
      return(e)
    ‚ü®v' ‚äï ‚ñ°‚ü© ‚Üí do
      return(Œ¥‚ü¶‚äï‚üß(v',v))
    ‚ü®[if0](‚ñ°){e‚ÇÅ}{e‚ÇÇ}‚ü© ‚Üí do
      b ‚Üê ‚Üë‚Çö(int-if0-E(v))
      if(b) then return(e‚ÇÅ) else return(e‚ÇÇ)
``````````````````````````````````````````````````
\caption{Monadic step function and garbage collection}
\label{InterpreterStep} 
\vspace{-1em}
`\end{figure}`{.raw}

`\begin{figure}`{.raw}
\vspace{-1em}
`````indent```````````````````````````````````````
‚Üë‚Çö : ‚àÄ Œ±, ùí´(Œ±) ‚Üí M(Œ±)
‚Üë‚Çö({a‚ÇÅ .. a‚Çô}) := return(a‚ÇÅ) ‚ü®+‚ü© .. ‚ü®+‚ü© return(a‚Çô)
<>
push : Frame ‚Üí M(1)
push(fr) := do
  Œ∫l ‚Üê get-KAddr
  Œ∫œÉ ‚Üê get-KStore
  Œ∫l' ‚Üê get-Time
  put-KStore(Œ∫œÉ ‚äî [Œ∫l' ‚Ü¶ {fr‚à∑Œ∫l}])
  put-KAddr(Œ∫l')
<>
pop : M(Frame)
pop := do
  Œ∫l ‚Üê get-KAddr
  Œ∫œÉ ‚Üê get-KStore
  fr‚à∑Œ∫l' ‚Üê ‚Üë‚Çö(Œ∫œÉ(Œ∫l))
  put-KAddr(Œ∫l')
  return(fr)
<>
tickM : Exp ‚Üí M(1)
tickM(e) = do
  œÑ ‚Üê get-Time
  Œ∫l ‚Üê get-KAddr
  put-Time(tick(e,Œ∫l,œÑ))
``````````````````````````````````````````````````
\caption{Monadic step function and garbage collection}
\label{InterpreterHelpers} 
\vspace{-1em}
`\end{figure}`{.raw}

We also implement abstract garbage collection in a general away using the
monadic effect interface:
`````indent```````````````````````````````````````
gc : Exp ‚Üí M(1)
gc(e) := do
  œÅ ‚Üê get-Env
  œÉ ‚Üê get-Store
  Œ∫œÉ ‚Üê get-KStore
  put-Store({l ‚Ü¶ œÉ(l) | l ‚àà R(œÉ,œÅ,e))
  put-KStore({Œ∫l ‚Ü¶ Œ∫œÉ(Œ∫l) | Œ∫l ‚àà KR(Œ∫œÉ,Œ∫l)})
``````````````````````````````````````````````````
where `R` and `KR` are as defined in Section`~\ref{semantics}`{.raw}. 

In generalizing the semantics to account for nondeterminism, updates to both
the value and continuation store must merge values rather than performing a
strong update. This is because we place no restriction on the semantics for
`Time` and therefore must preserve soundness in the presence of reused
addresses.

To support the `‚äî` operator for our stores (in observation of soundness), we
modify our definitions of `Store` and `KStore`.
`````indent```````````````````````````````````````
œÉ  ‚àà Store  : Addr ‚Üí Val
Œ∫œÉ ‚àà KStore : KAddr ‚Üí ùí´(Frame √ó KAddr)
``````````````````````````````````````````````````

We have already established a join-semilattice structure for `Val` in the
abstract domain interface. Developing a custom join-semilattice for
continuations is possible and is the key component of recent developments in
pushdown abstraction. For this presentation we use `ùí´(Frame √ó KAddr)` as an
abstraction for continuations for simplicity.

To execute the interpreter we must introduce one more parameter. In the
concrete semantics, execution takes the form of a least-fixed-point computation
over the collecting semantics. This in general requires a join-semilattice
structure for some `Œ£` and a transition function `Œ£ ‚Üí Œ£`.

For the monadic interpreter we require that monadic actions `Exp ‚Üí M(Exp)` form
a Galois connection with a transition system `Œ£ ‚Üí Œ£`. This Galois connection
serves two purposes. First, it allows us to implement the analysis by
converting our interpreter to the transition system `Œ£ ‚Üí Œ£` through `Œ≥`.
Second, this Galois connection serves to _transport other Galois connections_
as part of our correctness framework. For example, given concrete and abstract
versions of `Val`, we carry `CVal Œ±‚áÑŒ≥ AVal` through the Galois connection to
establish `CŒ£ Œ±‚áÑŒ≥ AŒ£`.

A collecting-semantics execution of our interpreter is defined as the
least-fixed-point of `step` transported through the Galois connection `(Œ£ ‚Üí Œ£)
Œ±‚áÑŒ≥ (Exp ‚Üí M(Exp))`.
`````indent```````````````````````````````````````
Œº(X). X ‚äî œÇ‚ÇÄ ‚äî Œ≥(step)(X)
``````````````````````````````````````````````````
where `œÇ‚ÇÄ` is the injection of the initial program `e‚ÇÄ` into `Œ£` and `Œ≥` has
type `(Exp ‚Üí M(Exp)) ‚Üí (Œ£ ‚Üí Œ£)`.

# Recovering Analyses

To recover concrete and abstract interpreters we need only instantiate our
generic monadic interpreter with concrete and abstract components. The concrete
interpreter will recover the concrete semantics from Section \ref{semantics},
and through that correspondance, the soundness proof for the abstract semantics
will be recovered largely for free.

## Recovering a Concrete Interpreter

For the concrete value space we instantiate `Val` to `CVal`:
`````indent```````````````````````````````````````
v ‚àà CVal := ùí´(CClo + ‚Ñ§)
``````````````````````````````````````````````````

The concrete value space `CVal` has straightforward introduction and
elimination rules:
`````indent```````````````````````````````````````
int-I : ‚Ñ§ ‚Üí CVal
int-I(i) := {i}
int-if0-E : CVal ‚Üí ùí´(Bool)
int-if0-E(v) := { true | 0 ‚àà v } ‚à™ { false | ‚àÉ i ‚àà v ‚àß i ‚â† 0 }
``````````````````````````````````````````````````
and a straightforward concrete `Œ¥`:
`````indent```````````````````````````````````````
Œ¥‚ü¶_‚üß(_,_) : IOp ‚Üí CVal √ó CVal ‚Üí CVal
Œ¥‚ü¶[+]‚üß(v‚ÇÅ,v‚ÇÇ) := { i‚ÇÅ + i‚ÇÇ | i‚ÇÅ ‚àà v‚ÇÅ ; i‚ÇÇ ‚àà v‚ÇÇ }
Œ¥‚ü¶[-]‚üß(v‚ÇÅ,v‚ÇÇ) := { i‚ÇÅ - i‚ÇÇ | i‚ÇÅ ‚àà v‚ÇÅ ; i‚ÇÇ ‚àà v‚ÇÇ }
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CVal` satisfies the abstract domain laws shown in Section
\ref{the-abstract-domain}.
`\end{proposition}`{.raw}

Concrete time `CTime` captures program contours as a product of `Exp` and
`CKAddr`:
`````indent```````````````````````````````````````
œÑ ‚àà CTime := (Exp √ó KAddr)‚∏¢*‚∏£
``````````````````````````````````````````````````
and `tick` is just a cons operator:
`````indent```````````````````````````````````````
tick : Exp √ó CKAddr √ó CTime ‚Üí CTime
tick (e,Œ∫l,œÑ) := (e,Œ∫l)‚à∑œÑ
``````````````````````````````````````````````````

For the concrete monad we instantiate `M` to a path-sensitive `CM` which
contains a powerset of concrete state space components.
`````indent```````````````````````````````````````
œà ‚àà Œ® := CEnv √ó CStore √ó CKAddr √ó CKStore √ó CTime
m ‚àà CM(Œ±) := Œ® ‚Üí ùí´(Œ± √ó Œ®)
``````````````````````````````````````````````````

Monadic operators `bind` and `return` encapsulate both state-passing and
set-flattening:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ±, CM(Œ±) ‚Üí (Œ± ‚Üí CM(Œ≤)) ‚Üí CM(Œ≤)
bind(m)(f)(œà) := 
  {(y,œà'') | (y,œà'') ‚àà f(a)(œà') ; (a,œà') ‚àà m(œà)}
return : ‚àÄ Œ±, Œ± ‚Üí CM(Œ±)
return(a)(œà) := {(a,œà)}
``````````````````````````````````````````````````

State effects merely return singleton sets:
`````indent```````````````````````````````````````
get-Env : CM(CEnv)
get-Env(‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©) := {(œÅ,‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©)}
put-Env : CEnv ‚Üí ùí´(1)
put-Env(œÅ')(‚ü®œÅ,œÉ,Œ∫,œÑ‚ü©) := {(1,‚ü®œÅ',œÉ,Œ∫,œÑ‚ü©)}
``````````````````````````````````````````````````

Nondeterminism effects are implemented with set union:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, CM(Œ±)
mzero(œà) := {}
_[‚ü®+‚ü©]_ : ‚àÄ Œ±, CM(Œ±) √ó CM(Œ±) ‚Üí CM(Œ±)
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(œà) := m‚ÇÅ(œà) ‚à™ m‚ÇÇ(œà)
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CM` satisfies monad, state, and nondeterminism laws shown in Section
\ref{the-analysis-monad}.
`\end{proposition}`{.raw}

Finally, we must establish a Galois connection between `Exp ‚Üí CM(Exp)` and `CŒ£
‚Üí CŒ£` for some choice of `CŒ£`. For the path-sensitive monad `CM` instantiated
with `CVal` and `CTime`, `CŒ£` is defined:
`````indent```````````````````````````````````````
CŒ£ := ùí´(Exp √ó Œ®)
``````````````````````````````````````````````````

The Galois connection between `CM` and `CŒ£` is straightforward:
`````indent```````````````````````````````````````
Œ≥ : (Exp ‚Üí CM(Exp)) ‚Üí (CŒ£ ‚Üí CŒ£)
Œ≥(f)(eœà‚∏¢*‚∏£) := {(e,œà') | (e,œà') ‚àà f(e)(œà) ; (e,œà) ‚àà eœà‚∏¢*‚∏£}
Œ± : (CŒ£ ‚Üí CŒ£) ‚Üí (Exp ‚Üí CM(Exp))
Œ±(f)(e)(œà) := f({(e,œà)})
``````````````````````````````````````````````````

The injection `œÇ‚ÇÄ` for a program `e‚ÇÄ` is:
`````indent```````````````````````````````````````
œÇ‚ÇÄ := {‚ü®e,‚ä•,‚ä•,‚àô,‚ä•,‚àô‚ü©}
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`Œ≥` and `Œ±` form an isomorphism, and therefore a Galois connection.
`\end{proposition}`{.raw}

## Recovering an Abstract Interpreter

We pick a simple abstraction for integers, `{[-],0,[+]}`, although our
technique scales seamlessly to other domains.
`````indent```````````````````````````````````````
AVal := ùí´(AClo + {[-],0,[+]})
``````````````````````````````````````````````````

Introduction and elimination for `AVal` are defined:
`````indent```````````````````````````````````````
int-I : ‚Ñ§ ‚Üí AVal
int-I(i) := {[-]} if i < 0
int-I(i) := {0}   if i = 0
int-I(i) := {[+]} if i > 0
int-if0-E : AVal ‚Üí ùí´(Bool)
int-if0-E(v) := { true | 0 ‚àà v } ‚à™ { false | [-] ‚àà v ‚à® [+] ‚àà v }
``````````````````````````````````````````````````
Introduction and elimination for `AClo` is identical to the concrete domain.

The abstract `Œ¥` operator is defined:
`````indent```````````````````````````````````````
Œ¥ : IOp ‚Üí AVal √ó AVal ‚Üí AVal 
Œ¥‚ü¶[+]‚üß(v‚ÇÅ,v‚ÇÇ) := 
    { i         | 0 ‚àà v‚ÇÅ ‚àß i ‚àà v‚ÇÇ }
  ‚à™ { i         | i ‚àà v‚ÇÅ ‚àß 0 ‚àà v‚ÇÇ }
  ‚à™ { [+]       | [+] ‚àà v‚ÇÅ ‚àß [+] ‚àà v‚ÇÇ } 
  ‚à™ { [-]       | [-] ‚àà v‚ÇÅ ‚àß [-] ‚àà v‚ÇÇ } 
  ‚à™ { [-],0,[+] | [+] ‚àà v‚ÇÅ ‚àß [-] ‚àà v‚ÇÇ }
  ‚à™ { [-],0,[+] | [-] ‚àà v‚ÇÅ ‚àß [+] ‚àà v‚ÇÇ }
``````````````````````````````````````````````````
The definition for `Œ¥‚ü¶[-]‚üß(v‚ÇÅ,v‚ÇÇ)` is analogous.

`\begin{proposition}`{.raw}
`AVal` satisfies the abstract domain laws shown in
Section`~\ref{the-abstract-domain}`{.raw}.
`\end{proposition}`{.raw}

`\begin{proposition}`{.raw}
`CVal Œ±‚áÑŒ≥ AVal` and their operations `int-I`, `int-if0-E` and `Œ¥` are ordered
`‚äë` respectively through the Galois connection.
`\end{proposition}`{.raw}

Next we abstract `Time` to `ATime` as the finite domain of k-truncated lists of
execution contexts:
`````indent```````````````````````````````````````
ATime := (Exp √ó AKAddr)‚ãÜ‚Çñ
``````````````````````````````````````````````````
The `tick` operator becomes cons followed by k-truncation, which restricts the
list to the first-k elements:
`````indent```````````````````````````````````````
tick : Exp √ó AKAddr √ó ATime ‚Üí ATime
tick(e,Œ∫l,œÑ) = ‚åä(e,Œ∫l)‚à∑œÑ‚åã‚Çñ
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`CTime Œ±‚áÑŒ≥ ATime` and `tick` are ordered `‚äë` through the Galois connection.
`\end{proposition}`{.raw}

The monad `AM` need not change in implementation from `CM`; they are identical
up the choice of `Œ®`.
`````indent```````````````````````````````````````
œà ‚àà Œ® := AEnv √ó AStore √ó AKAddr √ó AKStore √ó ATime
``````````````````````````````````````````````````

The resulting state space `AŒ£` is finite, and its least-fixed-point iteration
will give a sound and computable analysis.

# Varying Path and Flow Sensitivity

We are able to recover a flow insensitive analysis through a new definition for
`M`: `AM‚∏¢fi‚∏£`. To do this we pull `AStore` out of the powerset, exploiting its
join-semilattice structure:
`````indent```````````````````````````````````````
Œ® := AEnv √ó AKAddr √ó AKStore √ó ATime
AM‚∏¢fi‚∏£(Œ±) := Œ® √ó AStore ‚Üí ùí´(Œ± √ó Œ®) √ó AStore
``````````````````````````````````````````````````

The monad operator `bind` performs the store merging needed to capture a
flow-insensitive analysis.
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, AM‚∏¢fi‚∏£(Œ±) ‚Üí (Œ± ‚Üí AM‚∏¢fi‚∏£(Œ≤)) ‚Üí AM‚∏¢fi‚∏£(Œ≤)
bind(m)(f)(œà,œÉ) := ({bs‚∏§11‚∏• .. bs‚∏§1m‚ÇÅ‚∏• .. bs‚∏§n1‚∏• .. bs‚∏§nm‚Çô‚∏•},œÉ‚ÇÅ ‚äî .. ‚äî œÉ‚Çô)
  where
    ({(a‚ÇÅ,œà‚ÇÅ) .. (a‚Çô,œà‚Çô)},œÉ') := m(œà,œÉ)
    ({bœà‚∏§i1‚∏• .. bœà‚∏§im·µ¢‚∏•},œÉ·µ¢) := f(a·µ¢)(œà·µ¢,œÉ')
``````````````````````````````````````````````````
The unit for `bind` returns one nondeterminism branch and a single store:
`````indent```````````````````````````````````````
return : ‚àÄ Œ±, Œ± ‚Üí AM‚∏¢fi‚∏£(Œ±)
return(a)(œà,œÉ) := ({a,œà},œÉ)
``````````````````````````````````````````````````

State effects `get-Env` and `put-Env` are also straightforward, returning one
branch of nondeterminism:
`````indent```````````````````````````````````````
get-Env : AM‚∏¢fi‚∏£(AEnv)
get-Env(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(œÅ,‚ü®œÅ,Œ∫,œÑ‚ü©)},œÉ)
put-Env : AEnv ‚Üí AM‚∏¢fi‚∏£(1)
put-Env(œÅ')(‚ü®œÅ,Œ∫,œÑ‚ü©,œÉ) := ({(1,‚ü®œÅ',Œ∫,œÑ‚ü©)},œÉ)
``````````````````````````````````````````````````
State effects `get-Store` and `put-Store` are analogous to `get-Env` and
`put-Env`.

Nondeterminism operations will union the powerset and join the store pairwise:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, M(Œ±)
mzero(œà,œÉ) := ({}, ‚ä•)
_[‚ü®+‚ü©]_ : ‚àÄ Œ±, M(Œ±) √ó M(Œ±) ‚Üí M Œ± 
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(œà,œÉ) := (aœà*‚ÇÅ ‚à™ aœà*‚ÇÇ,œÉ‚ÇÅ ‚äî œÉ‚ÇÇ)
  where (aœà*·µ¢,œÉ·µ¢) := m·µ¢(œà,œÉ)
``````````````````````````````````````````````````

Finally, the Galois connection relating `AM‚∏¢fi‚∏£` to a state space transition over
`AŒ£‚∏¢fi‚∏£` must also compute set unions and store joins pairwise:
`````indent```````````````````````````````````````
AŒ£‚∏¢fi‚∏£ := ùí´(Exp √ó Œ®) √ó AStore
Œ≥ : (Exp ‚Üí AM‚∏¢fi‚∏£(Exp)) ‚Üí (AŒ£‚∏¢fi‚∏£ ‚Üí AŒ£‚∏¢fi‚∏£)
Œ≥(f)(eœà*,œÉ) := ({eœà‚∏§11‚∏• .. eœà‚∏§n1‚∏• .. eœà‚∏§nm‚∏•}, œÉ‚ÇÅ ‚äî .. ‚äî œÉ‚Çô)
  where 
    {(e‚ÇÅ,œà‚ÇÅ) .. (e‚Çô,œà‚Çô)} := eœà*
    ({eœà‚∏§i1‚∏• .. eœà‚∏§im‚∏•},œÉ·µ¢) := f(e·µ¢)(œà·µ¢,œÉ)
Œ±  : (AŒ£‚∏¢fi‚∏£ ‚Üí AŒ£‚∏¢fi‚∏£) ‚Üí (Exp ‚Üí AM‚∏¢fi‚∏£(Exp))
Œ±(f)(e)(œà,œÉ) := f({(e,œà)},œÉ)
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`Œ≥` and `Œ±` form an isomorphism, and therefore a Galois connection.
`\end{proposition}`{.raw}

`\begin{proposition}`{.raw}
There exists Galois connections:
`````align````````````````````````````````````````
CM Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ AM Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ AM‚∏¢fi‚∏£
``````````````````````````````````````````````````
`\end{proposition}`{.raw}
The first Galois connection `CM Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ AM` is justified piecewise by the Galois
connections between `CVal Œ±‚áÑŒ≥ AVal` and `CTime Œ±‚áÑŒ≥ ATime`. The second Galois
connection `AM Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ AM‚∏¢fi‚∏£` is justified by calculation over their
definitions. We aim to recover this proof more easily through compositional
components in Section \ref{a-compositional-monadic-framework}.

`\begin{corollary}`{.raw}
`````align````````````````````````````````````````
CŒ£ Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ AŒ£ Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ AŒ£‚∏¢fi‚∏£
``````````````````````````````````````````````````
`\end{corollary}`{.raw}
This property is derived by transporting each Galois connection between monads
through their respective Galois connections to `Œ£`.

`\begin{proposition}`{.raw}
The following orderings hold between the three induced transition relations:
`````align````````````````````````````````````````
Œ±‚ÇÅ ‚àò CŒ≥(step) ‚àò Œ≥‚ÇÅ ‚äë AŒ≥(step) ‚äë Œ≥‚ÇÇ ‚àò AŒ≥‚∏¢fi‚∏£(step) ‚àò Œ±‚ÇÇ
``````````````````````````````````````````````````
`\end{proposition}`{.raw}
This is a direct consequence of the monotonicity of step and the Galois
connections between monads.

We note that the implementation for our interpreter and abstract garbage
collector remain the same for each instantiation. They scale seamlessly to
path-sensitive and flow-insensitive variants when instantiated with the
appropriate monad. 

Recovering flow sensitivity is done through another analysis monad, which we
develop in Section \ref{a-compositional-monadic-framework} in a more general
setting.

# A Compositional Monadic Framework

In our development thus far, any modification to the interpreter requires
redesigning the monad `AM` and constructing new proofs relating `AM` to `CM`.
We want to avoid reconstructing complicated monads for our interpreters,
especially as languages and analyses grow and change. Even more, we want to
avoid reconstructing complicated _proofs_ that such changes will necessarily
require. Toward this goal we introduce a compositional framework for
constructing monads which are correct-by-construction--we extend the well-known
structure of monad transformer to that of _Galois transformer_.

There are two types of monadic effects used in our monadic interpreter: state
and nondeterminism. Each of these effects have corresponding monad
transformers. Transformers can be composed in either direction, and the two
possible directions of composition give rise naturally to path-sensitive and
flow-insenstive analyses. Furthermore, our definition of nondeterminism monad
transformer is novel in this work.

In the proceeding definitions, we must necessarily use `bind`, `return` and
other operations from the underlying monad. We notate these `bind‚Çò`, `return‚Çò`,
`do‚Çò`, `‚Üê‚Çò`,  etc. for clarity.

## State Monad Transformer

Briefly we review the state monad transformer, `S‚Çú[s]`:
`````indent```````````````````````````````````````
S‚Çú[_] : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
S‚Çú[s](m)(Œ±) := s ‚Üí m(Œ± √ó s)
``````````````````````````````````````````````````

The state monad transformer can transport monadic operations from `m` to
`S‚Çú[s](m)`:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, S‚Çú[s](m)(Œ±) ‚Üí (Œ± ‚Üí S‚Çú[s](m)(Œ≤)) ‚Üí S‚Çú[s](m)(Œ≤)
bind(m)(f)(s) := do‚Çò
  (x,s') ‚Üê‚Çò m(s)
  f(x)(s')
return : ‚àÄ Œ±, Œ± ‚Üí S‚Çú[s](m)(Œ±)
return(x)(s) := return‚Çò(x,s)
``````````````````````````````````````````````````

The state monad transformer can also transport nondeterminism effects from `m`
to `S‚Çú[s](m)`:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, S‚Çú[s](m)(Œ±)
mzero(s) := mzero‚Çò 
_[‚ü®+‚ü©]_ : ‚àÄ Œ±, S‚Çú[s](m)(Œ±) √ó S‚Çú[s](m)(Œ±) ‚Üí S‚Çú[s](m)(Œ±)
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(s) := m‚ÇÅ(s) ‚ü®+‚ü©‚Çò m‚ÇÇ(s) 
``````````````````````````````````````````````````

Finally, the state monad transformer exposes `get` and `put` operations
provided that `m` is a monad:
`````indent```````````````````````````````````````
get : S‚Çú[s](m)(s)
get(s) := return‚Çò(s,s)
put : s ‚Üí S‚Çú[s](m)(1)
put(s')(s) := return‚Çò(1,s')
``````````````````````````````````````````````````

## Nondeterminism Monad Transformer

We have developed a new monad transformer for nondeterminism which composes
with state in both directions. Previous attempts to define a monad transformer
for nondeterminism have resulted in monad operations which do not respect
either monad laws or nondeterminism effect laws.

Our nondeterminism monad transformer is defined with the expected type,
embedding `ùí´` inside `m`:
`````indent```````````````````````````````````````
ùí´‚Çú : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
ùí´‚Çú(m)(Œ±) := m(ùí´(Œ±))
``````````````````````````````````````````````````

The nondeterminism monad transformer can transport monadic operations from `m`
to `ùí´‚Çú` _provided that `m` is also a join-semilattice functor_:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, ùí´‚Çú(m)(Œ±) ‚Üí (Œ± ‚Üí ùí´‚Çú(m)(Œ≤)) ‚Üí ùí´‚Çú(m)(Œ≤)
bind(m)(f) := do‚Çò
  {x‚ÇÅ .. x‚Çô} ‚Üê‚Çò m
  f(x‚ÇÅ) ‚äî‚Çò .. ‚äî‚Çò f(x‚Çô)
return : ‚àÄ Œ±, Œ± ‚Üí ùí´‚Çú(m)(Œ±)
return(x) := return‚Çò({x})
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`bind` and `return` satisfy the monad laws.
`\end{proposition}`{.raw}
The key lemma in this proof is the functorality of `m`, namely that:
`````align````````````````````````````````````````
return‚Çò(x ‚äî y) = return‚Çò(x) ‚äî return‚Çò(y)
``````````````````````````````````````````````````

The nondeterminism monad transformer can transport state effects from `m` to
`ùí´‚Çú`:
`````indent```````````````````````````````````````
get : ùí´‚Çú(m)(s)
get = map‚Çò(Œª(s).{s})(get‚Çò)
put : s ‚Üí ùí´‚Çú(m)(1)
put(s) = map‚Çò(Œª(1).{1})(put‚Çò(s))
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`get` and `put` satisfy the state monad laws.
`\end{proposition}`{.raw}
The proof is by simple calculation.

Finally, our nondeterminism monad transformer exposes nondeterminism effects as
a straightforward application of the underlying monad's join-semilattice
functorality:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, ùí´‚Çú(m)(Œ±)
mzero := ‚ä•‚Çò
_[‚ü®+‚ü©]_ : ‚àÄ Œ±, ùí´‚Çú(m)(Œ±) x ùí´‚Çú(m)(Œ±) ‚Üí ùí´‚Çú(m)(Œ±)
m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ := m‚ÇÅ ‚äî‚Çò m‚ÇÇ
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`mzero` and `‚ü®+‚ü©` satisfy the nondeterminism monad laws.
`\end{proposition}`{.raw}
The proof is trivial as a consequence of the underlying monad being a
join-semilattice functor.

Path sensitivity arises naturally when a state transformer sits on top of a
nondeterminism transformer. Flow insensitivity arises naturally when
nondeterminism sits on top of state.

## Mapping to State Spaces

Both our execution and correctness frameworks requires that monadic actions in
`m` map to state space transitions in `Œ£`. We extend the earlier statement of
Galois connection to the transformer setting, mapping monad _transformer_
actions in `T` to state space _functor_ transitions in `Œ†`.
`````indent```````````````````````````````````````
T : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
Œ† : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
mstep : ‚àÄ Œ± Œ≤ m, (Œ± ‚Üí T(m)(Œ≤)) Œ±‚áÑŒ≥ (Œ†(Œ£‚Çò)(Œ±) ‚Üí Œ†(Œ£‚Çò)(Œ≤))
``````````````````````````````````````````````````
In the type of `mstep`, `m` is an arbitrary monad whose monadic actions map to
state space `Œ£‚Çò`. The monad transformer `T` must induce a state space
transformer `Œ†` for which `mstep` can be defined. We only show the `Œ≥` sides of
the mappings in this section, which allow one to execute the analyses.

For the state monad transformer `S‚Çú[s]` mstep is defined:
`````indent```````````````````````````````````````
mstep-Œ≥ : ‚àÄ Œ± Œ≤, 
  (Œ± ‚Üí S‚Çú[s](m)(Œ≤)) ‚Üí (Œ£‚Çò(Œ± √ó s) ‚Üí Œ£‚Çò(Œ≤ √ó s))
mstep-Œ≥(f) := mstep‚Çò-Œ≥(Œª(a,s). f(a)(s))
``````````````````````````````````````````````````

For the nondeterminism transformer `ùí´‚Çú` mstep is defined:
`````indent```````````````````````````````````````
mstep-Œ≥ : ‚àÄ Œ± Œ≤, 
  (Œ± ‚Üí ùí´‚Çú(m)(Œ≤)) ‚Üí (Œ£‚Çò(ùí´(Œ±)) ‚Üí Œ£‚Çò(ùí´(Œ≤)))
mstep-Œ≥(f) := mstep‚Çò-Œ≥(F)
  where F({x‚ÇÅ .. x‚Çô}) = f(x‚ÇÅ) ‚ü®+‚ü© .. ‚ü®+‚ü© f(x‚Çô))
``````````````````````````````````````````````````
The Galois connections for `mstep` for both `S‚Çú[s]` or `P‚Çú` rely crucially on
`mstep‚Çò-Œ≥` and `mstep‚Çò-Œ±` being homomorphic, i.e. that:
`````align````````````````````````````````````````
Œ±(id) ‚äë return
Œ±(f ‚àò g) ‚äë Œ±(f) ‚ü®‚àò‚ü© Œ±(g)
``````````````````````````````````````````````````
and likewise for `Œ≥`, where `‚ü®‚àò‚ü© ` is composition in the Kleisli category for
the monad `M`.

`\begin{proposition}`{.raw}
`S‚Çú[s] ‚àò ùí´‚Çú Œ±‚áÑŒ≥ ùí´‚Çú ‚àò S‚Çú[s]`.
`\end{proposition}`{.raw}
The proof is by calculation after unfolding the definitions.

## Flow Sensitivity Transformer

The flow sensitivity transformer is a unique monad transformer that combines
state and nondeterminism effects, and does not arise naturally from composing
vanilla nondeterminism and state transformers. The flow sensitivity transformer
is defined:
`````indent```````````````````````````````````````
FS‚Çú[_] : (Type ‚Üí Type) ‚Üí (Type ‚Üí Type)
FS‚Çú[s](m)(Œ±) := s ‚Üí m([Œ± ‚Ü¶ s])
``````````````````````````````````````````````````
where `[Œ± ‚Ü¶ s]` is notation for a finite map over a defined domain in `Œ±`.

`FS‚Çú[s]` is a monad when `s` is a join-semilattice and `m` is a
join-semilattice functor:
`````indent```````````````````````````````````````
bind : ‚àÄ Œ± Œ≤, 
  FS‚Çú[s](m)(Œ±) ‚Üí (Œ± ‚Üí FS‚Çú[s](m)(Œ≤)) ‚Üí FS‚Çú[s](m)(Œ≤)
bind(m)(f)(s) := do‚Çò
  {x‚ÇÅ ‚Ü¶ s‚ÇÅ,..,x‚Çô ‚Ü¶ s‚Çô} ‚Üê‚Çò m(s)
  f(x‚ÇÅ)(s‚ÇÅ) ‚ü®+‚ü© .. ‚ü®+‚ü© f(x‚Çô)(s‚Çô)
return : ‚àÄ Œ±, Œ± ‚Üí FS‚Çú[s](m)(Œ±)
return(x)(s) := return‚Çò {x ‚Ü¶ s}
``````````````````````````````````````````````````

`FS‚Çú[s]` has monadic state effects:
`````indent```````````````````````````````````````
get : FS‚Çú[s](m)(s)
get(s) := return‚Çò {s ‚Ü¶ s}
put : s ‚Üí FS‚Çú[s](m)(1)
put(s')(s) := return‚Çò {1 ‚Ü¶ s'}
``````````````````````````````````````````````````

`FS‚Çú[s]` has nondeterminism effects when `s` is a join-semilattice and `m` is a
join-semilattice functor:
`````indent```````````````````````````````````````
mzero : ‚àÄ Œ±, FS‚Çú[s](m)(Œ±)
mzero(s) := ‚ä•‚Çò
_[‚ü®+‚ü©]_ : ‚àÄ Œ±, FS‚Çú[s](m)(Œ±) x FS‚Çú[s](m)(Œ±) ‚Üí FS‚Çú[s](m)(Œ±)
(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(s) := m‚ÇÅ(s) ‚äî‚Çò m‚ÇÇ(s)
``````````````````````````````````````````````````

The last property required for `FS‚Çú[s]` to fit into our framework is to map
monadic actions in `FS‚Çú[s]` to transitions in some state space transformer `Œ†`.
`````indent```````````````````````````````````````
mstep-Œ≥ : ‚àÄ Œ± Œ≤, 
  (Œ± ‚Üí FS‚Çú[s](m)(Œ≤)) ‚Üí (Œ£‚Çò([Œ± ‚Ü¶ s]) ‚Üí Œ£‚Çò([Œ≤ √ó s]))
mstep-Œ≥(f) := mstep‚Çò-Œ≥(F)
  where F({x‚ÇÅ ‚Ü¶ s‚ÇÅ},..,{x‚Çô ‚Ü¶ s‚Çô}) :=
    f(x‚ÇÅ)(s‚ÇÅ) ‚ü®+‚ü© .. ‚ü®+‚ü© f(x‚Çô)(s‚Çô)
``````````````````````````````````````````````````

`\begin{proposition}`{.raw}
`get` and `put` satisfy the state monad laws.
`\end{proposition}`{.raw}

`\begin{proposition}`{.raw}
`mzero` and `‚ü®+‚ü©` satisfy the nondeterminism monad laws.
`\end{proposition}`{.raw}

`\begin{proposition}`{.raw}
`S‚Çú[s] ‚àò ùí´‚Çú Œ±‚ÇÅ‚áÑŒ≥‚ÇÅ FS‚Çú[s] Œ±‚ÇÇ‚áÑŒ≥‚ÇÇ ùí´‚Çú ‚àò S‚Çú[s]`.
`\end{proposition}`{.raw}

These proofs are analagous to those for state and nondeterminism monad
transformers.

## Galois Transformers

The capstone of our compositional framework is the fact that monad transformers
`S‚Çú[s]`, `FS‚Çú[s]` and `ùí´‚Çú` are also _Galois transformers_. Whereas a monad
transformer is a functor between monads, a Galois transformer is a functor
between Galois monads.

`\begin{definition}`{.raw}
A monad transformer `T` is a Galois transformer if:

1. For all monads `m‚ÇÅ` and `m‚ÇÇ`, `m‚ÇÅ Œ±‚áÑŒ≥ m‚ÇÇ` implies `T(m‚ÇÅ) Œ±‚áÑŒ≥ T(m‚ÇÇ)`
2. For all monads `m` and functors `Œ£` there exists `Œ†` s.t. 
   `(Œ± ‚Üí m(Œ≤)) Œ±‚áÑŒ≥ (Œ£(Œ±) ‚Üí Œ£(Œ≤)) ‚áí (Œ± ‚Üí T(m)(Œ≤)) Œ±‚áÑŒ≥ (Œ†(Œ£)(Œ±) ‚Üí Œ†(Œ£)(Œ≤))`. 

`\end{definition}`{.raw}

`\begin{proposition}`{.raw}
`S‚Çú[s]`, `FS‚Çú[s]` and `ùí´‚Çú` are Galois transformers.
`\end{proposition}`{.raw}
The proofs were sketched earlier in Section
\ref{a-compositional-monadic-framework}.

## Building Transformer Stacks

We can now build monad transformer stacks from combinations of `S‚Çú[s]`,
`FS[s]‚Çú` and `ùí´‚Çú` with the following properties:

- The resulting monad has the combined effects of all pieces of the transformer
  stack.
- Actions in the resulting monad map to a state space transition system `Œ£ ‚Üí Œ£`
  for some `Œ£`, allowing one to execute the analysis.
- Galois connections between `CŒ£` and `AŒ£` are established piecewise from monad
  transformer components.
- Monad transformer components are proven correct for all possible languages
  and choices for orthogonal analysis features.

We instantiate our interpreter to the following monad stacks in decreasing
order of precision:

\vspace{1em}
`\begin{tabular}{l | l | l}`{.raw}
`````rawmacro````````````````````````````````````
S‚Çú[AEnv]     & S‚Çú[AEnv]      & S‚Çú[AEnv]    \\
S‚Çú[AKAddr]   & S‚Çú[AKAddr]    & S‚Çú[AKAddr]  \\
S‚Çú[AKStore]  & S‚Çú[AKStore]   & S‚Çú[AKStore] \\
S‚Çú[ATime]    & S‚Çú[ATime]     & S‚Çú[ATime]   \\
S‚Çú[AStore]   &               & ùí´‚Çú          \\
ùí´‚Çú           & FS‚Çú[AStore]   & S‚Çú[AStore]  \\
``````````````````````````````````````````````````
`\end{tabular}`{.raw}
\vspace{1em}

\noindent
From left to right, these give path-sensitive, flow-sensitive, and
flow-insensitive analyses. Furthermore, each monad stack with abstract
components is assigned a Galois connection by-construction with their concrete
analogues:

\vspace{1em}
`\begin{tabular}{l | l | l}`{.raw}
`````rawmacro``````````````````````````````````````
S‚Çú[CEnv]     & S‚Çú[CEnv]      & S‚Çú[CEnv]    \\
S‚Çú[CKAddr]   & S‚Çú[CKAddr]    & S‚Çú[CKAddr]  \\
S‚Çú[CKStore]  & S‚Çú[CKStore]   & S‚Çú[CKStore] \\
S‚Çú[CTime]    & S‚Çú[CTime]     & S‚Çú[CTime]   \\
S‚Çú[CStore]   &               & ùí´‚Çú          \\
ùí´‚Çú           & FS‚Çú[CStore]   & S‚Çú[CStore]  \\
`````````````````````````````````````````````````
`\end{tabular}`{.raw}
\vspace{1em}

Another benefit of our approach is that we can selectively widen the value and
continuation stores independent of each other. To do this we merely swap the
order of transformers:
\vspace{1em}
`\begin{tabular}{l | l | l}`{.raw}
`````rawmacro``````````````````````````````````````
S‚Çú[CEnv]     & S‚Çú[CEnv]      & S‚Çú[CEnv]    \\
S‚Çú[CKAddr]   & S‚Çú[CKAddr]    & S‚Çú[CKAddr]  \\
S‚Çú[CTime]    & S‚Çú[CTime]     & S‚Çú[CTime]   \\
S‚Çú[CStore]   & FS‚Çú[CStore]   & ùí´‚Çú          \\
ùí´‚Çú           &               & S‚Çú[CStore]  \\
S‚Çú[CKStore]  & S‚Çú[CKStore]   & S‚Çú[CKStore] \\
`````````````````````````````````````````````````
`\end{tabular}`{.raw}
\vspace{1em}

# Implementation

We have implemented our framework in Haskell and applied it to compute analyses
for `ŒªIF`. Our implementation provides path sensitivity, flow sensitivity, and
flow insensitivity as a semantics-independent monad library. The code shares a
striking resemblance with the math.

Our interpreter for `ŒªIF` is parameterized as discussed in
Section`~\ref{analysis-parameters}`{.raw}. We express a valid analysis with the
following Haskell constraint:
`````indent```````````````````````````````````````
type Analysis(Œ¥,Œº,m) ‚à∑ Constraint = 
  (AAM(Œº),Delta(Œ¥),AnalysisMonad(Œ¥,Œº,m))
``````````````````````````````````````````````````
Constraints `AAM(Œº)` and `Delta(Œ¥)` are interfaces for abstract time and the
abstract domain.

\noindent
The constraint `AnalysisMonad(m)` requires only that `m` has the required
effects:
`````indent```````````````````````````````````````
type AnalysisMonad(Œ¥,Œº,m) ‚à∑ Constraint = (
   Monad(m(Œ¥,Œº)), 
   MonadNondeterminism(m(Œ¥,Œº)),
   MonadState‚∏§Env(Œº)‚∏•(m(Œ¥,Œº)),
   MonadState‚∏§Store(Œ¥,Œº)‚∏•(m(Œ¥,Œº)),
   MonadState‚∏§Time(Œº,Exp)‚∏•(m(Œ¥,Œº)))
``````````````````````````````````````````````````
Our interpreter is implemented against this interface and concrete and abstract
interpreters are recovered by instantiating `Œ¥`, `Œº` and `m`.

Using Galois transformers, we enable arbitrary composition of choices for
various analysis components. For example, our implementation, called `maam`
supports command-line flags for garbage collection, k-CFA, and path- and
flow sensitivity.
``````````````````````````````````````````````````
./maam --gc --CFA=0 --flow-sen prog.lam
``````````````````````````````````````````````````
These flags are implemented completely independent of one another, and their
combination is applied to a single parameterized monadic interpreter.
Furthermore, using Galois transformers allows us to prove each combination
correct in one fell swoop.

Our implementation is publicly available and can be installed as a cabal
package by executing:
``````````````````````````````````````````````````
cabal install maam
``````````````````````````````````````````````````

# Related Work

Program analysis comes in many forms such as points-to
\cite{dvanhorn:Andersen1994Program}, flow
\cite{dvanhorn:Jones:1981:LambdaFlow}, or shape analysis
\cite{dvanhorn:Chase1990Analysis}, and the literature is vast. (See
\citet{dvanhorn:hind-paste01,dvanhorn:Midtgaard2012Controlflow} for surveys.)
Much of the research has focused on developing families or frameworks of
analyses that endow the abstraction with a number of knobs, levers, and dials
to tune precision and compute efficiently (some examples include
\citet{dvanhorn:Shivers:1991:CFA, dvanhorn:nielson-nielson-popl97,
dvanhorn:Milanova2005Parameterized, davdar:van-horn:2010:aam}; there are many
more).  These parameters come in various forms with overloaded meanings such as
object- \cite{dvanhorn:Milanova2005Parameterized,
dvanhorn:Smaragdakis2011Pick}, context- \cite{dvanhorn:Sharir:Interprocedural,
dvanhorn:Shivers:1991:CFA}, path- \cite{davdar:das:2002:esp}, and heap-
\cite{davdar:van-horn:2010:aam} sensitivities, or some combination thereof
\cite{dvanhorn:Kastrinis2013Hybrid}.

These various forms can all be cast in the theory of abstraction
interpretation of \citet{dvanhorn:Cousot:1977:AI,
dvanhorn:Cousot1979Systematic} and understood as computable
approximations of an underlying concrete interpreter.  Our work
demonstrates that if this underlying concrete interpreter is written
in monadic style, monad transformers are a useful way to organize and
compose these various kinds of program abstractions in a modular and
language-independent way.  

This work is inspired by the combination of
\citeauthor{dvanhorn:Cousot:1977:AI}'s theory of abstract interpretation based
on Galois connections \citeyearpar{dvanhorn:Cousot:1977:AI,
dvanhorn:Cousot1979Systematic, dvanhorn:Cousot98-5},
\citeauthor{dvanhorn:Liang1995Monad}'s monad transformers for modular
interpreters \citeyearpar{dvanhorn:Liang1995Monad} and
\citeauthor{dvanhorn:Sergey2013Monadic}'s monadic abstract interpreters
\citeyearpar{dvanhorn:Sergey2013Monadic}, and continues in the tradition of
applying monads to programming language semantics pioneered by
\citet{davdar:Moggi:1989:Monads}.

\citet{dvanhorn:Liang1995Monad} first demonstrated how monad transformers could
be used to define building blocks for constructing (concrete) interpreters.
Their interpreter monad \mbox{\(\mathit{InterpM}\)} bears a strong resemblance
to ours.  We show this "building blocks" approach to interpreter construction
extends to \emph{abstract} interpreter construction, too, by using Galois
transfomers.  Moreover, we show that these monad transformers can be proved
sound via a Galois connection to their concrete counterparts, ensuring the
soundness of any stack built from sound blocks of Galois transformers.
Soundness proofs of various forms of analysis are notoriously brittle with
respect to language and analysis features.  A reusable framework of Galois
transformers offers a potential way forward for a modular metatheory of program
analysis.

\citet{dvanhorn:Cousot98-5} develops a "calculational approach" to analysis
design whereby analyses are not designed and then verified \emph{post facto}
but rather derived by positing an abstraction and calculating it through the
concrete interpreter using Galois connections.  These calculations are done by
hand.  Our approach offers a limited ability to automate the calculation
process by relying on monad transformers to combine different abstractions.

\citet{dvanhorn:Sergey2013Monadic} first introduced Monadic Abstract
Interpreters (MAI), in which interpreters are also written in monadic style and
variations in analysis are recovered through new monad implementations.
However, each monad in MAI is designed from scratch for a specific language to
have specific analysis properties.  The MAI work is analogous to monadic
interpreter of \citet{dvanhorn:Wadler1992Essence}, in which the monad structure
is monolithic and must be reconstructed for each new language feature. Our work
extends the ideas in MAI in a way that isolates each parameter to be
independent of others, similar to the approach of
\citet{dvanhorn:Liang1995Monad}.  We factor out the monad as a truly semantics
independent feature.  This factorization reveals an orthogonal tuning knob for
path  and flow sensitivity.  Even more, we give the user building blocks for
constructing monads that are correct and give the desired properties by
construction.  Our framework is also motivated by the needs of reasoning
formally about abstract interpreters, no mention of which is made in MAI.

We build directly on the work of Abstracting Abstract Machines (AAM) by
\citet{davdar:van-horn:2010:aam} in our parameterization of abstract time and
call-site sensitivity. More notably, we follow the AAM philosophy of
instrumenting a concrete semantics _first_ and performing a systematic
abstraction _second_. This greatly simplifies the Galois connection arguments
during systematic abstraction. However, this is at the cost of proving that the
instrumented semantics simulate the original concrete semantics.


# Conclusion

We have shown that \emph{Galois transfomers}, monad transfomers that form
Galois connections, are effective, language-inde\-pendent building blocks for
constructing program analyzers and form the basis of a modular, reusable, and
composable metatheory for program analysis.

In the end, we hope language independent characterizations of analysis
ingredients will both facilate the systematic construction of program analyses
and bridge the gap between various communities which often work in isolation.

-- We use the nondeterminism laws to reason about nondeterminism effects, w
-- `````indent```````````````````````````````````````
-- ‚ä•-zero‚ÇÅ : bind(mzero)(k) = mzero
-- ‚ä•-zero‚ÇÇ : bind(m)(Œª(a).mzero) = mzero
-- ‚ä•-unit‚ÇÅ : mzero ‚ü®+‚ü© m = m
-- ‚ä•-unit‚ÇÇ : m ‚ü®+‚ü© mzero = m 
-- +-assoc : m‚ÇÅ ‚ü®+‚ü© (m‚ÇÇ ‚ü®+‚ü© m‚ÇÉ) = (m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ) ‚ü®+‚ü© m‚ÇÉ
-- +-comm : m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ = m‚ÇÇ ‚ü®+‚ü© m‚ÇÅ
-- +-dist : 
--   bind(m‚ÇÅ ‚ü®+‚ü© m‚ÇÇ)(k) = bind(m‚ÇÅ)(k) ‚ü®+‚ü© bind(m‚ÇÇ)(k)
-- ``````````````````````````````````````````````````

-- `````indent``````````````````````````````````````` 
-- put-put : put(s‚ÇÅ) ; put(s‚ÇÇ) = put(s‚ÇÇ)
-- put-get : put(s) ; get = return(s)
-- get-put : s ‚Üê get ; put(s) = return(1)
-- get-get : s‚ÇÅ ‚Üê get ; s‚ÇÇ ‚Üê get ; k(s‚ÇÅ,s‚ÇÇ) = s ‚Üê get ; k(s,s)
-- ``````````````````````````````````````````````````

-- `\begin{figure}`{.raw}
-- \vspace{-1em}
-- `````align```````````````````````````````````````` 
--     M  : Type ‚Üí Type
-- `````````````````````````````````````````````````` 
-- \caption{Nondeterminism Interface}
-- \label{NondeterminismInterface}
-- \vspace{-1em}
-- `\end{figure}`{.raw}

-- `````align````````````````````````````````````````
-- unit‚ÇÅ :  bind(return(a))(k) = k(a)
-- unit‚ÇÇ :  bind(m)(return) = m
-- assoc :  bind(bind(m)(k‚ÇÅ))(k‚ÇÇ) 
--       =  bind(m)(Œª(a).bind(k‚ÇÅ(a))(k‚ÇÇ))
-- ``````````````````````````````````````````````````

-- --, despite the fruitful results of mapping between
-- langauge paradigms such as the work of \citet{dvanhorn:Might2010Resolving},
-- showing that object-oriented $k$-CFA can be applied to functional
-- languages to avoid the exponential time lower bound
-- \cite{dvanhorn:VanHorn-Mairson:ICFP08}.
