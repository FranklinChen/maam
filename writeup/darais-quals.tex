\documentclass{article}

% Boilerplate {{{

\input{setup.tex}

\title{Abstract Control in Static Analysis (Draft)}
\author{David Darais}
\date{\today}

\begin{document}
\maketitle

% }}}

% Abstract {{{
\begin{abstract}

The field of static analysis offers many techniques for automatically discovering facts about programs.
For example, a static analysis might be used to verify that a program is memory safe, or that it obeys a privacy policy.
Techniques based on abstract interpretation allow the analysis designer to vary some properties of an analysis.
However, features like context, object, and flow sensitivity are often hard-coded into a given analysis framework.
One option for altering such features is to redesign an analysis from scratch.
Unfortunately, designing new analyses is a difficult and error-prone process.
Abstracting Abstract Machines (AAM) is a methodology for building analyses which simplifies this process by adhering to a restricted design philosophy.
However, AAM lacks reusable tools for building analyses, and not all analysis features fit nicely into the framework.

We propose a new framework which gives the analysis designer compositional building blocks for designing analyses, and which supports one key feature missing in AAM: abstract control.
We achieve compositionality by refactoring AAM into monad transformers which can be related back to abstract state machines.
When put together, these monad transformers form analyses which are correct by construction.
Using these building blocks we are able to uncover a new tuning knob for static analyses which we call abstract control.
Abstract control allows one to adjust the flow and path sensitivity of an analysis independent of other design choices.

\end{abstract}
% }}}

\tableofcontents

% Introduction {{{
\section{Introduction}
\label{section:Introduction}

% A static analysis has two components: 
% \begin{itemize}
% \item A \emph{computation} which computes some set of facts about the execution of a program.
% \item A \emph{proof of correctness} about the computation.
% \end{itemize}
% 
% We are motivated by static analysis techniques which are:
% \begin{itemize}
% \item Compartmental: Various aspects of the analysis have been separated from each other and are understood in isolation.
% \item Modular: Design choices in one aspect of the analysis do not restrict design choices of another.  
%       This property is important for both computational and correctness components of an analysis.
% \item Language Agnostic: A given analysis technique can be seamlessly transfered from one semantics to another.
% \item Correct: The proof of correctness should exist, and there should be a framework for establishing it.
% \item Derived: Either the computational artifact or the correctness proof should be obtained "for free" from the other.
% \end{itemize}
% 
% Our framework compartmentalizes:
% \begin{itemize}
% \item Abstract domain a la Cousot.
% \item Abstract time and address a la Van Horn and Might.
% \item Intensional optimizations a la Van Horn and Might. 
% \item Object-sensitivity a la Smaragdakis.
% \item Analysis control properties.
% \end{itemize}
% 
% Our framework is:
% \begin{itemize}
% \item Compartmental: Each of the above concerns are separated and independent.
% \item Modular: Design choices in one axis is completely independent of others
% \item Language Agnostic: All axis other than abstract domain are fully language agnostic.
% \item Correct: A correctness framework is described and each axis is proven correct in isolation.
% \item Derived: The correctness of an analysis using our framework comes for free.
% \end{itemize}
% 
% Analysis control properties are the primary topic of this work.
% We merely note that the other axis in the design space are implemented in our framework using existing techniques.
% 
% Contributions:
% \begin{itemize}
% \item Computational artifacts and correctness proofs for the axis of abstract control, which captures the choice of flow and path sensitivity.
% \item Computational artifacts and correctness proofs for intensional optimizations (gargabe collection and mcfa) independent of abstract control.
% \item Language independent proofs of refinement for flow-sensitivity and path-sensitivity choices using the monadic abstraction.
% \end{itemize}
 
% }}}

% Background {{{
\section{Background}
\label{section:Background}
 
% Notation {{{
\subsection{Notation}
\label{section:Background:Notation}

We use traditional notation for function definitions and applications rather than lambda calculus notation.
For example, we will write:
\begin{equation*}
compose(g, f, x) ‚âî g(f(x))
\end{equation*}
rather than:
\begin{equation*}
compose\; g\; f\; x ‚âî g\; (f\; x)
\end{equation*}

We use lambda notation for anonymous functions.
For example, the anonymous composition function is written:
\begin{equation*}
Œª(g, f, x) ‚Üí g(f(x))
\end{equation*}

% }}}

% Monads {{{
\subsection{Monads}
\label{section:Background:Monads}

A basic familiarity with the concept of monads will be necessary for understanding this paper.
Some find it useful to review the concept of functor before learning about monads. 
We adopt this approach for our brief explanation of monads.

A type $(F : Set ‚Üí Set)$ is called a \emph{functor} if one can:
\begin{itemize}
\item Define $map : ‚àÄ (A, B : Set), (A ‚Üí B) ‚Üí (F(A) ‚Üí F(B))$
\item Prove $map(id) = id$, where $id$ is the identity function $(Œª(x) ‚Üí x)$
\item Prove $map (g ‚àò f) = map(g) ‚àò map(f)$
\end{itemize}

\paragraph{Example:} 
Lists are functors, where $map$ is defined:
\begin{align*}
    map(f)(xs) ‚âî &\case(xs):           \\
          Nil    &‚Üí Nil                \\
         x ‚à∑ xs' &‚Üí f(x) ‚à∑ map(f)(xs') \\
\end{align*}

\paragraph{Example:} $map(isEven)([1, 2, 3, 4]) = [False, True, False, True]$

Likewise a type $(‚Ñ≥  : Set ‚Üí Set)$ is called a \emph{monad} if one can:
\begin{itemize}
\item Define $extend : ‚àÄ (A, B : Set), (A ‚Üí ‚Ñ≥ (B)) ‚Üí (‚Ñ≥ (A) ‚Üí ‚Ñ≥ (B))$
\item Prove unit and associativity laws (not mentioned here).
\end{itemize}
The only difference from the definition of functor is in the the first argument.
For monads, this argument is allowed to be a \emph{monadic} $(A ‚Üí ‚Ñ≥ (B))$, rather than a pure function $(A ‚Üí B)$.

\paragraph{Example:} Lists are monads, where $extend$ is defined:
\begin{align*}
    extend(f)(xs) ‚âî &\case(xs):              \\
                Nil &‚Üí Nil                   \\
            x ‚à∑ xs' &‚Üí f(x) ‚ß∫ extend(f)(xs') \\
\end{align*}

\paragraph{Example:} 
$extend(Œª(x) ‚Üí [x + 1, x - 1])([10, 100]) = [9, 11, 99, 101]$

$extend$ for lists can also be understood as $concat$ followed by $map$:
\paragraph{Example:} 
\begin{align*}
extend(f)([10, 100]) &= concat(map(f)([10, 100]))    \\
                     &= concat([[9, 11], [99, 101]]) \\
                     &= [9, 11, 99, 101]             \\
\end{align*}
For all monads, it is equivalent to define $return$, $map$ and $join$, where:
\begin{equation*}
join : ‚àÄ (A : Set), ‚Ñ≥ (‚Ñ≥ (A)) ‚Üí ‚Ñ≥ (A)
\end{equation*}
As we have just seen, $join$ for the list monad is just $concat$.

% }}}

% Monad Transformers {{{
\subsection{Monad Transformers}
\label{section:Background:MonadTransformers}

Monad transformers are functions between monads.
Where a monad $‚Ñ≥ $ will have type $Set ‚Üí Set$, a monad transformer $ùíØ$ will have type $(Set ‚Üí Set) ‚Üí (Set ‚Üí Set)$.

Monad transformers are used to extend an existing monad to support another effect.
The three monads used in this work are the state monad, powerset monad, and the identity monad.
The state monad is notated $\SM(ùìà)$ (carrying a single cell of type $ùìà$), the powerset monad is notated $\PM$, and the identity is notated $ID$.
The state and powerset monad transformer equivalents are notated $\ST(ùìà)(‚Ñ≥ )$ and $\PT(‚Ñ≥ )$ where $‚Ñ≥ $ is the underlying monad.
The state monad has $get$ and $put$ effects, whereas the powerset monad has a $nondeterminism$ effect.
The transformer versions of both of these monads allow you to combine effects piecewise.

\paragraph{Example:}
$\ST(‚Ñ§)(\PT(ID))$ is a monad which has $get$ and $put$ effects for a single cell of integer state, in addition to nondeterminism effects.

The definitions, details and proofs of all monads used in our work are given in section \ref{section:Proofs}.

% }}}

% Small Step Semantics {{{
\subsection{Small-Step Semantics}
\label{section:Background:SmallStepSemantics}

This work follows the small-step operational approach to language semantics pioneered by Plotkin and Felleisen.
In small-step operational semantics, the meaning of an expression $e$ of a language is given by the transitive closure of some step relation $e ‚Ü¶ e'$.
This yields a state-machine approach to semantics.
Exploring the meaning of $e$ reduces to exploring all possible transitions reachable from $e$ through $‚Ü¶$.
This contrasts to previously developed deontational approaches, where the meaning of $e$ must be given all at once by a denotation function $‚ü¶ e ‚üß$.
This denotation function can quickly demand lots of mathematical machinery.
Small-step operational methods side-step the need for such machinery.

The small-step operation framework supports arbitrary step relations $e ‚Ü¶ e'$.  
However for our purposes $‚Ü¶$ will be always be a function-like form of \emph{decidable} relation, i.e. a multifunction.

% }}}

% Abstract Interpretation {{{
\subsection{Abstract Interpretation}
\label{section:Background:AbstractInterpretation}

Abstract Iterpretation (AI) is a formal framework for program analysis pioneered by Cousot and Cousot.
In the setting of abstract interpretation, a program analysis is just an alternate semantics over an abstract domain.
To distinguish the original semantics from the alternate semantics we call the original semantics the \emph{concrete} semantics.
The alternate semantics is called the \emph{abstract} semantics\footnote{
  This terminology quickly becomes confusing because we will eventually construct an abstract machine for both semantics.
  This yields a concrete abstract machine and an abstract abstract machine. 
  This linguistic pun is exploited mercilessly in the work of Might and Van Horn as they ‚Äúabstract‚Äù abstract abstract machines, yielding abstract abstract abstract machines.
}.

Consider a concrete language $\C$ and a program in that language $(\Ce : \C)$.
In the AI framework, an analysis for $\Ce$ is:
\begin{itemize}
\item 
  An abstract language $\A$.
\item 
  A relationship between $\C$ and $\A$ that defines when some $(\Ce' : \C)$ and $(\Ae' : \A)$ are related.
  This often takes the form of projecting $\A$ to $\PM(\C)$ and using the subset relation.
\item 
  An abstract version of $\Ce$ our concrete program: $(\Ae : \A)$.
\item 
  An abstract version of the $\Csteps$ relation: $(\Asteps : \A √ó \A ‚Üí Prop)$
\item 
  A method to explore every state reachable by $\Ae$ under $\Asteps$.
  This often requires $\A$ to be finite.
\end{itemize}
By convention, we put hats ($\widehat{\;\;}$) on things to name their abstract cousins.
The overall approach is summarized in the following picture:
\input{diagrams/AI.tikz}
This picture takes place at some point in the analysis process.
$\Ce$ is the current program (possibly the result of running the base program for a little while).
$\Ae$ is a valid abstraction of $\Ce$, where this validity is expressed by some relation $R$ holding between $\Ce$ and $\Ae$.
$\Ce'$ is some next state of execution of $\Ce$, and likewise for $\Ae$/$\Ae'$.
In order to be a correct analysis, it must be guaranteed that $\Ce'$ and $\Ae'$ will be related.
The logical structure of the picture, which states the correctness of the analysis, is given by:
\begin{equation*}
‚àÄ (\Ce,\Ce' : \C ) (\Ae,\Ae' : \A), (\Ce R \Ae) ‚àß (\Ce \Csteps \Ce') ‚àß (\Ae \Asteps \Ae') ‚áí  (\Ce' R \Ae')
\end{equation*}
The \emph{meaning} of the analysis is entirely subject to the relation $R$ which relates the abstract to the concrete.

% }}}

% Galois Connections {{{
\subsection{Galois Connections}
\label{section:Background:GaloisConnections}

The AI setting can be elegently simplified and enriched through the use of \emph{galois connections}.
Galois connections serve as a unifying framework for establishing the ‚Äúrelationship between $\C $ and $\A$‚Äù mentioned in the previous section.

A galois connection between two posets (sets with a partial order) $\C$ and $\A$ is notated $\C\galois{Œ±}{Œ≥}\A$ and contains:
\begin{itemize}
\item $(Œ± : \C ‚Üí \A)$ where $Œ±$ is monotonic
\item $(Œ≥ : \A ‚Üí \C )$ where $Œ≥$ is monotonic
\item A proof that $(Œ≥ ‚àò Œ±)$ is expansive: $‚àÄ (x : \C ), x ‚äë Œ≥(Œ±(x))$
\item A proof that $(Œ± ‚àò Œ≥)$ is contractive: $‚àÄ (y : \A), Œ±(Œ≥(y)) ‚äë y$
\end{itemize}
The last two properties can be succinctly stated as $(Œ± ‚àò Œ≥ ‚äë id ‚äë Œ≥ ‚àò Œ±)$\footnote{
  This uses the logical monotonicity relation $f ‚äë g ‚áî  (x ‚äë y ‚áí  f(x) ‚äë g(y))$ for the function space.
}.
Equivalent to all four properties is the property $x ‚äë Œ≥(y) ‚áî  Œ±(x) ‚äë y$.

The expansive property corresponds to \emph{soundness}, and the contractive property corresponds to \emph{tightness}.
A sound analysis gives results you can trust.  
A tight analysis promises to be the ‚Äúbest‚Äù analysis possible.

\paragraph{Example:}
Given a galois connection $\C\galois{Œ±}{Œ≥}\A$, there exists a galois connection $(\C ‚Üí \C)\galois{Œ±'}{Œ≥'}(\A ‚Üí \A)$ where:
\begin{align*}
Œ±'(f : \C ‚Üí \C) &‚âî Œ± ‚àò f ‚àò Œ≥ \\
Œ≥'(g : \A ‚Üí \A) &‚âî Œ≥ ‚àò g ‚àò Œ± \\
\end{align*}

\paragraph{Example:} 
The language $(\PM(‚Ñ§),+,*)$ forms a galois connection with the language $(\PM(\{ EVEN, ODD \}),‚àß,‚à®)$ where:
\begin{align*}
Œ±(zs : \PM(‚Ñ§))               &‚âî ‚ãÉ \{ \{ EVEN  \;|\; ‚àÉ z ‚àà zs ‚àß Even(z) \},  \{ ODD   \;|\; ‚àÉ z ‚àà zs ‚àß Odd(z) \} \} \\
Œ≥(ts : \PM(\{ EVEN, ODD \})) &‚âî ‚ãÉ \{ \{ z ‚àà ‚Ñ§ \;|\; EVEN ‚àà ts ‚àß Even(z) \}, \{ z ‚àà ‚Ñ§ \;|\; ODD ‚àà ts ‚àß Odd(z) \} \} \\
\end{align*}

Galois connections simplify the AI framework by using $x ‚äë Œ≥(y)$ or (equivalently) $Œ±(x) ‚äë y$ as the relation $(x R y)$.
Galois connections are a natural and general way of placing partial orders \emph{on sets themselves}.
$x ‚äë Œ≥(y)$ can be seen as a heterogenous extension of $x ‚äë y$ when $(x : A)$ and $(y : B)$ live in different sets. 
This heterogenous order is given meaning when there exists a galois connection $A\galois{Œ±}{Œ≥}B$.
One can also think of galois connections as something like an isomorphism, but with a weaker round-trip property.
(An isomorphism would require $Œ± ‚àò Œ≥ = id = Œ≥ ‚àò Œ±$.)

Using galois connections, the AI framework introduced in the previous section can be re-stated. In the AI framework, an analysis for $\Ce$ is:
\begin{itemize}
\item 
  An abstract language $\A$.
\item 
  A galois connection $\C\galois{Œ±}{Œ≥}\A$.
\item 
  An abstract version of the $\Csteps$ relation: $(\Asteps : \A √ó \A ‚Üí Prop)$
\item 
  A way to explore every state reachable by $\Ae$ under $\Asteps$.
  This often requires $\A$ to be finite.
\end{itemize}
The overall approach is summarized in the following picture:
\input{diagrams/AIGC.tikz}
As before, the logical structure of the picture is given by:
\begin{equation*}
‚àÄ (\Ce,\Ce' : \C ) (\Ae,\Ae' : \A), (\Ce ‚äë Œ≥(\Ae)) ‚àß (\Ce \Csteps \Ce') ‚àß (\Ae \Asteps \Ae') ‚áí  (\Ce' ‚äë Œ≥(\Ae'))
\end{equation*}
The statement of this property can be simplified further as $\Csteps ‚äë Œ≥(\Asteps)$.
This uses the definition of galois connections for function spaces shown in a previous example.

Using a galois connection $\C\galois{Œ±}{Œ≥}\A$ and abstract step function $\Asteps ‚äë Œ≥(\Csteps)$, the analysis story becomes simplified even further:
\begin{itemize}
\item Translate $(\Ce : \C)$ to $(Œ±(\Ce) : \A)$
\item Explore all abstract states $\Ae'$ states reachable from $Œ±(\Ce)$.
\item All reachable concrete states are summarized by projecting each $Œ≥(\Ae')$ back to $\C$.
\end{itemize}

The galois connection framework simultaneously guarantees the \emph{soundness} and \emph{tightness} of this method.
Soundness tells us that if we abstract, take an abstract step, and then concretize, then the result is an approximation of taking a concrete step.
Soundness tells us that we can trust the results of the analysis.
\input{diagrams/GCSoundness.tikz}
Tightness tells us that if we concretize, take a concrete step, and then abstract, then the result must be just as precise as taking an abstract step.
Tightness tells us that our abstract step function isn't losing precision unnecessarily, and that our abstract step $\Asteps$ is provably as strong as possible.
\input{diagrams/GCTightness.tikz}

% }}}

% CPS {{{
\subsection{Continuation Passing Style}
\label{section:Background:ContinuationPassingStyle}

We use CPS-IF as an example language to demonstrate the benefits of our framework.
CPS is a syntactically restricted version of the lambda calculus.
CPS-IF is an extension of CPS with conditionals.
We choose CPS because the state machine for the semantics of CPS requires no call stack.
We add conditionals to make things slightly more interesting.

We define the CPS-IF language as follows:
\input{snips/CPS-IF.tex}

CPS-IF supports integer and boolean literals, addition and subtraction by 1, and testing if an integer is greater than or equal to zero.
The essence of CPS is in the syntactic restriction on application forms $a(a)$ and $a(a,a)$.  
Because $a$ cannot be a nested call expression, evaluating a $Call$ requires no evaluation stack.

All lambda calculus terms can be translated to CPS terms through CPS-conversion.
However, because lambda calculus terms are much easier to read, we will use lambda calculus terms for examples.
We display the CPS-converted version of examples where appropriate.

% }}}

% Control Flow Analysis {{{
\subsection{Control Flow Analysis}
\label{section:Background:ControlFlowAnalysis}

Control flow analysis is a class of analysis which is particularly important for higher-order languages.
In non-higher-order languages, it is useful to distinguish control-flow from data-flow.
The control flow of the program is a graph of what functions are called from where.
The data flow of a program is a mapping of which values can flow to which variables.
Traditionally one performs a control-flow analysis first, to find out which functions are called, and a data-flow analysis second, using the results of the control flow analysis.

In higher-order languages, data-flow and control-flow are tightly coupled.
Before you can tell which functions will be called, you need to know how values flow, because functions are themselves values.

We note that the distinction between ‚Äúhigher-order‚Äù languages and ‚Äúnon-higher-order‚Äù languages is a red herring.
Functions can be passed as values in C using function pointers, and object-oriented languages enjoy a similar circularity between control- and data- flow due to method dispatch.
You can read these statements as saying ‚Äúall languages are higher order, and thus all languages need higher order control flow analysis‚Äù.
Or you can read them as saying ‚Äúall languages are higher order, and we've done just fine without higher oder control flow analysis so far‚Äù.
The real distinction is in the code that you end up analysing.

We build on the tradition of control flow analysis (CFA) pioneered by Shivers, as well as recent refinements of CFA developed by Might and Van Horn.
In this tradition, the result of a control flow analysis is closer to what one would think of as a data-flow analysis, only the process accounts for higher order flow.
0CFA, the most basic control flow analysis, merely computes the set of values which might flow to a particular variable.
kCFA is a suite of context sensitive extensions to 0CFA for which functions are analyzed separately for each possible calling context.
We use 0CFA as the example analysis in this paper.
However our framework, and our implementation of it, scale to the full range of context sensitive control flow analyses.

% }}}

% }}}

% Monadic AAM {{{

\section{Monadic AAM}
\label{section:MonadicAAM}

Monadic abstract interpretation[Sergey et al. PLDI 2013] demonstrated that abstract interpreters can be built modularly using a monadic abstraction.
We build directly on this work at the level of intuition‚Äîmonads serve as our pivot-point for achieving modularity.
However, in our pursuit of a modular correctness framework, our approach deviates greatly from prior work in the specific interfaces used.

First we demonstrate a simple 0CFA analysis on CPS-IF which doesn't use our framework.
The CPS-IF language is introduced in section \ref{section:Background:ContinuationPassingStyle}.
We repeat the definition here for convenience.
\input{snips/CPS-IF.tex}

Our abstract semantics of 0CFA will track literals (including lambdas) that appear in the program text.
For integers that do not appear in the program text, the analysis uses a single token $INT$ which conservatively approximates any possible integer.
Formally, the state space $Œ£$ for the abstract machine of the abstract semantics is defined as:
\begin{align*}
v : \AVal   &‚©¥ \INT \;|\; l \;|\; \lam(x) ‚Üí c \;|\; \lam(x,k) ‚Üí c \\
œÉ : \AStore &‚âî Var ‚Üí \PM(\AVal)                                   \\
Œ£           &‚âî \PM(Call √ó \AStore)                                \\
\end{align*}
Because there are a finite many literals in the program text, we can claim there are a finite number of possible abstract values.

The abstract semantics for $Œ£$ comes in two parts.  
First we define a \emph{denotation function} $ùíú $ for $Atom$ expressions.
\begin{align*}
ùíú                            &: \AStore √ó Atom ‚Üí \PM(\AVal) \\
ùíú (œÉ,x)                      &‚âî œÉ(x)                        \\
ùíú (œÉ,l)                      &‚âî \{ l \}                     \\
ùíú (œÉ,\add a) | ùíú (œÉ,a) ‚äë INT &‚âî \{ \INT \}                  \\
ùíú (œÉ,\sub a) | ùíú (œÉ,a) ‚äë INT &‚âî \{ \INT \}                  \\
ùíú (œÉ,\gez a) | ùíú (œÉ,a) ‚äë INT &‚âî \{ \TRUE , \FALSE \}        \\
ùíú (œÉ,\lam(x) ‚Üí c)            &‚âî \{ \lam(x) ‚Üí c \}           \\
ùíú (œÉ,\lam(x)(k) ‚Üí c)         &‚âî \{ \lam(x)(k) ‚Üí c \}        \\
\end{align*}

Second we define a \emph{step relation} (as a function) $ùíû$ for $Call$ expressions.
\begin{align*}
ùíû                        : &Call √ó \AStore ‚Üí \PM(Call √ó \AStore)                                              \\
ùíû(\iif(a)\{c‚ÇÅ\}\{c‚ÇÇ\},œÉ) ‚âî &\{ (c,œÉ)                                                                          \\
                           &|\; c ‚àà ‚ãÉ \{ \{ c‚ÇÅ \;|\; \TRUE ‚àà ùíú (œÉ,a) \}, \{ c‚ÇÇ \;|\; \FALSE ‚àà ùíú (œÉ,a) \} \} \\
                           &\}                                                                                \\
ùíû(a‚ÇÅ(a‚ÇÇ,a‚ÇÉ),œÉ)           ‚âî &\{ (c,œÉ')                                                                         \\
                           &|\; (\lam(x)(k) ‚Üí c) ‚àà ùíú (œÉ,a‚ÇÅ)                                                   \\
                           &|\;             v‚ÇÇ ‚àà ùíú (œÉ,a‚ÇÇ)                                                     \\
                           &|\;             v‚ÇÉ ‚àà ùíú (œÉ,a‚ÇÉ)                                                     \\
                           &|\;             œÉ' ‚âî œÉ ‚äî [x ‚Ü¶ v‚ÇÇ] ‚äî [k ‚Ü¶ v‚ÇÉ]                                      \\
                           &\}                                                                                \\
ùíû(\halt(a),œÉ)            ‚âî &\{ (\halt(a),œÉ) \}                                                                \\
\end{align*}
(We omit the $(a‚ÇÅ(a‚ÇÇ))$ case. It is directly analogous to $(a‚ÇÅ(a‚ÇÇ,a‚ÇÉ))$).

The complete analysis of a program $c$ is defined as the least fixed point of a \emph{collection semantics} for the relation $ùíû$:
\begin{align*}
\text{analysis} ‚âî Œº(Œ£) ‚Üí \{(c,‚ä•)\} ‚äî ùíû^{‚ãÜ}(Œ£)
\end{align*}
where
\begin{align*}
ùíû^{‚ãÜ}    &: \PM(Call √ó \AStore) ‚Üí \PM(Call √ó \AStore) \\
ùíû^{‚ãÜ}(Œ£) &‚âî ‚ãÉ \{ ùíû(c,œÉ) | (c,œÉ) ‚àà Œ£ \}                  \\
\end{align*}
The collecting semantics tracks all states that the program could be in rather than just the final states.

The first insight in monadic static analysis is to abbreviate the definitions of $ùíú $ and $ùíû$ using a monad.
At this point, the monad ‚Äútrick‚Äù is nothing more than a technique to simplify the definition of $ùíú $ and $ùíû$.
This simplification is similar to how a functional programmer would use a state monad in place of state passing style.

We wll use a powerset monad and state monad transformer to write the analysis in monadic style.
The full definitions of the monads (and their proofs) used throughout this paper are defered to section \ref{section:Proofs}.
Because monad transformers are just fancy names for simple types, we write the equivalent simple type underneath definitions which reference monad transformer.
The monadic conversion of the above analysis is as follows.
\begin{align*}
‚Ñ≥     &: Set ‚Üí Set                  \\
‚Ñ≥ (a) &‚âî \ST(\AStore)(\PM)(a)       \\
‚Ñ≥ (a) &‚âî \AStore ‚Üí \PM(a √ó \AStore) \\
\end{align*}

\begin{align*}
ùíú                &: Atom ‚Üí ‚Ñ≥ (\PM(\AVal))                    \\
ùíú (x)            &‚âî \ddo                                     \\
                 &œÉ ‚Üê \getstore                              \\
                 &\return(œÉ(x))                               \\
ùíú (l)            &‚âî \return(\{l\})                              \\
ùíú ‚Çò(add1(a))     &‚âî \ddo                                       \\
                 &v ‚Üê ùíú (a)                                  \\
                 &\return(\{\INT \;|\; ‚àÉ i ‚äë \INT ‚àà v\})              \\
ùíú ‚Çò(sub1(a))     &‚âî \ddo                                       \\
                 &v ‚Üê ùíú (a)                                  \\
                 &\return(\{\INT \;|\; ‚àÉ i ‚äë \INT ‚àà v\})              \\
ùíú ‚Çò(gez(a))      &‚âî \ddo                                       \\
                 &v ‚Üê ùíú (a)                                  \\
                 &\return(\{\TRUE, \FALSE \;|\; ‚àÉ i ‚äë \INT ‚àà v\})      \\
ùíú ‚Çò(\lam(x)(k) ‚Üí c) &‚âî \return(\{\lam(x)(k) ‚Üí c\})                    \\
\end{align*}

\begin{align*}
ùíû                 &: Call ‚Üí ‚Ñ≥ (Call)                         \\
ùíû (\iif(a)\{c‚ÇÅ\}\{c‚ÇÇ\}) &‚âî \ddo                                      \\
                  &vP ‚Üê ùíú (a)                                \\
                  &v ‚Üê \liftpowerset(vP)                           \\
                  &b ‚Üê \coercebool(v)                            \\
                  &\return(\{ \text{if}\; b\; \text{then}\; c‚ÇÅ\; \text{else}\; c‚ÇÇ \}) \\
ùíû‚Çò(a‚ÇÅ(a‚ÇÇ,a‚ÇÉ))     &‚âî \ddo                                      \\
                  &vP ‚Üê ùíú (a‚ÇÅ)                               \\
                  &v ‚Üê \liftpowerset(vP)                           \\
                  &(\lam(x)(k) ‚Üí c) ‚Üê \coercefun(v)               \\
                  &vP‚ÇÇ ‚Üê ùíú (a‚ÇÇ)                              \\
                  &vP‚ÇÉ ‚Üê ùíú (a‚ÇÉ)                              \\
                  &v‚ÇÇ ‚Üê \liftpowerset(vP‚ÇÇ)                         \\
                  &v‚ÇÉ ‚Üê \liftpowerset(vP‚ÇÉ)                         \\
                  &\modifystore(Œª(œÉ) ‚Üí œÉ ‚äî [x ‚Ü¶ v‚ÇÇ] ‚äî [k ‚Ü¶ v‚ÇÉ]) \\
                  &\return(c)                                    \\
\end{align*}

The monadic abstraction provides a nice way to simplify the implementation of the analysis.  
In particular, cases which do not modify the store or only return one result.
Both of these cases are instances of having "no effect", and they need not mentioned all members of the state machine.  
(This was observed in Sergey et. al. PLDI 2013.)

As before, we must complete the analysis by building an abstract machine transition function:
\begin{align*}
ùíû^{‚ãÜ}    &: \PM(Call √ó \AStore) ‚Üí \PM(Call √ó \AStore) \\
ùíû^{‚ãÜ}(Œ£) &‚âî ‚ãÉ \{ ùíû(c)(œÉ) \;|\; (c,œÉ) ‚àà Œ£ \}             \\
\end{align*}

Our current definition of $‚Ñ≥ $ used recovers exactly the analysis we wrote before.
On top of the convenience of writing things monadically, our insight and contribution is twofold:
\begin{itemize}
\item $‚Ñ≥ $ can be \emph{axiomatized}, such that different definitions for $‚Ñ≥ $ give rise to different control abstractions for the analysis.
\item The monadic abstraction provides for a modular proof framework for establishing the correctness of the analysis.
\end{itemize}

% }}}

% Abstract Control {{{
\section{Abstract Control}
\label{section:AbstractControl}

The current instantiation of ‚Ñ≥  yields a flow-sensitive path-sensitive analysis.  
Consider a reordering of the powerset\footnote{
  The definition of $\PT$ we use is non-traditional.  However, our definition
  for $\PT$ is actually a monad, whereas traditional definitions are not.  Our
  definition and proofs for $\PT$ are given in section \ref{section:Proofs}.
}
and state monad transformers:
\begin{align*}
‚Ñ≥     &: Set ‚Üí Set                  \\
‚Ñ≥ (a) &‚âî \PT(\SM(\AStore))(a)       \\
‚Ñ≥ (a) &‚âî \AStore ‚Üí \PM(a) √ó \AStore \\
\end{align*}

As before, we must convert between monadic actions and abstract state space transitions to achieve an analysis:
\begin{align*}
ùíû^{‚ãÜ}       &: \PM(Call) √ó \AStore ‚Üí \PM(Call) √ó \AStore                                         \\
ùíû^{‚ãÜ}(cP,œÉ) &‚âî (\{ c' \;|\; c' ‚àà œÄ‚ÇÅ(ùíû(c))(œÉ) \;|\; c ‚àà c\PM \}, ‚ãÉ \{ œÄ‚ÇÇ(ùíû(c))(œÉ) \;|\; c ‚àà cP \}) \\
\end{align*}
This instantiation of $‚Ñ≥ $ and $ùíû*$ yields a flow-insensitive analysis.

For the same monad $‚Ñ≥ $, we can change the definition of $ùíû*$ to achieve a flow-sensitive path-insensitive analysis:
\begin{align*}
ùíû^{‚ãÜ}    &: \PM(Call √ó \AStore) ‚Üí \PM(Call √ó \AStore)             \\
ùíû^{‚ãÜ}(Œ£) &‚âî \{ (c',œÄ‚ÇÇ(ùíû(c))(œÉ)) \;|\; c' ‚àà œÄ‚ÇÅ(ùíû(c))(œÉ) \;|\; (c,œÉ) ‚àà Œ£ \} \\
\end{align*}

In the correctness framework, both the flow-sensitive path-sensitive analysis and flow-insensitive analyses are justified through isomorphisms between monadic actions and abstract state space transitions.  
The flow-sensitive path-insensitive variant is recovered by weakening this isomorphism to a galois connection.

% }}}

% Intensional Optimizations {{{

\section{Intensional Optimizations}
\label{section:IntensionalOptimizations}

Up to this point we have factored the abstract control properties of static analysis behind a common interface.  
Now we show how to implement two intentional optimizations, abstract garbage collection and mcfa, in a completely general setting.

\paragraph{Abstract Garbage Collection}
Abstract garbage collection is a technique in abstract interpretation where unreachable abstract addresses are pruned from the state space.
This is analagous to ‚Äúreal‚Äù garbage collection, where unreachable pointers are reclaimed for space efficiency.
However, in abstract semantics, addresses are \emph{re-used} to soundly and finitely aproximate an infinite address space.
Impreceision in control flow analyses arise when an abstract address present in the current store must be used for allocation.
Abstract garbage collection is a purely precision and performance improving optimization which removes unreachable abstract addresses.

For a generic implementation of garbage collection we assume an arbitrary $‚Ñ≥ $ that has $get$, $put$ and nondeterminism effects.
Using this axiomatized interface for $‚Ñ≥ $, abstract garbage collection can be implemented once in a purely generic way.
\begin{align*}
gc    &: Call ‚Üí ‚Ñ≥ (1)                                        \\
gc(c) &‚âî \ddo                                                  \\
      &œÉ ‚Üê \getstore                                             \\
      &ùìâ‚ÇÄ ‚Üê \touchedcall(c)                                           \\
      &\llet ùìâ ‚âî Œº(ùìâ) ‚Üí ùìâ ‚äî \touchedvar(ùìâ)                           \\
      &\modifystore (Œª(œÉ) ‚Üí ‚ãÉ \{ [x ‚Ü¶ v] | x ‚àà ùìâ ‚àß œÉ(x) = v \} ) \\
\end{align*}
This is literally the implementation of \emph{concrete} garbage collection.
However, because we have not yet committed to the underlying monad, it seamlessly becomes abstract garbage collection when instantiated with the appropriate monad.

\paragraph{MCFA}
MCFA is an optimization that improves the asymptotic complexity of context-sensitive control flow analyses.
kCFA explodes exponentially for $k > 0$ in functional analyses, causing extremely poor analysis performance in the worst case.
However, an apparent paradox was discovered as kCFA was proven to be polynomial in the worst case for object-oriented programs.
MCFA resolved the paradox by identifying the difference in analyses and transfering the polynomial behavior to functional analysis.
The key insight of MCFA is to use packed, copied closures rather than linked closures in the abstract semantics.

So far our analysis has not used closures for abstract values; 0CFA only tracks lambdas without their closing context.
Adding closures to abstract values is a straightforward addition to the examples we've shown.
(Our implementation implements all of these features in full.)

The mcfa optimization of copying rather than linking closures similarly enjoys a fully generic implementation:
\begin{align*}
  œÅ : Env  &‚âî  Var ‚áÄ \widehat{Addr}                       \\
clo : Clo  &‚©¥ <\lam(x) ‚Üí c, œÅ> \;|\; <\lam(x,k) ‚Üí c, œÅ>   \\
\end{align*}

\begin{align*}
clo-copy    &: Lam ‚Üí ‚Ñ≥ (Clo)                               \\
clo-copy(l) &‚âî \ddo                                        \\
            &\llet ys ‚âî \operatorname{free-vars}(l)        \\
            &vs ‚Üê map^{‚ãÜ}(lookup)(ys)                      \\
            &œÅ ‚Üê \{ y ‚Ü¶^{‚ãÜ} v \;|\; (y,v) ‚àà zip(ys, vs) \} \\
            &\return (l,œÅ)                                 \\
\end{align*}

Using existing techniques, these optimizations would need to be both implemented and proven correct for each instantiation of abstract control.
Our generalization over abstract control allows us to implement each of these optimizations once.
More importantly, the correctness of these optimizations can be established generically as well.

% }}}

% Correctness Framework {{{

\section{Correctness}
\label{section:Correctness}

The key advantage to our framework is that the proofs of correctness for constructed analyses are derived automatically.
To establish the correctness of the monadic approach, we do not merely inline the definitions and resort to reasoning about fully instantiated instances of monadic definitions.
Instead, we relate monadic actions directly to abstract state space transitions for each monad transformer combination.
Given these proofs, along with an argument about monotonicity of the monadic semantics, we can establish a proof of galois connection for any given interpreter instantiation.

To relate back to small step semantics, we establish a galois connection between monadic actions in $‚Ñ≥ $ and transitions functions for \emph{some} abstract state space $ùíÆùíÆ$.
This abstract state space is constructed from the monad transformer stack, although some transformer stacks support multiple abstract state spaces.
This property is notated $(A ‚Üí ‚Ñ≥ (B))\galois{Œ±}{\gamma}(ùíÆùíÆ(A) ‚Üí ùíÆùíÆ(B))$.
We call a particular monad $‚Ñ≥ $ which enjoys this property a \emph{small-step monad}.
Likewise, we call a monad transformer $ùíØ$ which enjoys \emph{transports} this property a \emph{small-step monad transformer}.

In our framework we prove that not only are $\ST$ and $\PT$ monad transformers, they're small-step monad transformers.
This means that for any stack of interleaving $\ST$ and $\PT$ monad transformers, one can construct the necessary galois connection back to small step semantics.

We prove that $\ST(ùìà)(\PM) ‚äë \PT(\SM(ùìà))$.
These monad interleavings correspond to path-sensitivity and path-insensitivity respectively.

For the $\PT(\SM(ùìà))$ monad, we show two galois connections are possible to the state space $\PM(\_ √ó ùìà)$.
These choices for galois connection correspond to flow-sensitivity and flow-insensitivity respectively.

Independent of language or application we have proven:
\begin{align*}
flow-insensitive ‚äë flow-sensitive path-insensitive ‚äë flow-sensitive 
\end{align*}

A given concrete semantics will always use the flow-sensitive path-sensitive monad.
We can use this bridge to construct a galois connection between concrete and a flow-insensitive abstract semantics.

When using our framework, the analysis designer need only prove prove:
\begin{itemize}
\item The semantic step function $ùíû$ is monotonic.
\item The semantics as written, including intensional optimizations, are correct.
\end{itemize}
After supplying these proofs, the analysis designer enjoys:
\begin{itemize}
\item An automatically derived analysis for their language with their choice of abstract control.
\item A proof-by-construction of galois connection (soundness and tightness) for the derived analysis.
\item Seamless extensions to AAM and intensional optimizations (like gc or mcfa), which we demonstrate in our implementation.
\end{itemize}

Our proof technique is maximally modular in that new monads can be composed seamlessly into the framework with disruption.
This modularity greatly reduces the proof burden on the analysis designer as new languages and analyses are developed.

In practice, there will be many more state space components, like abstract time and abstract address in the AAM framework.
To add these features, the analysis designer need only stack more state space monads together to augment the resulting abstract state machine.
However, once monotonicity of the $ùíû$ action is established, both concrete and abstract interpreters can be derived for free.
This is only possible because all proofs have been decomposed to the unit of monad transformer, and these extensions reduce to just adding more transformers to the stack.

% }}}

% Proofs {{{

\section{Proofs}
\label{section:Proofs}

% Basic Definitions {{{
\subsection{Basic Definitions}
\label{section:Proofs:BasicDefinitions}

\begin{definition}
For a type $(A : Set)$, a \emph{partial order} structure on $A$ contains an operator:
\begin{align*}
\_‚äë\_ : A ‚Üí A ‚Üí Prop
\end{align*}
which respect the following properties:
\begin{align*}
 \operatorname{reflexivity} &: x ‚äë x                   \\
\operatorname{antisymmetry} &: x ‚äë y ‚áí  y ‚äë x ‚áí  x = y \\
\operatorname{transitivity} &: x ‚äë y ‚áí  y ‚äë z ‚áí  x ‚äë z \\
\end{align*}
\end{definition}

\begin{definition}
For types $(A, B : Set)$ which both have partial orders, a function $(f : A ‚Üí B)$ is called \emph{monotonic} if:
\begin{align*}
‚àÄ (x, y : A), x ‚äë y ‚áí  f(x) ‚äë f(y)
\end{align*}
\end{definition}

\begin{lemma}
For types $(A, B : Set)$ which both have partial orders, there exists a partial order on the \emph{monotonic} function space $(A ‚Üí^{mon} B : Set)$ with operator:
\begin{align*}
f ‚äë g ‚âî ‚àÄ (x, y : A), x ‚äë y ‚Üí f(x) ‚äë g(y)
\end{align*}
\begin{proof}
Reflexivity is justified by monotonicity.  
Antisymmetry and transitivity are justified through the partial orders on $A$ and $B$.
\end{proof}
\end{lemma}

\begin{definition}
For types $(C, A : Set)$ which both have partial orders, a \emph{galois connection} between $C$ and $A$, written $C\galois{Œ±}{Œ≥}A$, contains two operators:
\begin{align*}
Œ± &: C ‚Üí A \\
Œ≥ &: A ‚Üí C \\
\end{align*}
which respect the following properties:
\begin{align*}
                           &Œ± \text{is monotonic} \\
                           &Œ≥ \text{is monotonic} \\
\operatorname{contractive} &: Œ± ‚àò Œ≥ ‚äë id          \\
  \operatorname{expansive} &: id ‚äë Œ≥ ‚àò Œ±          \\
\end{align*}
\end{definition}

\begin{definition}
For a type $(A : Set)$, we call $A$ a \emph{join semilattice}, written $JoinSemilattice(A)$, if one can define two operators:
\begin{align*}
    ‚ä• &: A         \\
\_‚äî\_ &: A ‚Üí A ‚Üí A \\
\end{align*}
which respect the following properties:
\begin{align*}
    \operatorname{left-unit} &: ‚ä• ‚äî x = x                  \\
   \operatorname{right-unit} &: x ‚äî bot = x                \\
\operatorname{associativity} &: x ‚äî (y ‚äî z) = (x ‚äî y) ‚äî z  \\
\operatorname{commutativity} &: x ‚äî y = y ‚äî x              \\
\end{align*}
\end{definition}

\begin{definition}
For a type $(F : Set ‚Üí Set)$, we call $F$ a \emph{functor}, written $Functor(F)$, if one can define the operator:
\begin{align*}
\operatorname{map} : ‚àÄ (A , B : Set), (A ‚Üí B) ‚Üí (F(A) ‚Üí F(B))
\end{align*}
which respects the following properties:
\begin{align*}
          unit &: map(id) = id                  \\
distributivity &: map(g ‚àò f) = map(g) ‚àò map(f)  \\
\end{align*}
\end{definition}

\begin{definition}
For a type $(‚Ñ≥  : Set ‚Üí Set)$, we call $‚Ñ≥ $ a \emph{monad}, written $Monad(‚Ñ≥ )$, if one can define two operators:
\begin{align*}
\operatorname{return} &: ‚àÄ (A : Set), A ‚Üí ‚Ñ≥ (A)                          \\
\operatorname{extend} &: ‚àÄ (A, B : Set), (A ‚Üí ‚Ñ≥ (B)) ‚Üí (‚Ñ≥ (A) ‚Üí (‚Ñ≥ (B))) \\
\end{align*}
which respect the following properties:
\begin{align*}
    \operatorname{left-unit} &: extend(return) = id                               \\
   \operatorname{right-unit} &: extend(k) ‚àò return = k                            \\
\operatorname{associativity} &: extend(k‚ÇÇ) ‚àò extend(k‚ÇÅ) = extend(extend(k‚ÇÇ) ‚àò k‚ÇÅ) \\
\end{align*}
\end{definition}

\begin{corrolary}
All monads are functors.
\end{corrolary}

\begin{definition}
For a type $(ùíØ : (Set ‚Üí Set) ‚Üí (Set ‚Üí Set))$, we call $ùíØ$ a \emph{monad transformer}, written $Transformer(ùíØ)$, if one can define a single operator:
\begin{align*}
lift : ‚àÄ (‚Ñ≥  : Set ‚Üí Set) (A : Set), ‚Ñ≥ (A) ‚Üí ùíØ(‚Ñ≥ )(A)
\end{align*}
and the following property holds:
\begin{align*}
‚àÄ (‚Ñ≥  : Set ‚Üí Set), Monad(‚Ñ≥ ) ‚áí  Monad(ùíØ(‚Ñ≥ ))
\end{align*}
\end{definition}

\begin{definition}
For types $(ùìà : Set)$ and $(‚Ñ≥  : Set ‚Üí Set)$, we call $‚Ñ≥ $ a \emph{monad state over $ùìà$}, written $MonadState(ùìà)(‚Ñ≥ )$, if one can define operators:
\begin{align*}
\operatorname{get} &: ‚Ñ≥ (ùìà)     \\
\operatorname{put} &: ùìà ‚Üí ‚Ñ≥ (1) \\
\end{align*}
\end{definition}

\begin{definition}
For a type $(‚Ñ≥  : Set ‚Üí Set)$, we call $‚Ñ≥ $ a \emph{monad plus}, written $MonadPlus(‚Ñ≥ )$, if the following property holds:
\begin{align*}
‚àÄ (A : Set), JoinSemilattice(‚Ñ≥ (A))
\end{align*}
and the following additional properties hold:
\begin{align*}
     \operatorname{left-zero} &: extend(k)(‚ä•) = ‚ä•                               \\
    \operatorname{right-zero} &: extend(const(‚ä•))(x) = ‚ä•                        \\
\operatorname{distributivity} &: extend(k)(x ‚äî y) = extend(k)(x) ‚äî extend(k)(y) \\
\end{align*}
\end{definition}

\begin{definition}
For types $(‚Ñ≥  , ùíÆùíÆ : Set ‚Üí Set)$, we call $‚Ñ≥ $ a \emph{small step monad with state space $ùíÆùíÆ$}, written $MonadSmallStep(ùíÆùíÆ)(‚Ñ≥ )$, if one can define:
\begin{align*}
‚àÄ (A, B : Set), (A ‚Üí ‚Ñ≥ (B)) \galois{Œ±}{Œ≥} (ùíÆùíÆ(A) ‚Üí ùíÆùíÆ(B))
\end{align*}
\end{definition}

\begin{definition}
For a type $(F : Set ‚Üí Set)$ and property $(P : Set ‚Üí Prop)$, we call $F$ \emph{functorial in $P$}, written $Functorial(P)(F)$, if the following property holds:
\begin{align*}
‚àÄ (A : Set), P(A) ‚áí P (F(A))
\end{align*}
and all operations in $P$ distribute through monadic operations in $F$.
\end{definition}

\begin{example}
For a type $(F : Set ‚Üí Set)$ to be \emph{functorial in $JoinSemilattice$}, the following additional laws must hold:
\begin{align*}
return (x ‚äî y) = return(x) ‚äî return(y)
\end{align*}
\end{example}

% }}}

% ID {{{
\subsection{ID}
\label{section:Proofs:ID}

\begin{definition}
The \emph{identity monad}, written $ID$, is defined:
\begin{align*}
   ID &: Set ‚Üí Set \\
ID(A) &‚âî A         \\
\end{align*}
\end{definition}

\begin{lemma}
The identity monad is a monad with operators:
\begin{align*}
return &‚âî id \\
extend &‚âî id \\
\end{align*}
\begin{proof}
Unit and associativity laws are established trivially by definition.
\end{proof}
\end{lemma}

\begin{lemma}
The identity monad is \emph{functorial in all structures}.
\begin{proof}
Holds by definition of $ID$.
\end{proof}
\end{lemma}

% }}}

% SetT {{{
\subsection{$\PT$}
\label{section:Proofs:SetT}

\begin{definition}
The \emph{set monad transformer}, written $\PT$, is defined:
\begin{align*}
\PT(‚Ñ≥ )(A) ‚âî ‚Ñ≥ (\PM(A))
\end{align*}
\end{definition}

\begin{lemma}
For a given $(‚Ñ≥  : Set ‚Üí Set)$ where:
\begin{itemize}
\item $‚Ñ≥ $ is a monad.
\item $‚Ñ≥ $ is functorial in JoinSemilattice.
\end{itemize}
then $\PT(‚Ñ≥ )$ is a monad plus.
\begin{proof}
By applying functoriality of $‚Ñ≥ $ to the semilattice $\PM$.
\end{proof}
\end{lemma}

\begin{lemma}
For a given $(‚Ñ≥  : Set ‚Üí Set)$ where:
\begin{itemize}
\item $‚Ñ≥ $ is a monad.
\item $‚Ñ≥ $ is functorial in JoinSemilattice.
\end{itemize}
then $\PT(‚Ñ≥ )$ is a monad with operators:
\begin{align*}
   return &‚âî return_{‚Ñ≥ } ‚àò singleton \\
extend(k) &‚âî extend_{‚Ñ≥ }(joins ‚àò map_{\PM}(k))  \\
\end{align*}
\begin{proof} of left unit.
\begin{align*}
\operatorname{left-unit} &: extend(return) = id                                                                                        \\
                                                                                                                                       \\
extend(return) &= extend_{‚Ñ≥ }(joins ‚àò map_{\PM}(return_{‚Ñ≥ } ‚àò singleton_{\PM}))            \tag{definition of extend and join}         \\
               &= extend_{‚Ñ≥ }(Œª(xs) ‚Üí ‚ãÉ \{ return_{‚Ñ≥ } (singleton_{\PM}(x)) \;|\; x ‚àà xs \}) \tag{definition of joins}                 \\
               &= extend_{‚Ñ≥ }(Œª(xs) ‚Üí return_{‚Ñ≥ } (‚ãÉ \{ singleton_{\PM}(x) \;|\; x ‚àà xs \})) \tag{functorality of semilattice in $‚Ñ≥ $} \\
               &= extend_{‚Ñ≥ }(Œª(xs) ‚Üí return_{‚Ñ≥ }(xs))                                       \tag{join identity for $\PM$}             \\
               &= extend_{‚Ñ≥ }(return_{‚Ñ≥ })                                                 \tag{Œ∑ reduction for Œª}                     \\
               &= id                                                                       \tag{left unit monad law for $‚Ñ≥ $}          \\
\end{align*}
\end{proof}
\begin{proof} of right unit.
\begin{align*}
\operatorname{right-unit} &: extend(k)(return(x)) = k(x)                                                                                 \\
                                                                                                                                         \\
extend(k)(return(x)) &= extend_{‚Ñ≥ }(joins ‚àò map_{\PM}(k))(return_{‚Ñ≥ }(singleton_{\PM}(x))) \tag{definition of extend and join}           \\
                     &= joins(map_{\PM}(k)(return_{‚Ñ≥ }(singleton_{\PM}(x))))               \tag{right unit monad law for $‚Ñ≥ $}           \\
                     &= joins(return_{‚Ñ≥ }(singleton_{\PM}(k(x))))                          \tag{map distribution law for $‚Ñ≥ $ and $\PM$} \\
                     &= k(x)                                                               \tag{definition of joins}                     \\
\end{align*}
\end{proof}
\begin{proof} of associativity.
\begin{align*}
\operatorname{associativity} &: extend(k‚ÇÇ) ‚àò extend(k‚ÇÅ) = extend(extend(k‚ÇÇ) ‚àò k‚ÇÅ)                                                              \\
                                                                                                                                               \\
extend(k‚ÇÇ)‚àò extend(k‚ÇÅ) &= extend_{‚Ñ≥ }(joins ‚àò map_{\PM}(k‚ÇÇ)) ‚àò extend_{‚Ñ≥ }(joins ‚àò map_{\PM}(k‚ÇÅ)) \tag{definition of $extend$}                 \\
                       &= extend_{‚Ñ≥ }(extend_{‚Ñ≥ }(joins ‚àò map_{\PM}(k‚ÇÇ)) ‚àò joins ‚àò map_{\PM}(k‚ÇÅ)) \tag{associativity law for $‚Ñ≥ $}             \\
                       &= extend_{‚Ñ≥ }(extend(k‚ÇÇ) ‚àò joins ‚àò map_{\PM}(k‚ÇÅ))                         \tag{definition of $extend$}                 \\
                       &= extend_{‚Ñ≥ }(Œª(xs) ‚Üí extend(k‚ÇÇ) (‚ãÉ \{ k‚ÇÅ(x) \;|\; x ‚àà xs\}))             \tag{definitions of $joins$ and $map_{\PM}$} \\
                       &= extend_{‚Ñ≥ }(Œª(xs) ‚Üí ‚ãÉ \{ extend(k‚ÇÇ)(k‚ÇÅ(x)) \;|\; x ‚àà xs\})              \tag{distributivity of $‚à™$ for $‚Ñ≥ $}         \\
                       &= extend_{‚Ñ≥ }(joins ‚àò map_{\PM}(extend(k‚ÇÇ) ‚àò k‚ÇÅ))                         \tag{definition of $map_{\PM}$}              \\
                       &= extend(extend(k‚ÇÇ) ‚àò k‚ÇÅ)                                                 \tag{definition of $extend$}                 \\
\end{align*}
\end{proof}
\end{lemma}

\begin{lemma}
For a given $(‚Ñ≥  : Set ‚Üí Set)$ and $(ùìà : Set)$ where:
\begin{itemize}
\item $‚Ñ≥ $ is a monad.
\item $‚Ñ≥ $ is a monad state over $ùìà$.
\item $‚Ñ≥ $ is functorial in JoinSemilattice.
\end{itemize}
then $\PT(‚Ñ≥ )$ is a monad state over $ùìà$ with operators:
\begin{align*}
   get    &‚âî map_{‚Ñ≥ }(singleton)(get_{‚Ñ≥ })    \\
   put(ùìà) &‚âî map_{‚Ñ≥ }(singleton)(put_{‚Ñ≥ }(ùìà)) \\
\end{align*}
\end{lemma}

\begin{lemma}
For a given $(‚Ñ≥  : Set ‚Üí Set)$ and $(ùíÆùíÆ : Set ‚Üí Set)$ where:
\begin{itemize}
\item $‚Ñ≥ $ is a monad.
\item $‚Ñ≥ $ is a small-step monad over $ùíÆùíÆ$.
\item $‚Ñ≥ $ is functorial in join semilattice.
\item $ùíÆùíÆ$ is a functor.
\end{itemize}
then $\PT(‚Ñ≥ )$ is a small step monad over $(ùíÆùíÆ ‚àò \PM)$ with galois connection maps:
\begin{align*}
   Œ± &: ‚àÄ (A, B : Set), (A ‚Üí \PT(‚Ñ≥ )(B)) ‚Üí (ùíÆùíÆ(\PM(A)) ‚Üí ùíÆùíÆ(\PM(B))) \\
Œ±(f) &‚âî Œ±_{‚Ñ≥ }(joins ‚àò map_{\PM}(f))                                 \\
                                                                     \\
   Œ≥ &: ‚àÄ (A, B : Set), (ùíÆùíÆ(\PM(A)) ‚Üí ùíÆùíÆ(\PM(B))) ‚Üí (A ‚Üí \PT(‚Ñ≥ )(B)) \\
Œ≥(f) &‚âî Œ≥_{‚Ñ≥ }(f ‚àò map_{ùíÆùíÆ}(return_{\PM}))                           \\
\end{align*}
\begin{proof} of contractivity.
\begin{align*}
Œ± ‚àò Œ≥ &‚äë id                                                                   \\
                                                                              \\
(Œ± ‚àò Œ≥)(f) &= Œ±_{‚Ñ≥ }(joins ‚àò map_{\PM}(Œ≥_{‚Ñ≥ }(f ‚àò map_{ùíÆ ùíÆ }(return_{\PM})))) \\
\end{align*}
TODO.
(Requires $Œ±(1) = 1$ and $Œ±(g ‚àò f) = Œ±(g) ‚àò Œ±(f)$ (maybe $‚äë$?), and likewise for $Œ≥$.)
\end{proof}
\begin{proof} of expansivity.
\begin{align*}
\end{align*}
TODO.
\end{proof}
\end{lemma}

\begin{verbatim}

MonadSmallStep(ùìÇ )(ùíÆùíÆ) ‚àß (\PM ‚àò ùíÆùíÆ) Œ±‚áÑ Œ≥ (ùíÆùíÆ ‚àò \PM)
-------------------------------------
MonadSmallStep(\ST ùìÇ )(\PM ‚àò ùíÆ)

Œ± : ‚àÄ (A B : Set), (A ‚Üí \ST(ùìÇ )(B)) ‚Üí (\PM(ùíÆùíÆ(A) ‚Üí \PM(ùíÆùíÆ(B))))
Œ±(f) ‚âî extend‚Çö(Œ± ‚àò Œ±‚Çò(f))

Œ≥ : ‚àÄ (A B : Set), (\PM(ùíÆùíÆ(A) ‚Üí \PM(ùíÆùíÆ(B)))) ‚Üí (A ‚Üí \ST(ùìÇ )(B))
Œ≥(f) ‚âî extend‚Çö(Œ≥ ‚àò Œ≥‚Çò(f))
\end{verbatim}

% }}}

% StateT {{{

\subsection{$\ST$}
\label{section:Proofs:StateT}

\begin{verbatim}
\ST : Set ‚Üí (Set ‚Üí Set) ‚Üí (Set ‚Üí Set)
\ST(ùìà)(ùìÇ )(A) ‚âî ùìà ‚Üí ùìÇ  (A √ó ùìà)

Transformer(\ST(ùìà))
----------------------

lift : ‚àÄ (ùìÇ  : Set ‚Üí Set) (A : Set), ùìÇ  a ‚Üí \ST(ùìà)(ùìÇ )(A)
lift aM ‚âî Œª ùìà ‚Üí map‚Çò (,ùìà) aM

Monad(ùìÇ )
--------------------
Monad(\ST(ùìà)(ùìÇ ))

return : ‚àÄ (A : Set), A ‚Üí \ST(ùìà)(ùìÇ )(A)
return ‚âî lift ‚àò return‚Çò

extend : ‚àÄ (A B : Set), (A ‚Üí \ST(ùìà)(ùìÇ )(B)) ‚Üí (\ST(ùìà)(ùìÇ )(A) ‚Üí \ST(ùìà)(ùìÇ )(B))
extend(k)(aM) ‚âî Œª ùìà ‚Üí do‚Çò
  (a,ùìà') ‚Üê aM(ùìà)
  k(a)(ùìà')

JoinSemilattice(ùìà) ‚àß Monad(ùìÇ )
------------------------------------------
Functorial(JoinSemilattice)(\ST(ùìà)(ùìÇ ))

bot : \ST(ùìà)(ùìÇ )(A)
bot ‚âî Œª(ùìà)‚Üí (‚ä• ‚Çõ, ‚ä• ‚Çê)

‚äî : \ST(ùìà)(ùìÇ )(A) ‚Üí \ST(ùìà)(ùìÇ )(A) ‚Üí \ST(ùìà)(ùìÇ )(A)
aM‚ÇÅ ‚äî aM‚ÇÇ ‚âî Œª ùìà ‚Üí do‚Çò
  (a‚ÇÅ,ùìà‚ÇÅ) ‚Üê aM‚ÇÅ
  (a‚ÇÇ,ùìà‚ÇÇ) ‚Üê aM‚ÇÇ
  return (a‚ÇÅ ‚äî a‚ÇÇ, ùìà‚ÇÅ ‚äî ùìà‚ÇÇ)

MonadPlus(ùìÇ )
------------------------
MonadPlus(\ST(ùìà)(ùìÇ ))

‚ä• : ‚àÄ (A : Set), \ST(ùìà)(ùìÇ )(A)
‚ä• ‚âî lift ‚ä• ‚Çò

‚äî : ‚àÄ (A : Set), \ST(ùìà)(ùìÇ )(A)
aM‚ÇÅ ‚äî aM‚ÇÇ ‚âî Œª ùìà ‚Üí aM‚ÇÅ(ùìà) <+> aM‚ÇÇ(ùìà)

Monad(ùìÇ )
----------------------------
Monad\ST(ùìà)(\ST(ùìà)(ùìÇ ))

get : \ST ùìà ùìÇ  ùìà
get ‚âî Œª ùìà ‚Üí return (ùìà,ùìà)

put : ùìà ‚Üí \ST ùìà ùìÇ  1
put(ùìà) ‚âî Œª (ùìà') ‚Üí return (‚àô,ùìà)

MonadSmallStep(ùìÇ )(ùíÆùíÆ)
--------------------------------------
MonadSmallStep(\ST(ùìà)(ùìÇ ))(ùíÆùíÆ(\_ √ó ùìà))

Œ± : ‚àÄ (A B : Set), (A ‚Üí \ST(ùìà)(ùìÇ )(B)) ‚Üí (ùíÆùíÆ(A √ó ùìà) ‚Üí ùíÆùíÆ(B √ó ùìà))
Œ±(f) ‚âî Œ±‚Çò (Œª (a,ùìà) ‚Üí f(a)(ùìà))

Œ≥ : ‚àÄ (A B : Set), (ùíÆùíÆ(A √ó ùìà) ‚Üí ùíÆùíÆ(B √ó ùìà)) ‚Üí (A ‚Üí \ST(ùìà)(ùìÇ )(B))
Œ≥(f) ‚âî Œª(a,ùìà) ‚Üí Œ≥‚Çò (f)(a,s)
\end{verbatim}

% }}}

% }}}

% Bibliography {{{
\bibliography{davdar}{}
\bibliographystyle{plain}
% }}}

\end{document}
